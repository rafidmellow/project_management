/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Account
 *
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>;
/**
 * Model Session
 *
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>;
/**
 * Model VerificationToken
 *
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>;
/**
 * Model Project
 *
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>;
/**
 * Model ProjectStatus
 *
 */
export type ProjectStatus = $Result.DefaultSelection<Prisma.$ProjectStatusPayload>;
/**
 * Model Task
 *
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>;
/**
 * Model TaskAssignee
 *
 */
export type TaskAssignee = $Result.DefaultSelection<Prisma.$TaskAssigneePayload>;
/**
 * Model TeamMember
 *
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>;
/**
 * Model Event
 *
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>;
/**
 * Model Attendance
 *
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>;
/**
 * Model AttendanceSettings
 *
 */
export type AttendanceSettings = $Result.DefaultSelection<Prisma.$AttendanceSettingsPayload>;
/**
 * Model Activity
 *
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>;
/**
 * Model Document
 *
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>;
/**
 * Model AttendanceCorrectionRequest
 *
 */
export type AttendanceCorrectionRequest =
  $Result.DefaultSelection<Prisma.$AttendanceCorrectionRequestPayload>;
/**
 * Model Comment
 *
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>;
/**
 * Model TaskAttachment
 *
 */
export type TaskAttachment = $Result.DefaultSelection<Prisma.$TaskAttachmentPayload>;
/**
 * Model Role
 *
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>;
/**
 * Model Permission
 *
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>;
/**
 * Model RolePermission
 *
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(
    eventType: V,
    callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Sessions
   * const sessions = await prisma.session.findMany()
   * ```
   */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more VerificationTokens
   * const verificationTokens = await prisma.verificationToken.findMany()
   * ```
   */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Projects
   * const projects = await prisma.project.findMany()
   * ```
   */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectStatus`: Exposes CRUD operations for the **ProjectStatus** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ProjectStatuses
   * const projectStatuses = await prisma.projectStatus.findMany()
   * ```
   */
  get projectStatus(): Prisma.ProjectStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Tasks
   * const tasks = await prisma.task.findMany()
   * ```
   */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskAssignee`: Exposes CRUD operations for the **TaskAssignee** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TaskAssignees
   * const taskAssignees = await prisma.taskAssignee.findMany()
   * ```
   */
  get taskAssignee(): Prisma.TaskAssigneeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TeamMembers
   * const teamMembers = await prisma.teamMember.findMany()
   * ```
   */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Events
   * const events = await prisma.event.findMany()
   * ```
   */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Attendances
   * const attendances = await prisma.attendance.findMany()
   * ```
   */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceSettings`: Exposes CRUD operations for the **AttendanceSettings** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AttendanceSettings
   * const attendanceSettings = await prisma.attendanceSettings.findMany()
   * ```
   */
  get attendanceSettings(): Prisma.AttendanceSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Activities
   * const activities = await prisma.activity.findMany()
   * ```
   */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Documents
   * const documents = await prisma.document.findMany()
   * ```
   */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceCorrectionRequest`: Exposes CRUD operations for the **AttendanceCorrectionRequest** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AttendanceCorrectionRequests
   * const attendanceCorrectionRequests = await prisma.attendanceCorrectionRequest.findMany()
   * ```
   */
  get attendanceCorrectionRequest(): Prisma.AttendanceCorrectionRequestDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Comments
   * const comments = await prisma.comment.findMany()
   * ```
   */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskAttachment`: Exposes CRUD operations for the **TaskAttachment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TaskAttachments
   * const taskAttachments = await prisma.taskAttachment.findMany()
   * ```
   */
  get taskAttachment(): Prisma.TaskAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Permissions
   * const permissions = await prisma.permission.findMany()
   * ```
   */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more RolePermissions
   * const rolePermissions = await prisma.rolePermission.findMany()
   * ```
   */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<
    ReturnType<T>
  >;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
    ? _Either<O, K, strict>
    : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (
    k: infer I
  ) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> =
    IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<
    T,
    MaybeTupleToUnion<K>
  >;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    User: 'User';
    Account: 'Account';
    Session: 'Session';
    VerificationToken: 'VerificationToken';
    Project: 'Project';
    ProjectStatus: 'ProjectStatus';
    Task: 'Task';
    TaskAssignee: 'TaskAssignee';
    TeamMember: 'TeamMember';
    Event: 'Event';
    Attendance: 'Attendance';
    AttendanceSettings: 'AttendanceSettings';
    Activity: 'Activity';
    Document: 'Document';
    AttendanceCorrectionRequest: 'AttendanceCorrectionRequest';
    Comment: 'Comment';
    TaskAttachment: 'TaskAttachment';
    Role: 'Role';
    Permission: 'Permission';
    RolePermission: 'RolePermission';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<{ extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | 'user'
        | 'account'
        | 'session'
        | 'verificationToken'
        | 'project'
        | 'projectStatus'
        | 'task'
        | 'taskAssignee'
        | 'teamMember'
        | 'event'
        | 'attendance'
        | 'attendanceSettings'
        | 'activity'
        | 'document'
        | 'attendanceCorrectionRequest'
        | 'comment'
        | 'taskAttachment'
        | 'role'
        | 'permission'
        | 'rolePermission';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>;
        fields: Prisma.AccountFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAccount>;
          };
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AccountGroupByOutputType>[];
          };
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>;
            result: $Utils.Optional<AccountCountAggregateOutputType> | number;
          };
        };
      };
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>;
        fields: Prisma.SessionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSession>;
          };
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SessionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>;
            result: $Utils.Optional<SessionCountAggregateOutputType> | number;
          };
        };
      };
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>;
        fields: Prisma.VerificationTokenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateVerificationToken>;
          };
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[];
          };
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>;
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number;
          };
        };
      };
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>;
        fields: Prisma.ProjectFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>;
          };
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>;
          };
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[];
          };
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>;
          };
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>;
          };
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>;
          };
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>;
          };
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProject>;
          };
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ProjectGroupByOutputType>[];
          };
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>;
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number;
          };
        };
      };
      ProjectStatus: {
        payload: Prisma.$ProjectStatusPayload<ExtArgs>;
        fields: Prisma.ProjectStatusFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ProjectStatusFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ProjectStatusFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload>;
          };
          findFirst: {
            args: Prisma.ProjectStatusFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ProjectStatusFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload>;
          };
          findMany: {
            args: Prisma.ProjectStatusFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload>[];
          };
          create: {
            args: Prisma.ProjectStatusCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload>;
          };
          createMany: {
            args: Prisma.ProjectStatusCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ProjectStatusDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload>;
          };
          update: {
            args: Prisma.ProjectStatusUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload>;
          };
          deleteMany: {
            args: Prisma.ProjectStatusDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ProjectStatusUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ProjectStatusUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload>;
          };
          aggregate: {
            args: Prisma.ProjectStatusAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProjectStatus>;
          };
          groupBy: {
            args: Prisma.ProjectStatusGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ProjectStatusGroupByOutputType>[];
          };
          count: {
            args: Prisma.ProjectStatusCountArgs<ExtArgs>;
            result: $Utils.Optional<ProjectStatusCountAggregateOutputType> | number;
          };
        };
      };
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>;
        fields: Prisma.TaskFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
          };
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
          };
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[];
          };
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
          };
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
          };
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
          };
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
          };
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTask>;
          };
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TaskGroupByOutputType>[];
          };
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>;
            result: $Utils.Optional<TaskCountAggregateOutputType> | number;
          };
        };
      };
      TaskAssignee: {
        payload: Prisma.$TaskAssigneePayload<ExtArgs>;
        fields: Prisma.TaskAssigneeFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TaskAssigneeFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TaskAssigneeFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>;
          };
          findFirst: {
            args: Prisma.TaskAssigneeFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TaskAssigneeFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>;
          };
          findMany: {
            args: Prisma.TaskAssigneeFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>[];
          };
          create: {
            args: Prisma.TaskAssigneeCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>;
          };
          createMany: {
            args: Prisma.TaskAssigneeCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.TaskAssigneeDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>;
          };
          update: {
            args: Prisma.TaskAssigneeUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>;
          };
          deleteMany: {
            args: Prisma.TaskAssigneeDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TaskAssigneeUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.TaskAssigneeUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>;
          };
          aggregate: {
            args: Prisma.TaskAssigneeAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTaskAssignee>;
          };
          groupBy: {
            args: Prisma.TaskAssigneeGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TaskAssigneeGroupByOutputType>[];
          };
          count: {
            args: Prisma.TaskAssigneeCountArgs<ExtArgs>;
            result: $Utils.Optional<TaskAssigneeCountAggregateOutputType> | number;
          };
        };
      };
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>;
        fields: Prisma.TeamMemberFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[];
          };
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTeamMember>;
          };
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TeamMemberGroupByOutputType>[];
          };
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>;
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number;
          };
        };
      };
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>;
        fields: Prisma.EventFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[];
          };
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateEvent>;
          };
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>;
            result: $Utils.Optional<EventGroupByOutputType>[];
          };
          count: {
            args: Prisma.EventCountArgs<ExtArgs>;
            result: $Utils.Optional<EventCountAggregateOutputType> | number;
          };
        };
      };
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>;
        fields: Prisma.AttendanceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>;
          };
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>;
          };
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[];
          };
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>;
          };
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>;
          };
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>;
          };
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>;
          };
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAttendance>;
          };
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AttendanceGroupByOutputType>[];
          };
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>;
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number;
          };
        };
      };
      AttendanceSettings: {
        payload: Prisma.$AttendanceSettingsPayload<ExtArgs>;
        fields: Prisma.AttendanceSettingsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AttendanceSettingsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceSettingsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AttendanceSettingsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceSettingsPayload>;
          };
          findFirst: {
            args: Prisma.AttendanceSettingsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceSettingsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AttendanceSettingsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceSettingsPayload>;
          };
          findMany: {
            args: Prisma.AttendanceSettingsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceSettingsPayload>[];
          };
          create: {
            args: Prisma.AttendanceSettingsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceSettingsPayload>;
          };
          createMany: {
            args: Prisma.AttendanceSettingsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.AttendanceSettingsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceSettingsPayload>;
          };
          update: {
            args: Prisma.AttendanceSettingsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceSettingsPayload>;
          };
          deleteMany: {
            args: Prisma.AttendanceSettingsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AttendanceSettingsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AttendanceSettingsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceSettingsPayload>;
          };
          aggregate: {
            args: Prisma.AttendanceSettingsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAttendanceSettings>;
          };
          groupBy: {
            args: Prisma.AttendanceSettingsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AttendanceSettingsGroupByOutputType>[];
          };
          count: {
            args: Prisma.AttendanceSettingsCountArgs<ExtArgs>;
            result: $Utils.Optional<AttendanceSettingsCountAggregateOutputType> | number;
          };
        };
      };
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>;
        fields: Prisma.ActivityFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>;
          };
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>;
          };
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[];
          };
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>;
          };
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>;
          };
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>;
          };
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>;
          };
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateActivity>;
          };
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ActivityGroupByOutputType>[];
          };
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>;
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number;
          };
        };
      };
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>;
        fields: Prisma.DocumentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[];
          };
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDocument>;
          };
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DocumentGroupByOutputType>[];
          };
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>;
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number;
          };
        };
      };
      AttendanceCorrectionRequest: {
        payload: Prisma.$AttendanceCorrectionRequestPayload<ExtArgs>;
        fields: Prisma.AttendanceCorrectionRequestFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AttendanceCorrectionRequestFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceCorrectionRequestPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AttendanceCorrectionRequestFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceCorrectionRequestPayload>;
          };
          findFirst: {
            args: Prisma.AttendanceCorrectionRequestFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceCorrectionRequestPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AttendanceCorrectionRequestFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceCorrectionRequestPayload>;
          };
          findMany: {
            args: Prisma.AttendanceCorrectionRequestFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceCorrectionRequestPayload>[];
          };
          create: {
            args: Prisma.AttendanceCorrectionRequestCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceCorrectionRequestPayload>;
          };
          createMany: {
            args: Prisma.AttendanceCorrectionRequestCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.AttendanceCorrectionRequestDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceCorrectionRequestPayload>;
          };
          update: {
            args: Prisma.AttendanceCorrectionRequestUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceCorrectionRequestPayload>;
          };
          deleteMany: {
            args: Prisma.AttendanceCorrectionRequestDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AttendanceCorrectionRequestUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AttendanceCorrectionRequestUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AttendanceCorrectionRequestPayload>;
          };
          aggregate: {
            args: Prisma.AttendanceCorrectionRequestAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAttendanceCorrectionRequest>;
          };
          groupBy: {
            args: Prisma.AttendanceCorrectionRequestGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AttendanceCorrectionRequestGroupByOutputType>[];
          };
          count: {
            args: Prisma.AttendanceCorrectionRequestCountArgs<ExtArgs>;
            result: $Utils.Optional<AttendanceCorrectionRequestCountAggregateOutputType> | number;
          };
        };
      };
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>;
        fields: Prisma.CommentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[];
          };
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateComment>;
          };
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CommentGroupByOutputType>[];
          };
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>;
            result: $Utils.Optional<CommentCountAggregateOutputType> | number;
          };
        };
      };
      TaskAttachment: {
        payload: Prisma.$TaskAttachmentPayload<ExtArgs>;
        fields: Prisma.TaskAttachmentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TaskAttachmentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TaskAttachmentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>;
          };
          findFirst: {
            args: Prisma.TaskAttachmentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TaskAttachmentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>;
          };
          findMany: {
            args: Prisma.TaskAttachmentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>[];
          };
          create: {
            args: Prisma.TaskAttachmentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>;
          };
          createMany: {
            args: Prisma.TaskAttachmentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.TaskAttachmentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>;
          };
          update: {
            args: Prisma.TaskAttachmentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>;
          };
          deleteMany: {
            args: Prisma.TaskAttachmentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TaskAttachmentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.TaskAttachmentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>;
          };
          aggregate: {
            args: Prisma.TaskAttachmentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTaskAttachment>;
          };
          groupBy: {
            args: Prisma.TaskAttachmentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TaskAttachmentGroupByOutputType>[];
          };
          count: {
            args: Prisma.TaskAttachmentCountArgs<ExtArgs>;
            result: $Utils.Optional<TaskAttachmentCountAggregateOutputType> | number;
          };
        };
      };
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>;
        fields: Prisma.RoleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[];
          };
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRole>;
          };
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RoleGroupByOutputType>[];
          };
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>;
            result: $Utils.Optional<RoleCountAggregateOutputType> | number;
          };
        };
      };
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>;
        fields: Prisma.PermissionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>;
          };
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>;
          };
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[];
          };
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>;
          };
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>;
          };
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>;
          };
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>;
          };
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePermission>;
          };
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PermissionGroupByOutputType>[];
          };
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>;
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number;
          };
        };
      };
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>;
        fields: Prisma.RolePermissionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>;
          };
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>;
          };
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[];
          };
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>;
          };
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>;
          };
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>;
          };
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>;
          };
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRolePermission>;
          };
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RolePermissionGroupByOutputType>[];
          };
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>;
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    user?: UserOmit;
    account?: AccountOmit;
    session?: SessionOmit;
    verificationToken?: VerificationTokenOmit;
    project?: ProjectOmit;
    projectStatus?: ProjectStatusOmit;
    task?: TaskOmit;
    taskAssignee?: TaskAssigneeOmit;
    teamMember?: TeamMemberOmit;
    event?: EventOmit;
    attendance?: AttendanceOmit;
    attendanceSettings?: AttendanceSettingsOmit;
    activity?: ActivityOmit;
    document?: DocumentOmit;
    attendanceCorrectionRequest?: AttendanceCorrectionRequestOmit;
    comment?: CommentOmit;
    taskAttachment?: TaskAttachmentOmit;
    role?: RoleOmit;
    permission?: PermissionOmit;
    rolePermission?: RolePermissionOmit;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition
    ? T['emit'] extends 'event'
      ? T['level']
      : never
    : never;
  export type GetEvents<T extends any> =
    T extends Array<LogLevel | LogDefinition>
      ? GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
      : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>
  ) => $Utils.JsPromise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number;
    activities: number;
    attendanceRecords: number;
    correctionRequests: number;
    comments: number;
    documents: number;
    projects: number;
    sessions: number;
    taskAssignments: number;
    taskAttachments: number;
    teams: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs;
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs;
    attendanceRecords?: boolean | UserCountOutputTypeCountAttendanceRecordsArgs;
    correctionRequests?: boolean | UserCountOutputTypeCountCorrectionRequestsArgs;
    comments?: boolean | UserCountOutputTypeCountCommentsArgs;
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs;
    projects?: boolean | UserCountOutputTypeCountProjectsArgs;
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs;
    taskAssignments?: boolean | UserCountOutputTypeCountTaskAssignmentsArgs;
    taskAttachments?: boolean | UserCountOutputTypeCountTaskAttachmentsArgs;
    teams?: boolean | UserCountOutputTypeCountTeamsArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ActivityWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceRecordsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AttendanceWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCorrectionRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AttendanceCorrectionRequestWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommentWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DocumentWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProjectWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskAssignmentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TaskAssigneeWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskAttachmentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TaskAttachmentWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamMemberWhereInput;
  };

  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    activities: number;
    attendances: number;
    events: number;
    statuses: number;
    tasks: number;
    teamMembers: number;
  };

  export type ProjectCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    activities?: boolean | ProjectCountOutputTypeCountActivitiesArgs;
    attendances?: boolean | ProjectCountOutputTypeCountAttendancesArgs;
    events?: boolean | ProjectCountOutputTypeCountEventsArgs;
    statuses?: boolean | ProjectCountOutputTypeCountStatusesArgs;
    tasks?: boolean | ProjectCountOutputTypeCountTasksArgs;
    teamMembers?: boolean | ProjectCountOutputTypeCountTeamMembersArgs;
  };

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountActivitiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ActivityWhereInput;
  };

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAttendancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AttendanceWhereInput;
  };

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountEventsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EventWhereInput;
  };

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountStatusesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProjectStatusWhereInput;
  };

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTasksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TaskWhereInput;
  };

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTeamMembersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamMemberWhereInput;
  };

  /**
   * Count Type ProjectStatusCountOutputType
   */

  export type ProjectStatusCountOutputType = {
    tasks: number;
  };

  export type ProjectStatusCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    tasks?: boolean | ProjectStatusCountOutputTypeCountTasksArgs;
  };

  // Custom InputTypes
  /**
   * ProjectStatusCountOutputType without action
   */
  export type ProjectStatusCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProjectStatusCountOutputType
     */
    select?: ProjectStatusCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ProjectStatusCountOutputType without action
   */
  export type ProjectStatusCountOutputTypeCountTasksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TaskWhereInput;
  };

  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    activities: number;
    attendances: number;
    comments: number;
    subtasks: number;
    assignees: number;
    attachments: number;
  };

  export type TaskCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    activities?: boolean | TaskCountOutputTypeCountActivitiesArgs;
    attendances?: boolean | TaskCountOutputTypeCountAttendancesArgs;
    comments?: boolean | TaskCountOutputTypeCountCommentsArgs;
    subtasks?: boolean | TaskCountOutputTypeCountSubtasksArgs;
    assignees?: boolean | TaskCountOutputTypeCountAssigneesArgs;
    attachments?: boolean | TaskCountOutputTypeCountAttachmentsArgs;
  };

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountActivitiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ActivityWhereInput;
  };

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAttendancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AttendanceWhereInput;
  };

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommentWhereInput;
  };

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountSubtasksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TaskWhereInput;
  };

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAssigneesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TaskAssigneeWhereInput;
  };

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAttachmentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TaskAttachmentWhereInput;
  };

  /**
   * Count Type AttendanceCountOutputType
   */

  export type AttendanceCountOutputType = {
    correctionRequests: number;
  };

  export type AttendanceCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    correctionRequests?: boolean | AttendanceCountOutputTypeCountCorrectionRequestsArgs;
  };

  // Custom InputTypes
  /**
   * AttendanceCountOutputType without action
   */
  export type AttendanceCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceCountOutputType
     */
    select?: AttendanceCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AttendanceCountOutputType without action
   */
  export type AttendanceCountOutputTypeCountCorrectionRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AttendanceCorrectionRequestWhereInput;
  };

  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    permissions: number;
  };

  export type RoleCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs;
  };

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RolePermissionWhereInput;
  };

  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number;
  };

  export type PermissionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs;
  };

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RolePermissionWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    emailVerified: Date | null;
    image: string | null;
    password: string | null;
    role: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    lastLogin: Date | null;
    bio: string | null;
    department: string | null;
    jobTitle: string | null;
    location: string | null;
    phone: string | null;
    skills: string | null;
    active: boolean | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    emailVerified: Date | null;
    image: string | null;
    password: string | null;
    role: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    lastLogin: Date | null;
    bio: string | null;
    department: string | null;
    jobTitle: string | null;
    location: string | null;
    phone: string | null;
    skills: string | null;
    active: boolean | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    name: number;
    email: number;
    emailVerified: number;
    image: number;
    password: number;
    role: number;
    createdAt: number;
    updatedAt: number;
    lastLogin: number;
    bio: number;
    department: number;
    jobTitle: number;
    location: number;
    phone: number;
    skills: number;
    active: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    password?: true;
    role?: true;
    createdAt?: true;
    updatedAt?: true;
    lastLogin?: true;
    bio?: true;
    department?: true;
    jobTitle?: true;
    location?: true;
    phone?: true;
    skills?: true;
    active?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    password?: true;
    role?: true;
    createdAt?: true;
    updatedAt?: true;
    lastLogin?: true;
    bio?: true;
    department?: true;
    jobTitle?: true;
    location?: true;
    phone?: true;
    skills?: true;
    active?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    password?: true;
    role?: true;
    createdAt?: true;
    updatedAt?: true;
    lastLogin?: true;
    bio?: true;
    department?: true;
    jobTitle?: true;
    location?: true;
    phone?: true;
    skills?: true;
    active?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: UserWhereInput;
      orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[];
      by: UserScalarFieldEnum[] | UserScalarFieldEnum;
      having?: UserScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: UserCountAggregateInputType | true;
      _min?: UserMinAggregateInputType;
      _max?: UserMaxAggregateInputType;
    };

  export type UserGroupByOutputType = {
    id: string;
    name: string | null;
    email: string;
    emailVerified: Date | null;
    image: string | null;
    password: string | null;
    role: string;
    createdAt: Date;
    updatedAt: Date;
    lastLogin: Date | null;
    bio: string | null;
    department: string | null;
    jobTitle: string | null;
    location: string | null;
    phone: string | null;
    skills: string | null;
    active: boolean;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        email?: boolean;
        emailVerified?: boolean;
        image?: boolean;
        password?: boolean;
        role?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        lastLogin?: boolean;
        bio?: boolean;
        department?: boolean;
        jobTitle?: boolean;
        location?: boolean;
        phone?: boolean;
        skills?: boolean;
        active?: boolean;
        accounts?: boolean | User$accountsArgs<ExtArgs>;
        activities?: boolean | User$activitiesArgs<ExtArgs>;
        attendanceRecords?: boolean | User$attendanceRecordsArgs<ExtArgs>;
        correctionRequests?: boolean | User$correctionRequestsArgs<ExtArgs>;
        attendanceSettings?: boolean | User$attendanceSettingsArgs<ExtArgs>;
        comments?: boolean | User$commentsArgs<ExtArgs>;
        documents?: boolean | User$documentsArgs<ExtArgs>;
        projects?: boolean | User$projectsArgs<ExtArgs>;
        sessions?: boolean | User$sessionsArgs<ExtArgs>;
        taskAssignments?: boolean | User$taskAssignmentsArgs<ExtArgs>;
        taskAttachments?: boolean | User$taskAttachmentsArgs<ExtArgs>;
        teams?: boolean | User$teamsArgs<ExtArgs>;
        _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['user']
    >;

  export type UserSelectScalar = {
    id?: boolean;
    name?: boolean;
    email?: boolean;
    emailVerified?: boolean;
    image?: boolean;
    password?: boolean;
    role?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    lastLogin?: boolean;
    bio?: boolean;
    department?: boolean;
    jobTitle?: boolean;
    location?: boolean;
    phone?: boolean;
    skills?: boolean;
    active?: boolean;
  };

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'email'
      | 'emailVerified'
      | 'image'
      | 'password'
      | 'role'
      | 'createdAt'
      | 'updatedAt'
      | 'lastLogin'
      | 'bio'
      | 'department'
      | 'jobTitle'
      | 'location'
      | 'phone'
      | 'skills'
      | 'active',
      ExtArgs['result']['user']
    >;
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>;
    activities?: boolean | User$activitiesArgs<ExtArgs>;
    attendanceRecords?: boolean | User$attendanceRecordsArgs<ExtArgs>;
    correctionRequests?: boolean | User$correctionRequestsArgs<ExtArgs>;
    attendanceSettings?: boolean | User$attendanceSettingsArgs<ExtArgs>;
    comments?: boolean | User$commentsArgs<ExtArgs>;
    documents?: boolean | User$documentsArgs<ExtArgs>;
    projects?: boolean | User$projectsArgs<ExtArgs>;
    sessions?: boolean | User$sessionsArgs<ExtArgs>;
    taskAssignments?: boolean | User$taskAssignmentsArgs<ExtArgs>;
    taskAttachments?: boolean | User$taskAttachmentsArgs<ExtArgs>;
    teams?: boolean | User$teamsArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'User';
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[];
      activities: Prisma.$ActivityPayload<ExtArgs>[];
      attendanceRecords: Prisma.$AttendancePayload<ExtArgs>[];
      correctionRequests: Prisma.$AttendanceCorrectionRequestPayload<ExtArgs>[];
      attendanceSettings: Prisma.$AttendanceSettingsPayload<ExtArgs> | null;
      comments: Prisma.$CommentPayload<ExtArgs>[];
      documents: Prisma.$DocumentPayload<ExtArgs>[];
      projects: Prisma.$ProjectPayload<ExtArgs>[];
      sessions: Prisma.$SessionPayload<ExtArgs>[];
      taskAssignments: Prisma.$TaskAssigneePayload<ExtArgs>[];
      taskAttachments: Prisma.$TaskAttachmentPayload<ExtArgs>[];
      teams: Prisma.$TeamMemberPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string | null;
        email: string;
        emailVerified: Date | null;
        image: string | null;
        password: string | null;
        role: string;
        createdAt: Date;
        updatedAt: Date;
        lastLogin: Date | null;
        bio: string | null;
        department: string | null;
        jobTitle: string | null;
        location: string | null;
        phone: string | null;
        skills: string | null;
        active: boolean;
      },
      ExtArgs['result']['user']
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<
    Prisma.$UserPayload,
    S
  >;

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    UserFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User']; meta: { name: 'User' } };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$accountsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$activitiesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    attendanceRecords<T extends User$attendanceRecordsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$attendanceRecordsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    correctionRequests<T extends User$correctionRequestsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$correctionRequestsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AttendanceCorrectionRequestPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    attendanceSettings<T extends User$attendanceSettingsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$attendanceSettingsArgs<ExtArgs>>
    ): Prisma__AttendanceSettingsClient<
      $Result.GetResult<
        Prisma.$AttendanceSettingsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    comments<T extends User$commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    documents<T extends User$documentsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$documentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    projects<T extends User$projectsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$projectsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$sessionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    taskAssignments<T extends User$taskAssignmentsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$taskAssignmentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    taskAttachments<T extends User$taskAttachmentsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$taskAttachmentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    teams<T extends User$teamsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$teamsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<'User', 'String'>;
    readonly name: FieldRef<'User', 'String'>;
    readonly email: FieldRef<'User', 'String'>;
    readonly emailVerified: FieldRef<'User', 'DateTime'>;
    readonly image: FieldRef<'User', 'String'>;
    readonly password: FieldRef<'User', 'String'>;
    readonly role: FieldRef<'User', 'String'>;
    readonly createdAt: FieldRef<'User', 'DateTime'>;
    readonly updatedAt: FieldRef<'User', 'DateTime'>;
    readonly lastLogin: FieldRef<'User', 'DateTime'>;
    readonly bio: FieldRef<'User', 'String'>;
    readonly department: FieldRef<'User', 'String'>;
    readonly jobTitle: FieldRef<'User', 'String'>;
    readonly location: FieldRef<'User', 'String'>;
    readonly phone: FieldRef<'User', 'String'>;
    readonly skills: FieldRef<'User', 'String'>;
    readonly active: FieldRef<'User', 'Boolean'>;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      /**
       * Filter, which Users to fetch.
       */
      where?: UserWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Users to fetch.
       */
      orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Users.
       */
      cursor?: UserWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Users from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Users.
       */
      skip?: number;
      distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
    };

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.accounts
   */
  export type User$accountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    where?: AccountWhereInput;
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    cursor?: AccountWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * User.activities
   */
  export type User$activitiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null;
    where?: ActivityWhereInput;
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[];
    cursor?: ActivityWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[];
  };

  /**
   * User.attendanceRecords
   */
  export type User$attendanceRecordsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null;
    where?: AttendanceWhereInput;
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[];
    cursor?: AttendanceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[];
  };

  /**
   * User.correctionRequests
   */
  export type User$correctionRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceCorrectionRequest
     */
    select?: AttendanceCorrectionRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceCorrectionRequest
     */
    omit?: AttendanceCorrectionRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCorrectionRequestInclude<ExtArgs> | null;
    where?: AttendanceCorrectionRequestWhereInput;
    orderBy?:
      | AttendanceCorrectionRequestOrderByWithRelationInput
      | AttendanceCorrectionRequestOrderByWithRelationInput[];
    cursor?: AttendanceCorrectionRequestWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | AttendanceCorrectionRequestScalarFieldEnum
      | AttendanceCorrectionRequestScalarFieldEnum[];
  };

  /**
   * User.attendanceSettings
   */
  export type User$attendanceSettingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceSettings
     */
    select?: AttendanceSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceSettings
     */
    omit?: AttendanceSettingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSettingsInclude<ExtArgs> | null;
    where?: AttendanceSettingsWhereInput;
  };

  /**
   * User.comments
   */
  export type User$commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    where?: CommentWhereInput;
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[];
    cursor?: CommentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * User.documents
   */
  export type User$documentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    where?: DocumentWhereInput;
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    cursor?: DocumentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * User.projects
   */
  export type User$projectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null;
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[];
    cursor?: ProjectWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[];
  };

  /**
   * User.sessions
   */
  export type User$sessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    where?: SessionWhereInput;
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    cursor?: SessionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * User.taskAssignments
   */
  export type User$taskAssignmentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null;
    where?: TaskAssigneeWhereInput;
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[];
    cursor?: TaskAssigneeWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[];
  };

  /**
   * User.taskAttachments
   */
  export type User$taskAttachmentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null;
    where?: TaskAttachmentWhereInput;
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[];
    cursor?: TaskAttachmentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[];
  };

  /**
   * User.teams
   */
  export type User$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    where?: TeamMemberWhereInput;
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
    cursor?: TeamMemberWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
    };

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null;
  };

  export type AccountSumAggregateOutputType = {
    expires_at: number | null;
  };

  export type AccountMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: string | null;
    provider: string | null;
    providerAccountId: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
  };

  export type AccountMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: string | null;
    provider: string | null;
    providerAccountId: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
  };

  export type AccountCountAggregateOutputType = {
    id: number;
    userId: number;
    type: number;
    provider: number;
    providerAccountId: number;
    refresh_token: number;
    access_token: number;
    expires_at: number;
    token_type: number;
    scope: number;
    id_token: number;
    session_state: number;
    _all: number;
  };

  export type AccountAvgAggregateInputType = {
    expires_at?: true;
  };

  export type AccountSumAggregateInputType = {
    expires_at?: true;
  };

  export type AccountMinAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
  };

  export type AccountMaxAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
  };

  export type AccountCountAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
    _all?: true;
  };

  export type AccountAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Accounts
     **/
    _count?: true | AccountCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AccountAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AccountSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AccountMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AccountMaxAggregateInputType;
  };

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
    [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>;
  };

  export type AccountGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[];
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum;
    having?: AccountScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AccountCountAggregateInputType | true;
    _avg?: AccountAvgAggregateInputType;
    _sum?: AccountSumAggregateInputType;
    _min?: AccountMinAggregateInputType;
    _max?: AccountMaxAggregateInputType;
  };

  export type AccountGroupByOutputType = {
    id: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AccountGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
          : GetScalarType<T[P], AccountGroupByOutputType[P]>;
      }
    >
  >;

  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        type?: boolean;
        provider?: boolean;
        providerAccountId?: boolean;
        refresh_token?: boolean;
        access_token?: boolean;
        expires_at?: boolean;
        token_type?: boolean;
        scope?: boolean;
        id_token?: boolean;
        session_state?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['account']
    >;

  export type AccountSelectScalar = {
    id?: boolean;
    userId?: boolean;
    type?: boolean;
    provider?: boolean;
    providerAccountId?: boolean;
    refresh_token?: boolean;
    access_token?: boolean;
    expires_at?: boolean;
    token_type?: boolean;
    scope?: boolean;
    id_token?: boolean;
    session_state?: boolean;
  };

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'userId'
      | 'type'
      | 'provider'
      | 'providerAccountId'
      | 'refresh_token'
      | 'access_token'
      | 'expires_at'
      | 'token_type'
      | 'scope'
      | 'id_token'
      | 'session_state',
      ExtArgs['result']['account']
    >;
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Account';
      objects: {
        user: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          userId: string;
          type: string;
          provider: string;
          providerAccountId: string;
          refresh_token: string | null;
          access_token: string | null;
          expires_at: number | null;
          token_type: string | null;
          scope: string | null;
          id_token: string | null;
          session_state: string | null;
        },
        ExtArgs['result']['account']
      >;
      composites: {};
    };

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> =
    $Result.GetResult<Prisma.$AccountPayload, S>;

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    AccountFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: AccountCountAggregateInputType | true;
  };

  export interface AccountDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account']; meta: { name: 'Account' } };
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     *
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     *
     */
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     *
     */
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
     **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AccountAggregateArgs>(
      args: Subset<T, AccountAggregateArgs>
    ): Prisma.PrismaPromise<GetAccountAggregateType<T>>;

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Account model
     */
    readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<'Account', 'String'>;
    readonly userId: FieldRef<'Account', 'String'>;
    readonly type: FieldRef<'Account', 'String'>;
    readonly provider: FieldRef<'Account', 'String'>;
    readonly providerAccountId: FieldRef<'Account', 'String'>;
    readonly refresh_token: FieldRef<'Account', 'String'>;
    readonly access_token: FieldRef<'Account', 'String'>;
    readonly expires_at: FieldRef<'Account', 'Int'>;
    readonly token_type: FieldRef<'Account', 'String'>;
    readonly scope: FieldRef<'Account', 'String'>;
    readonly id_token: FieldRef<'Account', 'String'>;
    readonly session_state: FieldRef<'Account', 'String'>;
  }

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account create
   */
  export type AccountCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
  };

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Account update
   */
  export type AccountUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>;
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to update.
     */
    limit?: number;
  };

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput;
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
  };

  /**
   * Account delete
   */
  export type AccountDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number;
  };

  /**
   * Account without action
   */
  export type AccountDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
  };

  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  export type SessionMinAggregateOutputType = {
    id: string | null;
    sessionToken: string | null;
    userId: string | null;
    expires: Date | null;
  };

  export type SessionMaxAggregateOutputType = {
    id: string | null;
    sessionToken: string | null;
    userId: string | null;
    expires: Date | null;
  };

  export type SessionCountAggregateOutputType = {
    id: number;
    sessionToken: number;
    userId: number;
    expires: number;
    _all: number;
  };

  export type SessionMinAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
  };

  export type SessionMaxAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
  };

  export type SessionCountAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
    _all?: true;
  };

  export type SessionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Sessions
     **/
    _count?: true | SessionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SessionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SessionMaxAggregateInputType;
  };

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
    [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>;
  };

  export type SessionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[];
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum;
    having?: SessionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SessionCountAggregateInputType | true;
    _min?: SessionMinAggregateInputType;
    _max?: SessionMaxAggregateInputType;
  };

  export type SessionGroupByOutputType = {
    id: string;
    sessionToken: string;
    userId: string;
    expires: Date;
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> & {
        [P in keyof T & keyof SessionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
          : GetScalarType<T[P], SessionGroupByOutputType[P]>;
      }
    >
  >;

  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        sessionToken?: boolean;
        userId?: boolean;
        expires?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['session']
    >;

  export type SessionSelectScalar = {
    id?: boolean;
    sessionToken?: boolean;
    userId?: boolean;
    expires?: boolean;
  };

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<'id' | 'sessionToken' | 'userId' | 'expires', ExtArgs['result']['session']>;
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Session';
      objects: {
        user: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          sessionToken: string;
          userId: string;
          expires: Date;
        },
        ExtArgs['result']['session']
      >;
      composites: {};
    };

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> =
    $Result.GetResult<Prisma.$SessionPayload, S>;

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    SessionFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: SessionCountAggregateInputType | true;
  };

  export interface SessionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session']; meta: { name: 'Session' } };
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     *
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     *
     */
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     *
     */
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
     **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SessionAggregateArgs>(
      args: Subset<T, SessionAggregateArgs>
    ): Prisma.PrismaPromise<GetSessionAggregateType<T>>;

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Session model
     */
    readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<'Session', 'String'>;
    readonly sessionToken: FieldRef<'Session', 'String'>;
    readonly userId: FieldRef<'Session', 'String'>;
    readonly expires: FieldRef<'Session', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session create
   */
  export type SessionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
  };

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Session update
   */
  export type SessionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to update.
     */
    limit?: number;
  };

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput;
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
  };

  /**
   * Session delete
   */
  export type SessionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number;
  };

  /**
   * Session without action
   */
  export type SessionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
  };

  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null;
    _min: VerificationTokenMinAggregateOutputType | null;
    _max: VerificationTokenMaxAggregateOutputType | null;
  };

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null;
    token: string | null;
    expires: Date | null;
  };

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null;
    token: string | null;
    expires: Date | null;
  };

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number;
    token: number;
    expires: number;
    _all: number;
  };

  export type VerificationTokenMinAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
  };

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
  };

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
    _all?: true;
  };

  export type VerificationTokenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned VerificationTokens
     **/
    _count?: true | VerificationTokenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: VerificationTokenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: VerificationTokenMaxAggregateInputType;
  };

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
    [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>;
  };

  export type VerificationTokenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VerificationTokenWhereInput;
    orderBy?:
      | VerificationTokenOrderByWithAggregationInput
      | VerificationTokenOrderByWithAggregationInput[];
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum;
    having?: VerificationTokenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: VerificationTokenCountAggregateInputType | true;
    _min?: VerificationTokenMinAggregateInputType;
    _max?: VerificationTokenMaxAggregateInputType;
  };

  export type VerificationTokenGroupByOutputType = {
    identifier: string;
    token: string;
    expires: Date;
    _count: VerificationTokenCountAggregateOutputType | null;
    _min: VerificationTokenMinAggregateOutputType | null;
    _max: VerificationTokenMaxAggregateOutputType | null;
  };

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<VerificationTokenGroupByOutputType, T['by']> & {
          [P in keyof T & keyof VerificationTokenGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>;
        }
      >
    >;

  export type VerificationTokenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs['result']['verificationToken']
  >;

  export type VerificationTokenSelectScalar = {
    identifier?: boolean;
    token?: boolean;
    expires?: boolean;
  };

  export type VerificationTokenOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'identifier' | 'token' | 'expires',
    ExtArgs['result']['verificationToken']
  >;

  export type $VerificationTokenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'VerificationToken';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        identifier: string;
        token: string;
        expires: Date;
      },
      ExtArgs['result']['verificationToken']
    >;
    composites: {};
  };

  type VerificationTokenGetPayload<
    S extends boolean | null | undefined | VerificationTokenDefaultArgs,
  > = $Result.GetResult<Prisma.$VerificationTokenPayload, S>;

  type VerificationTokenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: VerificationTokenCountAggregateInputType | true;
  };

  export interface VerificationTokenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'];
      meta: { name: 'VerificationToken' };
    };
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(
      args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     *
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     *
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     *
     */
    findMany<T extends VerificationTokenFindManyArgs>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     *
     */
    create<T extends VerificationTokenCreateArgs>(
      args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends VerificationTokenCreateManyArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     *
     */
    delete<T extends VerificationTokenDeleteArgs>(
      args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends VerificationTokenUpdateArgs>(
      args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(
      args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
     **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends VerificationTokenAggregateArgs>(
      args: Subset<T, VerificationTokenAggregateArgs>
    ): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>;

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetVerificationTokenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the VerificationToken model
     */
    readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<'VerificationToken', 'String'>;
    readonly token: FieldRef<'VerificationToken', 'String'>;
    readonly expires: FieldRef<'VerificationToken', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>;
  };

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>;
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>;
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput;
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number;
  };

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput;
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>;
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>;
  };

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput;
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number;
  };

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
  };

  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null;
    _avg: ProjectAvgAggregateOutputType | null;
    _sum: ProjectSumAggregateOutputType | null;
    _min: ProjectMinAggregateOutputType | null;
    _max: ProjectMaxAggregateOutputType | null;
  };

  export type ProjectAvgAggregateOutputType = {
    estimatedTime: number | null;
    totalTimeSpent: number | null;
  };

  export type ProjectSumAggregateOutputType = {
    estimatedTime: number | null;
    totalTimeSpent: number | null;
  };

  export type ProjectMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    startDate: Date | null;
    endDate: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdById: string | null;
    dueDate: Date | null;
    estimatedTime: number | null;
    totalTimeSpent: number | null;
  };

  export type ProjectMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    startDate: Date | null;
    endDate: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdById: string | null;
    dueDate: Date | null;
    estimatedTime: number | null;
    totalTimeSpent: number | null;
  };

  export type ProjectCountAggregateOutputType = {
    id: number;
    title: number;
    description: number;
    startDate: number;
    endDate: number;
    createdAt: number;
    updatedAt: number;
    createdById: number;
    dueDate: number;
    estimatedTime: number;
    totalTimeSpent: number;
    _all: number;
  };

  export type ProjectAvgAggregateInputType = {
    estimatedTime?: true;
    totalTimeSpent?: true;
  };

  export type ProjectSumAggregateInputType = {
    estimatedTime?: true;
    totalTimeSpent?: true;
  };

  export type ProjectMinAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    startDate?: true;
    endDate?: true;
    createdAt?: true;
    updatedAt?: true;
    createdById?: true;
    dueDate?: true;
    estimatedTime?: true;
    totalTimeSpent?: true;
  };

  export type ProjectMaxAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    startDate?: true;
    endDate?: true;
    createdAt?: true;
    updatedAt?: true;
    createdById?: true;
    dueDate?: true;
    estimatedTime?: true;
    totalTimeSpent?: true;
  };

  export type ProjectCountAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    startDate?: true;
    endDate?: true;
    createdAt?: true;
    updatedAt?: true;
    createdById?: true;
    dueDate?: true;
    estimatedTime?: true;
    totalTimeSpent?: true;
    _all?: true;
  };

  export type ProjectAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Projects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Projects
     **/
    _count?: true | ProjectCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ProjectAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ProjectSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ProjectMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ProjectMaxAggregateInputType;
  };

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
    [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>;
  };

  export type ProjectGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[];
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum;
    having?: ProjectScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ProjectCountAggregateInputType | true;
    _avg?: ProjectAvgAggregateInputType;
    _sum?: ProjectSumAggregateInputType;
    _min?: ProjectMinAggregateInputType;
    _max?: ProjectMaxAggregateInputType;
  };

  export type ProjectGroupByOutputType = {
    id: string;
    title: string;
    description: string | null;
    startDate: Date | null;
    endDate: Date | null;
    createdAt: Date;
    updatedAt: Date;
    createdById: string;
    dueDate: Date | null;
    estimatedTime: number | null;
    totalTimeSpent: number | null;
    _count: ProjectCountAggregateOutputType | null;
    _avg: ProjectAvgAggregateOutputType | null;
    _sum: ProjectSumAggregateOutputType | null;
    _min: ProjectMinAggregateOutputType | null;
    _max: ProjectMaxAggregateOutputType | null;
  };

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ProjectGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
          : GetScalarType<T[P], ProjectGroupByOutputType[P]>;
      }
    >
  >;

  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        title?: boolean;
        description?: boolean;
        startDate?: boolean;
        endDate?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        createdById?: boolean;
        dueDate?: boolean;
        estimatedTime?: boolean;
        totalTimeSpent?: boolean;
        activities?: boolean | Project$activitiesArgs<ExtArgs>;
        attendances?: boolean | Project$attendancesArgs<ExtArgs>;
        events?: boolean | Project$eventsArgs<ExtArgs>;
        createdBy?: boolean | UserDefaultArgs<ExtArgs>;
        statuses?: boolean | Project$statusesArgs<ExtArgs>;
        tasks?: boolean | Project$tasksArgs<ExtArgs>;
        teamMembers?: boolean | Project$teamMembersArgs<ExtArgs>;
        _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['project']
    >;

  export type ProjectSelectScalar = {
    id?: boolean;
    title?: boolean;
    description?: boolean;
    startDate?: boolean;
    endDate?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    createdById?: boolean;
    dueDate?: boolean;
    estimatedTime?: boolean;
    totalTimeSpent?: boolean;
  };

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'title'
      | 'description'
      | 'startDate'
      | 'endDate'
      | 'createdAt'
      | 'updatedAt'
      | 'createdById'
      | 'dueDate'
      | 'estimatedTime'
      | 'totalTimeSpent',
      ExtArgs['result']['project']
    >;
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | Project$activitiesArgs<ExtArgs>;
    attendances?: boolean | Project$attendancesArgs<ExtArgs>;
    events?: boolean | Project$eventsArgs<ExtArgs>;
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    statuses?: boolean | Project$statusesArgs<ExtArgs>;
    tasks?: boolean | Project$tasksArgs<ExtArgs>;
    teamMembers?: boolean | Project$teamMembersArgs<ExtArgs>;
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Project';
      objects: {
        activities: Prisma.$ActivityPayload<ExtArgs>[];
        attendances: Prisma.$AttendancePayload<ExtArgs>[];
        events: Prisma.$EventPayload<ExtArgs>[];
        createdBy: Prisma.$UserPayload<ExtArgs>;
        statuses: Prisma.$ProjectStatusPayload<ExtArgs>[];
        tasks: Prisma.$TaskPayload<ExtArgs>[];
        teamMembers: Prisma.$TeamMemberPayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          title: string;
          description: string | null;
          startDate: Date | null;
          endDate: Date | null;
          createdAt: Date;
          updatedAt: Date;
          createdById: string;
          dueDate: Date | null;
          estimatedTime: number | null;
          totalTimeSpent: number | null;
        },
        ExtArgs['result']['project']
      >;
      composites: {};
    };

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> =
    $Result.GetResult<Prisma.$ProjectPayload, S>;

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ProjectFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ProjectCountAggregateInputType | true;
  };

  export interface ProjectDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project']; meta: { name: 'Project' } };
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(
      args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>
    ): Prisma__ProjectClient<
      $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProjectClient<
      $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(
      args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>
    ): Prisma__ProjectClient<
      $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProjectClient<
      $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     *
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ProjectFindManyArgs>(
      args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     *
     */
    create<T extends ProjectCreateArgs>(
      args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>
    ): Prisma__ProjectClient<
      $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ProjectCreateManyArgs>(
      args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     *
     */
    delete<T extends ProjectDeleteArgs>(
      args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>
    ): Prisma__ProjectClient<
      $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ProjectUpdateArgs>(
      args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>
    ): Prisma__ProjectClient<
      $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ProjectDeleteManyArgs>(
      args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ProjectUpdateManyArgs>(
      args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(
      args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>
    ): Prisma__ProjectClient<
      $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
     **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ProjectAggregateArgs>(
      args: Subset<T, ProjectAggregateArgs>
    ): Prisma.PrismaPromise<GetProjectAggregateType<T>>;

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Project model
     */
    readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    activities<T extends Project$activitiesArgs<ExtArgs> = {}>(
      args?: Subset<T, Project$activitiesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    attendances<T extends Project$attendancesArgs<ExtArgs> = {}>(
      args?: Subset<T, Project$attendancesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    events<T extends Project$eventsArgs<ExtArgs> = {}>(
      args?: Subset<T, Project$eventsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    statuses<T extends Project$statusesArgs<ExtArgs> = {}>(
      args?: Subset<T, Project$statusesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    tasks<T extends Project$tasksArgs<ExtArgs> = {}>(
      args?: Subset<T, Project$tasksArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    teamMembers<T extends Project$teamMembersArgs<ExtArgs> = {}>(
      args?: Subset<T, Project$teamMembersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<'Project', 'String'>;
    readonly title: FieldRef<'Project', 'String'>;
    readonly description: FieldRef<'Project', 'String'>;
    readonly startDate: FieldRef<'Project', 'DateTime'>;
    readonly endDate: FieldRef<'Project', 'DateTime'>;
    readonly createdAt: FieldRef<'Project', 'DateTime'>;
    readonly updatedAt: FieldRef<'Project', 'DateTime'>;
    readonly createdById: FieldRef<'Project', 'String'>;
    readonly dueDate: FieldRef<'Project', 'DateTime'>;
    readonly estimatedTime: FieldRef<'Project', 'Float'>;
    readonly totalTimeSpent: FieldRef<'Project', 'Float'>;
  }

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null;
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput;
  };

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null;
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput;
  };

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null;
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Projects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[];
  };

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null;
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Projects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[];
  };

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null;
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Projects.
     */
    skip?: number;
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[];
  };

  /**
   * Project create
   */
  export type ProjectCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null;
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>;
  };

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Project update
   */
  export type ProjectUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null;
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>;
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput;
  };

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>;
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput;
    /**
     * Limit how many Projects to update.
     */
    limit?: number;
  };

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null;
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput;
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>;
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>;
  };

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null;
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput;
  };

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput;
    /**
     * Limit how many Projects to delete.
     */
    limit?: number;
  };

  /**
   * Project.activities
   */
  export type Project$activitiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null;
    where?: ActivityWhereInput;
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[];
    cursor?: ActivityWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[];
  };

  /**
   * Project.attendances
   */
  export type Project$attendancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null;
    where?: AttendanceWhereInput;
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[];
    cursor?: AttendanceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[];
  };

  /**
   * Project.events
   */
  export type Project$eventsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    where?: EventWhereInput;
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[];
    cursor?: EventWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * Project.statuses
   */
  export type Project$statusesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProjectStatus
     */
    omit?: ProjectStatusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null;
    where?: ProjectStatusWhereInput;
    orderBy?: ProjectStatusOrderByWithRelationInput | ProjectStatusOrderByWithRelationInput[];
    cursor?: ProjectStatusWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProjectStatusScalarFieldEnum | ProjectStatusScalarFieldEnum[];
  };

  /**
   * Project.tasks
   */
  export type Project$tasksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    where?: TaskWhereInput;
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
    cursor?: TaskWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[];
  };

  /**
   * Project.teamMembers
   */
  export type Project$teamMembersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    where?: TeamMemberWhereInput;
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
    cursor?: TeamMemberWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
  };

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null;
  };

  /**
   * Model ProjectStatus
   */

  export type AggregateProjectStatus = {
    _count: ProjectStatusCountAggregateOutputType | null;
    _avg: ProjectStatusAvgAggregateOutputType | null;
    _sum: ProjectStatusSumAggregateOutputType | null;
    _min: ProjectStatusMinAggregateOutputType | null;
    _max: ProjectStatusMaxAggregateOutputType | null;
  };

  export type ProjectStatusAvgAggregateOutputType = {
    order: number | null;
  };

  export type ProjectStatusSumAggregateOutputType = {
    order: number | null;
  };

  export type ProjectStatusMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    color: string | null;
    description: string | null;
    isDefault: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    order: number | null;
    projectId: string | null;
    isCompletedStatus: boolean | null;
  };

  export type ProjectStatusMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    color: string | null;
    description: string | null;
    isDefault: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    order: number | null;
    projectId: string | null;
    isCompletedStatus: boolean | null;
  };

  export type ProjectStatusCountAggregateOutputType = {
    id: number;
    name: number;
    color: number;
    description: number;
    isDefault: number;
    createdAt: number;
    updatedAt: number;
    order: number;
    projectId: number;
    isCompletedStatus: number;
    _all: number;
  };

  export type ProjectStatusAvgAggregateInputType = {
    order?: true;
  };

  export type ProjectStatusSumAggregateInputType = {
    order?: true;
  };

  export type ProjectStatusMinAggregateInputType = {
    id?: true;
    name?: true;
    color?: true;
    description?: true;
    isDefault?: true;
    createdAt?: true;
    updatedAt?: true;
    order?: true;
    projectId?: true;
    isCompletedStatus?: true;
  };

  export type ProjectStatusMaxAggregateInputType = {
    id?: true;
    name?: true;
    color?: true;
    description?: true;
    isDefault?: true;
    createdAt?: true;
    updatedAt?: true;
    order?: true;
    projectId?: true;
    isCompletedStatus?: true;
  };

  export type ProjectStatusCountAggregateInputType = {
    id?: true;
    name?: true;
    color?: true;
    description?: true;
    isDefault?: true;
    createdAt?: true;
    updatedAt?: true;
    order?: true;
    projectId?: true;
    isCompletedStatus?: true;
    _all?: true;
  };

  export type ProjectStatusAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ProjectStatus to aggregate.
     */
    where?: ProjectStatusWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProjectStatuses to fetch.
     */
    orderBy?: ProjectStatusOrderByWithRelationInput | ProjectStatusOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ProjectStatusWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProjectStatuses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProjectStatuses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ProjectStatuses
     **/
    _count?: true | ProjectStatusCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ProjectStatusAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ProjectStatusSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ProjectStatusMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ProjectStatusMaxAggregateInputType;
  };

  export type GetProjectStatusAggregateType<T extends ProjectStatusAggregateArgs> = {
    [P in keyof T & keyof AggregateProjectStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectStatus[P]>
      : GetScalarType<T[P], AggregateProjectStatus[P]>;
  };

  export type ProjectStatusGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProjectStatusWhereInput;
    orderBy?: ProjectStatusOrderByWithAggregationInput | ProjectStatusOrderByWithAggregationInput[];
    by: ProjectStatusScalarFieldEnum[] | ProjectStatusScalarFieldEnum;
    having?: ProjectStatusScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ProjectStatusCountAggregateInputType | true;
    _avg?: ProjectStatusAvgAggregateInputType;
    _sum?: ProjectStatusSumAggregateInputType;
    _min?: ProjectStatusMinAggregateInputType;
    _max?: ProjectStatusMaxAggregateInputType;
  };

  export type ProjectStatusGroupByOutputType = {
    id: string;
    name: string;
    color: string | null;
    description: string | null;
    isDefault: boolean;
    createdAt: Date;
    updatedAt: Date;
    order: number;
    projectId: string;
    isCompletedStatus: boolean;
    _count: ProjectStatusCountAggregateOutputType | null;
    _avg: ProjectStatusAvgAggregateOutputType | null;
    _sum: ProjectStatusSumAggregateOutputType | null;
    _min: ProjectStatusMinAggregateOutputType | null;
    _max: ProjectStatusMaxAggregateOutputType | null;
  };

  type GetProjectStatusGroupByPayload<T extends ProjectStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectStatusGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ProjectStatusGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ProjectStatusGroupByOutputType[P]>
          : GetScalarType<T[P], ProjectStatusGroupByOutputType[P]>;
      }
    >
  >;

  export type ProjectStatusSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      color?: boolean;
      description?: boolean;
      isDefault?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      order?: boolean;
      projectId?: boolean;
      isCompletedStatus?: boolean;
      project?: boolean | ProjectDefaultArgs<ExtArgs>;
      tasks?: boolean | ProjectStatus$tasksArgs<ExtArgs>;
      _count?: boolean | ProjectStatusCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['projectStatus']
  >;

  export type ProjectStatusSelectScalar = {
    id?: boolean;
    name?: boolean;
    color?: boolean;
    description?: boolean;
    isDefault?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    order?: boolean;
    projectId?: boolean;
    isCompletedStatus?: boolean;
  };

  export type ProjectStatusOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'name'
    | 'color'
    | 'description'
    | 'isDefault'
    | 'createdAt'
    | 'updatedAt'
    | 'order'
    | 'projectId'
    | 'isCompletedStatus',
    ExtArgs['result']['projectStatus']
  >;
  export type ProjectStatusInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>;
    tasks?: boolean | ProjectStatus$tasksArgs<ExtArgs>;
    _count?: boolean | ProjectStatusCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $ProjectStatusPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ProjectStatus';
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>;
      tasks: Prisma.$TaskPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        color: string | null;
        description: string | null;
        isDefault: boolean;
        createdAt: Date;
        updatedAt: Date;
        order: number;
        projectId: string;
        isCompletedStatus: boolean;
      },
      ExtArgs['result']['projectStatus']
    >;
    composites: {};
  };

  type ProjectStatusGetPayload<S extends boolean | null | undefined | ProjectStatusDefaultArgs> =
    $Result.GetResult<Prisma.$ProjectStatusPayload, S>;

  type ProjectStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectStatusCountAggregateInputType | true;
    };

  export interface ProjectStatusDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ProjectStatus'];
      meta: { name: 'ProjectStatus' };
    };
    /**
     * Find zero or one ProjectStatus that matches the filter.
     * @param {ProjectStatusFindUniqueArgs} args - Arguments to find a ProjectStatus
     * @example
     * // Get one ProjectStatus
     * const projectStatus = await prisma.projectStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectStatusFindUniqueArgs>(
      args: SelectSubset<T, ProjectStatusFindUniqueArgs<ExtArgs>>
    ): Prisma__ProjectStatusClient<
      $Result.GetResult<
        Prisma.$ProjectStatusPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ProjectStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectStatusFindUniqueOrThrowArgs} args - Arguments to find a ProjectStatus
     * @example
     * // Get one ProjectStatus
     * const projectStatus = await prisma.projectStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectStatusFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ProjectStatusFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProjectStatusClient<
      $Result.GetResult<
        Prisma.$ProjectStatusPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ProjectStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusFindFirstArgs} args - Arguments to find a ProjectStatus
     * @example
     * // Get one ProjectStatus
     * const projectStatus = await prisma.projectStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectStatusFindFirstArgs>(
      args?: SelectSubset<T, ProjectStatusFindFirstArgs<ExtArgs>>
    ): Prisma__ProjectStatusClient<
      $Result.GetResult<
        Prisma.$ProjectStatusPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ProjectStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusFindFirstOrThrowArgs} args - Arguments to find a ProjectStatus
     * @example
     * // Get one ProjectStatus
     * const projectStatus = await prisma.projectStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectStatusFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProjectStatusFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProjectStatusClient<
      $Result.GetResult<
        Prisma.$ProjectStatusPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ProjectStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectStatuses
     * const projectStatuses = await prisma.projectStatus.findMany()
     *
     * // Get first 10 ProjectStatuses
     * const projectStatuses = await prisma.projectStatus.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const projectStatusWithIdOnly = await prisma.projectStatus.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ProjectStatusFindManyArgs>(
      args?: SelectSubset<T, ProjectStatusFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a ProjectStatus.
     * @param {ProjectStatusCreateArgs} args - Arguments to create a ProjectStatus.
     * @example
     * // Create one ProjectStatus
     * const ProjectStatus = await prisma.projectStatus.create({
     *   data: {
     *     // ... data to create a ProjectStatus
     *   }
     * })
     *
     */
    create<T extends ProjectStatusCreateArgs>(
      args: SelectSubset<T, ProjectStatusCreateArgs<ExtArgs>>
    ): Prisma__ProjectStatusClient<
      $Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ProjectStatuses.
     * @param {ProjectStatusCreateManyArgs} args - Arguments to create many ProjectStatuses.
     * @example
     * // Create many ProjectStatuses
     * const projectStatus = await prisma.projectStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ProjectStatusCreateManyArgs>(
      args?: SelectSubset<T, ProjectStatusCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ProjectStatus.
     * @param {ProjectStatusDeleteArgs} args - Arguments to delete one ProjectStatus.
     * @example
     * // Delete one ProjectStatus
     * const ProjectStatus = await prisma.projectStatus.delete({
     *   where: {
     *     // ... filter to delete one ProjectStatus
     *   }
     * })
     *
     */
    delete<T extends ProjectStatusDeleteArgs>(
      args: SelectSubset<T, ProjectStatusDeleteArgs<ExtArgs>>
    ): Prisma__ProjectStatusClient<
      $Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ProjectStatus.
     * @param {ProjectStatusUpdateArgs} args - Arguments to update one ProjectStatus.
     * @example
     * // Update one ProjectStatus
     * const projectStatus = await prisma.projectStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ProjectStatusUpdateArgs>(
      args: SelectSubset<T, ProjectStatusUpdateArgs<ExtArgs>>
    ): Prisma__ProjectStatusClient<
      $Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ProjectStatuses.
     * @param {ProjectStatusDeleteManyArgs} args - Arguments to filter ProjectStatuses to delete.
     * @example
     * // Delete a few ProjectStatuses
     * const { count } = await prisma.projectStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ProjectStatusDeleteManyArgs>(
      args?: SelectSubset<T, ProjectStatusDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ProjectStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectStatuses
     * const projectStatus = await prisma.projectStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ProjectStatusUpdateManyArgs>(
      args: SelectSubset<T, ProjectStatusUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ProjectStatus.
     * @param {ProjectStatusUpsertArgs} args - Arguments to update or create a ProjectStatus.
     * @example
     * // Update or create a ProjectStatus
     * const projectStatus = await prisma.projectStatus.upsert({
     *   create: {
     *     // ... data to create a ProjectStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectStatus we want to update
     *   }
     * })
     */
    upsert<T extends ProjectStatusUpsertArgs>(
      args: SelectSubset<T, ProjectStatusUpsertArgs<ExtArgs>>
    ): Prisma__ProjectStatusClient<
      $Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ProjectStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusCountArgs} args - Arguments to filter ProjectStatuses to count.
     * @example
     * // Count the number of ProjectStatuses
     * const count = await prisma.projectStatus.count({
     *   where: {
     *     // ... the filter for the ProjectStatuses we want to count
     *   }
     * })
     **/
    count<T extends ProjectStatusCountArgs>(
      args?: Subset<T, ProjectStatusCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectStatusCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ProjectStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ProjectStatusAggregateArgs>(
      args: Subset<T, ProjectStatusAggregateArgs>
    ): Prisma.PrismaPromise<GetProjectStatusAggregateType<T>>;

    /**
     * Group by ProjectStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ProjectStatusGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectStatusGroupByArgs['orderBy'] }
        : { orderBy?: ProjectStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ProjectStatusGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetProjectStatusGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ProjectStatus model
     */
    readonly fields: ProjectStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectStatusClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ProjectDefaultArgs<ExtArgs>>
    ): Prisma__ProjectClient<
      | $Result.GetResult<
          Prisma.$ProjectPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    tasks<T extends ProjectStatus$tasksArgs<ExtArgs> = {}>(
      args?: Subset<T, ProjectStatus$tasksArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ProjectStatus model
   */
  interface ProjectStatusFieldRefs {
    readonly id: FieldRef<'ProjectStatus', 'String'>;
    readonly name: FieldRef<'ProjectStatus', 'String'>;
    readonly color: FieldRef<'ProjectStatus', 'String'>;
    readonly description: FieldRef<'ProjectStatus', 'String'>;
    readonly isDefault: FieldRef<'ProjectStatus', 'Boolean'>;
    readonly createdAt: FieldRef<'ProjectStatus', 'DateTime'>;
    readonly updatedAt: FieldRef<'ProjectStatus', 'DateTime'>;
    readonly order: FieldRef<'ProjectStatus', 'Int'>;
    readonly projectId: FieldRef<'ProjectStatus', 'String'>;
    readonly isCompletedStatus: FieldRef<'ProjectStatus', 'Boolean'>;
  }

  // Custom InputTypes
  /**
   * ProjectStatus findUnique
   */
  export type ProjectStatusFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProjectStatus
     */
    omit?: ProjectStatusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null;
    /**
     * Filter, which ProjectStatus to fetch.
     */
    where: ProjectStatusWhereUniqueInput;
  };

  /**
   * ProjectStatus findUniqueOrThrow
   */
  export type ProjectStatusFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProjectStatus
     */
    omit?: ProjectStatusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null;
    /**
     * Filter, which ProjectStatus to fetch.
     */
    where: ProjectStatusWhereUniqueInput;
  };

  /**
   * ProjectStatus findFirst
   */
  export type ProjectStatusFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProjectStatus
     */
    omit?: ProjectStatusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null;
    /**
     * Filter, which ProjectStatus to fetch.
     */
    where?: ProjectStatusWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProjectStatuses to fetch.
     */
    orderBy?: ProjectStatusOrderByWithRelationInput | ProjectStatusOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProjectStatuses.
     */
    cursor?: ProjectStatusWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProjectStatuses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProjectStatuses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProjectStatuses.
     */
    distinct?: ProjectStatusScalarFieldEnum | ProjectStatusScalarFieldEnum[];
  };

  /**
   * ProjectStatus findFirstOrThrow
   */
  export type ProjectStatusFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProjectStatus
     */
    omit?: ProjectStatusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null;
    /**
     * Filter, which ProjectStatus to fetch.
     */
    where?: ProjectStatusWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProjectStatuses to fetch.
     */
    orderBy?: ProjectStatusOrderByWithRelationInput | ProjectStatusOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProjectStatuses.
     */
    cursor?: ProjectStatusWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProjectStatuses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProjectStatuses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProjectStatuses.
     */
    distinct?: ProjectStatusScalarFieldEnum | ProjectStatusScalarFieldEnum[];
  };

  /**
   * ProjectStatus findMany
   */
  export type ProjectStatusFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProjectStatus
     */
    omit?: ProjectStatusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null;
    /**
     * Filter, which ProjectStatuses to fetch.
     */
    where?: ProjectStatusWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProjectStatuses to fetch.
     */
    orderBy?: ProjectStatusOrderByWithRelationInput | ProjectStatusOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ProjectStatuses.
     */
    cursor?: ProjectStatusWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProjectStatuses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProjectStatuses.
     */
    skip?: number;
    distinct?: ProjectStatusScalarFieldEnum | ProjectStatusScalarFieldEnum[];
  };

  /**
   * ProjectStatus create
   */
  export type ProjectStatusCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProjectStatus
     */
    omit?: ProjectStatusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null;
    /**
     * The data needed to create a ProjectStatus.
     */
    data: XOR<ProjectStatusCreateInput, ProjectStatusUncheckedCreateInput>;
  };

  /**
   * ProjectStatus createMany
   */
  export type ProjectStatusCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ProjectStatuses.
     */
    data: ProjectStatusCreateManyInput | ProjectStatusCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ProjectStatus update
   */
  export type ProjectStatusUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProjectStatus
     */
    omit?: ProjectStatusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null;
    /**
     * The data needed to update a ProjectStatus.
     */
    data: XOR<ProjectStatusUpdateInput, ProjectStatusUncheckedUpdateInput>;
    /**
     * Choose, which ProjectStatus to update.
     */
    where: ProjectStatusWhereUniqueInput;
  };

  /**
   * ProjectStatus updateMany
   */
  export type ProjectStatusUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ProjectStatuses.
     */
    data: XOR<ProjectStatusUpdateManyMutationInput, ProjectStatusUncheckedUpdateManyInput>;
    /**
     * Filter which ProjectStatuses to update
     */
    where?: ProjectStatusWhereInput;
    /**
     * Limit how many ProjectStatuses to update.
     */
    limit?: number;
  };

  /**
   * ProjectStatus upsert
   */
  export type ProjectStatusUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProjectStatus
     */
    omit?: ProjectStatusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null;
    /**
     * The filter to search for the ProjectStatus to update in case it exists.
     */
    where: ProjectStatusWhereUniqueInput;
    /**
     * In case the ProjectStatus found by the `where` argument doesn't exist, create a new ProjectStatus with this data.
     */
    create: XOR<ProjectStatusCreateInput, ProjectStatusUncheckedCreateInput>;
    /**
     * In case the ProjectStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectStatusUpdateInput, ProjectStatusUncheckedUpdateInput>;
  };

  /**
   * ProjectStatus delete
   */
  export type ProjectStatusDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProjectStatus
     */
    omit?: ProjectStatusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null;
    /**
     * Filter which ProjectStatus to delete.
     */
    where: ProjectStatusWhereUniqueInput;
  };

  /**
   * ProjectStatus deleteMany
   */
  export type ProjectStatusDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ProjectStatuses to delete
     */
    where?: ProjectStatusWhereInput;
    /**
     * Limit how many ProjectStatuses to delete.
     */
    limit?: number;
  };

  /**
   * ProjectStatus.tasks
   */
  export type ProjectStatus$tasksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    where?: TaskWhereInput;
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
    cursor?: TaskWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[];
  };

  /**
   * ProjectStatus without action
   */
  export type ProjectStatusDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProjectStatus
     */
    omit?: ProjectStatusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null;
  };

  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null;
    _avg: TaskAvgAggregateOutputType | null;
    _sum: TaskSumAggregateOutputType | null;
    _min: TaskMinAggregateOutputType | null;
    _max: TaskMaxAggregateOutputType | null;
  };

  export type TaskAvgAggregateOutputType = {
    order: number | null;
    estimatedTime: number | null;
    timeSpent: number | null;
  };

  export type TaskSumAggregateOutputType = {
    order: number | null;
    estimatedTime: number | null;
    timeSpent: number | null;
  };

  export type TaskMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    priority: string | null;
    dueDate: Date | null;
    projectId: string | null;
    parentId: string | null;
    order: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    endDate: Date | null;
    estimatedTime: number | null;
    startDate: Date | null;
    statusId: string | null;
    timeSpent: number | null;
    completed: boolean | null;
  };

  export type TaskMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    priority: string | null;
    dueDate: Date | null;
    projectId: string | null;
    parentId: string | null;
    order: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    endDate: Date | null;
    estimatedTime: number | null;
    startDate: Date | null;
    statusId: string | null;
    timeSpent: number | null;
    completed: boolean | null;
  };

  export type TaskCountAggregateOutputType = {
    id: number;
    title: number;
    description: number;
    priority: number;
    dueDate: number;
    projectId: number;
    parentId: number;
    order: number;
    createdAt: number;
    updatedAt: number;
    endDate: number;
    estimatedTime: number;
    startDate: number;
    statusId: number;
    timeSpent: number;
    completed: number;
    _all: number;
  };

  export type TaskAvgAggregateInputType = {
    order?: true;
    estimatedTime?: true;
    timeSpent?: true;
  };

  export type TaskSumAggregateInputType = {
    order?: true;
    estimatedTime?: true;
    timeSpent?: true;
  };

  export type TaskMinAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    priority?: true;
    dueDate?: true;
    projectId?: true;
    parentId?: true;
    order?: true;
    createdAt?: true;
    updatedAt?: true;
    endDate?: true;
    estimatedTime?: true;
    startDate?: true;
    statusId?: true;
    timeSpent?: true;
    completed?: true;
  };

  export type TaskMaxAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    priority?: true;
    dueDate?: true;
    projectId?: true;
    parentId?: true;
    order?: true;
    createdAt?: true;
    updatedAt?: true;
    endDate?: true;
    estimatedTime?: true;
    startDate?: true;
    statusId?: true;
    timeSpent?: true;
    completed?: true;
  };

  export type TaskCountAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    priority?: true;
    dueDate?: true;
    projectId?: true;
    parentId?: true;
    order?: true;
    createdAt?: true;
    updatedAt?: true;
    endDate?: true;
    estimatedTime?: true;
    startDate?: true;
    statusId?: true;
    timeSpent?: true;
    completed?: true;
    _all?: true;
  };

  export type TaskAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tasks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Tasks
     **/
    _count?: true | TaskCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: TaskAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: TaskSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TaskMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TaskMaxAggregateInputType;
  };

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
    [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>;
  };

  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: TaskWhereInput;
      orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[];
      by: TaskScalarFieldEnum[] | TaskScalarFieldEnum;
      having?: TaskScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: TaskCountAggregateInputType | true;
      _avg?: TaskAvgAggregateInputType;
      _sum?: TaskSumAggregateInputType;
      _min?: TaskMinAggregateInputType;
      _max?: TaskMaxAggregateInputType;
    };

  export type TaskGroupByOutputType = {
    id: string;
    title: string;
    description: string | null;
    priority: string;
    dueDate: Date | null;
    projectId: string;
    parentId: string | null;
    order: number;
    createdAt: Date;
    updatedAt: Date;
    endDate: Date | null;
    estimatedTime: number | null;
    startDate: Date | null;
    statusId: string | null;
    timeSpent: number | null;
    completed: boolean;
    _count: TaskCountAggregateOutputType | null;
    _avg: TaskAvgAggregateOutputType | null;
    _sum: TaskSumAggregateOutputType | null;
    _min: TaskMinAggregateOutputType | null;
    _max: TaskMaxAggregateOutputType | null;
  };

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> & {
        [P in keyof T & keyof TaskGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
          : GetScalarType<T[P], TaskGroupByOutputType[P]>;
      }
    >
  >;

  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        title?: boolean;
        description?: boolean;
        priority?: boolean;
        dueDate?: boolean;
        projectId?: boolean;
        parentId?: boolean;
        order?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        endDate?: boolean;
        estimatedTime?: boolean;
        startDate?: boolean;
        statusId?: boolean;
        timeSpent?: boolean;
        completed?: boolean;
        activities?: boolean | Task$activitiesArgs<ExtArgs>;
        attendances?: boolean | Task$attendancesArgs<ExtArgs>;
        comments?: boolean | Task$commentsArgs<ExtArgs>;
        parent?: boolean | Task$parentArgs<ExtArgs>;
        subtasks?: boolean | Task$subtasksArgs<ExtArgs>;
        project?: boolean | ProjectDefaultArgs<ExtArgs>;
        status?: boolean | Task$statusArgs<ExtArgs>;
        assignees?: boolean | Task$assigneesArgs<ExtArgs>;
        attachments?: boolean | Task$attachmentsArgs<ExtArgs>;
        _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['task']
    >;

  export type TaskSelectScalar = {
    id?: boolean;
    title?: boolean;
    description?: boolean;
    priority?: boolean;
    dueDate?: boolean;
    projectId?: boolean;
    parentId?: boolean;
    order?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    endDate?: boolean;
    estimatedTime?: boolean;
    startDate?: boolean;
    statusId?: boolean;
    timeSpent?: boolean;
    completed?: boolean;
  };

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'title'
      | 'description'
      | 'priority'
      | 'dueDate'
      | 'projectId'
      | 'parentId'
      | 'order'
      | 'createdAt'
      | 'updatedAt'
      | 'endDate'
      | 'estimatedTime'
      | 'startDate'
      | 'statusId'
      | 'timeSpent'
      | 'completed',
      ExtArgs['result']['task']
    >;
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | Task$activitiesArgs<ExtArgs>;
    attendances?: boolean | Task$attendancesArgs<ExtArgs>;
    comments?: boolean | Task$commentsArgs<ExtArgs>;
    parent?: boolean | Task$parentArgs<ExtArgs>;
    subtasks?: boolean | Task$subtasksArgs<ExtArgs>;
    project?: boolean | ProjectDefaultArgs<ExtArgs>;
    status?: boolean | Task$statusArgs<ExtArgs>;
    assignees?: boolean | Task$assigneesArgs<ExtArgs>;
    attachments?: boolean | Task$attachmentsArgs<ExtArgs>;
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Task';
    objects: {
      activities: Prisma.$ActivityPayload<ExtArgs>[];
      attendances: Prisma.$AttendancePayload<ExtArgs>[];
      comments: Prisma.$CommentPayload<ExtArgs>[];
      parent: Prisma.$TaskPayload<ExtArgs> | null;
      subtasks: Prisma.$TaskPayload<ExtArgs>[];
      project: Prisma.$ProjectPayload<ExtArgs>;
      status: Prisma.$ProjectStatusPayload<ExtArgs> | null;
      assignees: Prisma.$TaskAssigneePayload<ExtArgs>[];
      attachments: Prisma.$TaskAttachmentPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        description: string | null;
        priority: string;
        dueDate: Date | null;
        projectId: string;
        parentId: string | null;
        order: number;
        createdAt: Date;
        updatedAt: Date;
        endDate: Date | null;
        estimatedTime: number | null;
        startDate: Date | null;
        statusId: string | null;
        timeSpent: number | null;
        completed: boolean;
      },
      ExtArgs['result']['task']
    >;
    composites: {};
  };

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<
    Prisma.$TaskPayload,
    S
  >;

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    TaskFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: TaskCountAggregateInputType | true;
  };

  export interface TaskDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task']; meta: { name: 'Task' } };
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(
      args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(
      args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     *
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TaskFindManyArgs>(
      args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     *
     */
    create<T extends TaskCreateArgs>(
      args: SelectSubset<T, TaskCreateArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TaskCreateManyArgs>(
      args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     *
     */
    delete<T extends TaskDeleteArgs>(
      args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TaskUpdateArgs>(
      args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TaskDeleteManyArgs>(
      args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TaskUpdateManyArgs>(
      args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(
      args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
     **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TaskAggregateArgs>(
      args: Subset<T, TaskAggregateArgs>
    ): Prisma.PrismaPromise<GetTaskAggregateType<T>>;

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Task model
     */
    readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    activities<T extends Task$activitiesArgs<ExtArgs> = {}>(
      args?: Subset<T, Task$activitiesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    attendances<T extends Task$attendancesArgs<ExtArgs> = {}>(
      args?: Subset<T, Task$attendancesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    comments<T extends Task$commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Task$commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    parent<T extends Task$parentArgs<ExtArgs> = {}>(
      args?: Subset<T, Task$parentArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<
        Prisma.$TaskPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    subtasks<T extends Task$subtasksArgs<ExtArgs> = {}>(
      args?: Subset<T, Task$subtasksArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ProjectDefaultArgs<ExtArgs>>
    ): Prisma__ProjectClient<
      | $Result.GetResult<
          Prisma.$ProjectPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    status<T extends Task$statusArgs<ExtArgs> = {}>(
      args?: Subset<T, Task$statusArgs<ExtArgs>>
    ): Prisma__ProjectStatusClient<
      $Result.GetResult<
        Prisma.$ProjectStatusPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    assignees<T extends Task$assigneesArgs<ExtArgs> = {}>(
      args?: Subset<T, Task$assigneesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    attachments<T extends Task$attachmentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Task$attachmentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<'Task', 'String'>;
    readonly title: FieldRef<'Task', 'String'>;
    readonly description: FieldRef<'Task', 'String'>;
    readonly priority: FieldRef<'Task', 'String'>;
    readonly dueDate: FieldRef<'Task', 'DateTime'>;
    readonly projectId: FieldRef<'Task', 'String'>;
    readonly parentId: FieldRef<'Task', 'String'>;
    readonly order: FieldRef<'Task', 'Int'>;
    readonly createdAt: FieldRef<'Task', 'DateTime'>;
    readonly updatedAt: FieldRef<'Task', 'DateTime'>;
    readonly endDate: FieldRef<'Task', 'DateTime'>;
    readonly estimatedTime: FieldRef<'Task', 'Float'>;
    readonly startDate: FieldRef<'Task', 'DateTime'>;
    readonly statusId: FieldRef<'Task', 'String'>;
    readonly timeSpent: FieldRef<'Task', 'Float'>;
    readonly completed: FieldRef<'Task', 'Boolean'>;
  }

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput;
  };

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput;
  };

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tasks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[];
  };

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tasks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[];
  };

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Task
       */
      select?: TaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Task
       */
      omit?: TaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskInclude<ExtArgs> | null;
      /**
       * Filter, which Tasks to fetch.
       */
      where?: TaskWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Tasks to fetch.
       */
      orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Tasks.
       */
      cursor?: TaskWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Tasks from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Tasks.
       */
      skip?: number;
      distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[];
    };

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>;
  };

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>;
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput;
  };

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>;
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput;
    /**
     * Limit how many Tasks to update.
     */
    limit?: number;
  };

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput;
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>;
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>;
  };

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput;
  };

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput;
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number;
  };

  /**
   * Task.activities
   */
  export type Task$activitiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null;
    where?: ActivityWhereInput;
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[];
    cursor?: ActivityWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[];
  };

  /**
   * Task.attendances
   */
  export type Task$attendancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null;
    where?: AttendanceWhereInput;
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[];
    cursor?: AttendanceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[];
  };

  /**
   * Task.comments
   */
  export type Task$commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    where?: CommentWhereInput;
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[];
    cursor?: CommentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * Task.parent
   */
  export type Task$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Task
       */
      select?: TaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Task
       */
      omit?: TaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskInclude<ExtArgs> | null;
      where?: TaskWhereInput;
    };

  /**
   * Task.subtasks
   */
  export type Task$subtasksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    where?: TaskWhereInput;
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
    cursor?: TaskWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[];
  };

  /**
   * Task.status
   */
  export type Task$statusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the ProjectStatus
       */
      select?: ProjectStatusSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the ProjectStatus
       */
      omit?: ProjectStatusOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProjectStatusInclude<ExtArgs> | null;
      where?: ProjectStatusWhereInput;
    };

  /**
   * Task.assignees
   */
  export type Task$assigneesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null;
    where?: TaskAssigneeWhereInput;
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[];
    cursor?: TaskAssigneeWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[];
  };

  /**
   * Task.attachments
   */
  export type Task$attachmentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null;
    where?: TaskAttachmentWhereInput;
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[];
    cursor?: TaskAttachmentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[];
  };

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Task
       */
      select?: TaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Task
       */
      omit?: TaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskInclude<ExtArgs> | null;
    };

  /**
   * Model TaskAssignee
   */

  export type AggregateTaskAssignee = {
    _count: TaskAssigneeCountAggregateOutputType | null;
    _min: TaskAssigneeMinAggregateOutputType | null;
    _max: TaskAssigneeMaxAggregateOutputType | null;
  };

  export type TaskAssigneeMinAggregateOutputType = {
    id: string | null;
    taskId: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TaskAssigneeMaxAggregateOutputType = {
    id: string | null;
    taskId: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TaskAssigneeCountAggregateOutputType = {
    id: number;
    taskId: number;
    userId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type TaskAssigneeMinAggregateInputType = {
    id?: true;
    taskId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TaskAssigneeMaxAggregateInputType = {
    id?: true;
    taskId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TaskAssigneeCountAggregateInputType = {
    id?: true;
    taskId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type TaskAssigneeAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TaskAssignee to aggregate.
     */
    where?: TaskAssigneeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TaskAssigneeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TaskAssignees.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TaskAssignees
     **/
    _count?: true | TaskAssigneeCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TaskAssigneeMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TaskAssigneeMaxAggregateInputType;
  };

  export type GetTaskAssigneeAggregateType<T extends TaskAssigneeAggregateArgs> = {
    [P in keyof T & keyof AggregateTaskAssignee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAssignee[P]>
      : GetScalarType<T[P], AggregateTaskAssignee[P]>;
  };

  export type TaskAssigneeGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TaskAssigneeWhereInput;
    orderBy?: TaskAssigneeOrderByWithAggregationInput | TaskAssigneeOrderByWithAggregationInput[];
    by: TaskAssigneeScalarFieldEnum[] | TaskAssigneeScalarFieldEnum;
    having?: TaskAssigneeScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TaskAssigneeCountAggregateInputType | true;
    _min?: TaskAssigneeMinAggregateInputType;
    _max?: TaskAssigneeMaxAggregateInputType;
  };

  export type TaskAssigneeGroupByOutputType = {
    id: string;
    taskId: string;
    userId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: TaskAssigneeCountAggregateOutputType | null;
    _min: TaskAssigneeMinAggregateOutputType | null;
    _max: TaskAssigneeMaxAggregateOutputType | null;
  };

  type GetTaskAssigneeGroupByPayload<T extends TaskAssigneeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAssigneeGroupByOutputType, T['by']> & {
        [P in keyof T & keyof TaskAssigneeGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TaskAssigneeGroupByOutputType[P]>
          : GetScalarType<T[P], TaskAssigneeGroupByOutputType[P]>;
      }
    >
  >;

  export type TaskAssigneeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      taskId?: boolean;
      userId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      task?: boolean | TaskDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['taskAssignee']
  >;

  export type TaskAssigneeSelectScalar = {
    id?: boolean;
    taskId?: boolean;
    userId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type TaskAssigneeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'id' | 'taskId' | 'userId' | 'createdAt' | 'updatedAt',
      ExtArgs['result']['taskAssignee']
    >;
  export type TaskAssigneeInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    task?: boolean | TaskDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $TaskAssigneePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'TaskAssignee';
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        taskId: string;
        userId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['taskAssignee']
    >;
    composites: {};
  };

  type TaskAssigneeGetPayload<S extends boolean | null | undefined | TaskAssigneeDefaultArgs> =
    $Result.GetResult<Prisma.$TaskAssigneePayload, S>;

  type TaskAssigneeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskAssigneeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskAssigneeCountAggregateInputType | true;
    };

  export interface TaskAssigneeDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['TaskAssignee'];
      meta: { name: 'TaskAssignee' };
    };
    /**
     * Find zero or one TaskAssignee that matches the filter.
     * @param {TaskAssigneeFindUniqueArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAssigneeFindUniqueArgs>(
      args: SelectSubset<T, TaskAssigneeFindUniqueArgs<ExtArgs>>
    ): Prisma__TaskAssigneeClient<
      $Result.GetResult<
        Prisma.$TaskAssigneePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one TaskAssignee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskAssigneeFindUniqueOrThrowArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAssigneeFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TaskAssigneeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TaskAssigneeClient<
      $Result.GetResult<
        Prisma.$TaskAssigneePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TaskAssignee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeFindFirstArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAssigneeFindFirstArgs>(
      args?: SelectSubset<T, TaskAssigneeFindFirstArgs<ExtArgs>>
    ): Prisma__TaskAssigneeClient<
      $Result.GetResult<
        Prisma.$TaskAssigneePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TaskAssignee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeFindFirstOrThrowArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAssigneeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TaskAssigneeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TaskAssigneeClient<
      $Result.GetResult<
        Prisma.$TaskAssigneePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more TaskAssignees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAssignees
     * const taskAssignees = await prisma.taskAssignee.findMany()
     *
     * // Get first 10 TaskAssignees
     * const taskAssignees = await prisma.taskAssignee.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const taskAssigneeWithIdOnly = await prisma.taskAssignee.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TaskAssigneeFindManyArgs>(
      args?: SelectSubset<T, TaskAssigneeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a TaskAssignee.
     * @param {TaskAssigneeCreateArgs} args - Arguments to create a TaskAssignee.
     * @example
     * // Create one TaskAssignee
     * const TaskAssignee = await prisma.taskAssignee.create({
     *   data: {
     *     // ... data to create a TaskAssignee
     *   }
     * })
     *
     */
    create<T extends TaskAssigneeCreateArgs>(
      args: SelectSubset<T, TaskAssigneeCreateArgs<ExtArgs>>
    ): Prisma__TaskAssigneeClient<
      $Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many TaskAssignees.
     * @param {TaskAssigneeCreateManyArgs} args - Arguments to create many TaskAssignees.
     * @example
     * // Create many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TaskAssigneeCreateManyArgs>(
      args?: SelectSubset<T, TaskAssigneeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a TaskAssignee.
     * @param {TaskAssigneeDeleteArgs} args - Arguments to delete one TaskAssignee.
     * @example
     * // Delete one TaskAssignee
     * const TaskAssignee = await prisma.taskAssignee.delete({
     *   where: {
     *     // ... filter to delete one TaskAssignee
     *   }
     * })
     *
     */
    delete<T extends TaskAssigneeDeleteArgs>(
      args: SelectSubset<T, TaskAssigneeDeleteArgs<ExtArgs>>
    ): Prisma__TaskAssigneeClient<
      $Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one TaskAssignee.
     * @param {TaskAssigneeUpdateArgs} args - Arguments to update one TaskAssignee.
     * @example
     * // Update one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TaskAssigneeUpdateArgs>(
      args: SelectSubset<T, TaskAssigneeUpdateArgs<ExtArgs>>
    ): Prisma__TaskAssigneeClient<
      $Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more TaskAssignees.
     * @param {TaskAssigneeDeleteManyArgs} args - Arguments to filter TaskAssignees to delete.
     * @example
     * // Delete a few TaskAssignees
     * const { count } = await prisma.taskAssignee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TaskAssigneeDeleteManyArgs>(
      args?: SelectSubset<T, TaskAssigneeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TaskAssignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TaskAssigneeUpdateManyArgs>(
      args: SelectSubset<T, TaskAssigneeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one TaskAssignee.
     * @param {TaskAssigneeUpsertArgs} args - Arguments to update or create a TaskAssignee.
     * @example
     * // Update or create a TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.upsert({
     *   create: {
     *     // ... data to create a TaskAssignee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAssignee we want to update
     *   }
     * })
     */
    upsert<T extends TaskAssigneeUpsertArgs>(
      args: SelectSubset<T, TaskAssigneeUpsertArgs<ExtArgs>>
    ): Prisma__TaskAssigneeClient<
      $Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of TaskAssignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeCountArgs} args - Arguments to filter TaskAssignees to count.
     * @example
     * // Count the number of TaskAssignees
     * const count = await prisma.taskAssignee.count({
     *   where: {
     *     // ... the filter for the TaskAssignees we want to count
     *   }
     * })
     **/
    count<T extends TaskAssigneeCountArgs>(
      args?: Subset<T, TaskAssigneeCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAssigneeCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a TaskAssignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TaskAssigneeAggregateArgs>(
      args: Subset<T, TaskAssigneeAggregateArgs>
    ): Prisma.PrismaPromise<GetTaskAssigneeAggregateType<T>>;

    /**
     * Group by TaskAssignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TaskAssigneeGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAssigneeGroupByArgs['orderBy'] }
        : { orderBy?: TaskAssigneeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TaskAssigneeGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetTaskAssigneeGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the TaskAssignee model
     */
    readonly fields: TaskAssigneeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAssignee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAssigneeClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TaskDefaultArgs<ExtArgs>>
    ): Prisma__TaskClient<
      | $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the TaskAssignee model
   */
  interface TaskAssigneeFieldRefs {
    readonly id: FieldRef<'TaskAssignee', 'String'>;
    readonly taskId: FieldRef<'TaskAssignee', 'String'>;
    readonly userId: FieldRef<'TaskAssignee', 'String'>;
    readonly createdAt: FieldRef<'TaskAssignee', 'DateTime'>;
    readonly updatedAt: FieldRef<'TaskAssignee', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * TaskAssignee findUnique
   */
  export type TaskAssigneeFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null;
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where: TaskAssigneeWhereUniqueInput;
  };

  /**
   * TaskAssignee findUniqueOrThrow
   */
  export type TaskAssigneeFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null;
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where: TaskAssigneeWhereUniqueInput;
  };

  /**
   * TaskAssignee findFirst
   */
  export type TaskAssigneeFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null;
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where?: TaskAssigneeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TaskAssignees.
     */
    cursor?: TaskAssigneeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TaskAssignees.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TaskAssignees.
     */
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[];
  };

  /**
   * TaskAssignee findFirstOrThrow
   */
  export type TaskAssigneeFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null;
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where?: TaskAssigneeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TaskAssignees.
     */
    cursor?: TaskAssigneeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TaskAssignees.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TaskAssignees.
     */
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[];
  };

  /**
   * TaskAssignee findMany
   */
  export type TaskAssigneeFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null;
    /**
     * Filter, which TaskAssignees to fetch.
     */
    where?: TaskAssigneeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TaskAssignees.
     */
    cursor?: TaskAssigneeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TaskAssignees.
     */
    skip?: number;
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[];
  };

  /**
   * TaskAssignee create
   */
  export type TaskAssigneeCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null;
    /**
     * The data needed to create a TaskAssignee.
     */
    data: XOR<TaskAssigneeCreateInput, TaskAssigneeUncheckedCreateInput>;
  };

  /**
   * TaskAssignee createMany
   */
  export type TaskAssigneeCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many TaskAssignees.
     */
    data: TaskAssigneeCreateManyInput | TaskAssigneeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * TaskAssignee update
   */
  export type TaskAssigneeUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null;
    /**
     * The data needed to update a TaskAssignee.
     */
    data: XOR<TaskAssigneeUpdateInput, TaskAssigneeUncheckedUpdateInput>;
    /**
     * Choose, which TaskAssignee to update.
     */
    where: TaskAssigneeWhereUniqueInput;
  };

  /**
   * TaskAssignee updateMany
   */
  export type TaskAssigneeUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update TaskAssignees.
     */
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyInput>;
    /**
     * Filter which TaskAssignees to update
     */
    where?: TaskAssigneeWhereInput;
    /**
     * Limit how many TaskAssignees to update.
     */
    limit?: number;
  };

  /**
   * TaskAssignee upsert
   */
  export type TaskAssigneeUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null;
    /**
     * The filter to search for the TaskAssignee to update in case it exists.
     */
    where: TaskAssigneeWhereUniqueInput;
    /**
     * In case the TaskAssignee found by the `where` argument doesn't exist, create a new TaskAssignee with this data.
     */
    create: XOR<TaskAssigneeCreateInput, TaskAssigneeUncheckedCreateInput>;
    /**
     * In case the TaskAssignee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAssigneeUpdateInput, TaskAssigneeUncheckedUpdateInput>;
  };

  /**
   * TaskAssignee delete
   */
  export type TaskAssigneeDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null;
    /**
     * Filter which TaskAssignee to delete.
     */
    where: TaskAssigneeWhereUniqueInput;
  };

  /**
   * TaskAssignee deleteMany
   */
  export type TaskAssigneeDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TaskAssignees to delete
     */
    where?: TaskAssigneeWhereInput;
    /**
     * Limit how many TaskAssignees to delete.
     */
    limit?: number;
  };

  /**
   * TaskAssignee without action
   */
  export type TaskAssigneeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null;
  };

  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null;
    _min: TeamMemberMinAggregateOutputType | null;
    _max: TeamMemberMaxAggregateOutputType | null;
  };

  export type TeamMemberMinAggregateOutputType = {
    id: string | null;
    projectId: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null;
    projectId: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TeamMemberCountAggregateOutputType = {
    id: number;
    projectId: number;
    userId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type TeamMemberMinAggregateInputType = {
    id?: true;
    projectId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TeamMemberMaxAggregateInputType = {
    id?: true;
    projectId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TeamMemberCountAggregateInputType = {
    id?: true;
    projectId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type TeamMemberAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TeamMembers
     **/
    _count?: true | TeamMemberCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TeamMemberMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TeamMemberMaxAggregateInputType;
  };

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
    [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>;
  };

  export type TeamMemberGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamMemberWhereInput;
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[];
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum;
    having?: TeamMemberScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TeamMemberCountAggregateInputType | true;
    _min?: TeamMemberMinAggregateInputType;
    _max?: TeamMemberMaxAggregateInputType;
  };

  export type TeamMemberGroupByOutputType = {
    id: string;
    projectId: string;
    userId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: TeamMemberCountAggregateOutputType | null;
    _min: TeamMemberMinAggregateOutputType | null;
    _max: TeamMemberMaxAggregateOutputType | null;
  };

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> & {
        [P in keyof T & keyof TeamMemberGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
          : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>;
      }
    >
  >;

  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        projectId?: boolean;
        userId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        project?: boolean | ProjectDefaultArgs<ExtArgs>;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['teamMember']
    >;

  export type TeamMemberSelectScalar = {
    id?: boolean;
    projectId?: boolean;
    userId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type TeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'id' | 'projectId' | 'userId' | 'createdAt' | 'updatedAt',
      ExtArgs['result']['teamMember']
    >;
  export type TeamMemberInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $TeamMemberPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'TeamMember';
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        projectId: string;
        userId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['teamMember']
    >;
    composites: {};
  };

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> =
    $Result.GetResult<Prisma.$TeamMemberPayload, S>;

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMemberCountAggregateInputType | true;
    };

  export interface TeamMemberDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'];
      meta: { name: 'TeamMember' };
    };
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(
      args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<
        Prisma.$TeamMemberPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<
        Prisma.$TeamMemberPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(
      args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<
        Prisma.$TeamMemberPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<
        Prisma.$TeamMemberPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     *
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TeamMemberFindManyArgs>(
      args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     *
     */
    create<T extends TeamMemberCreateArgs>(
      args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TeamMemberCreateManyArgs>(
      args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     *
     */
    delete<T extends TeamMemberDeleteArgs>(
      args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TeamMemberUpdateArgs>(
      args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(
      args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(
      args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(
      args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
     **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TeamMemberAggregateArgs>(
      args: Subset<T, TeamMemberAggregateArgs>
    ): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>;

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the TeamMember model
     */
    readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ProjectDefaultArgs<ExtArgs>>
    ): Prisma__ProjectClient<
      | $Result.GetResult<
          Prisma.$ProjectPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the TeamMember model
   */
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<'TeamMember', 'String'>;
    readonly projectId: FieldRef<'TeamMember', 'String'>;
    readonly userId: FieldRef<'TeamMember', 'String'>;
    readonly createdAt: FieldRef<'TeamMember', 'DateTime'>;
    readonly updatedAt: FieldRef<'TeamMember', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput;
  };

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput;
  };

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
  };

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
  };

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number;
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
  };

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>;
  };

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>;
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput;
  };

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>;
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput;
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number;
  };

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput;
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>;
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>;
  };

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput;
  };

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput;
    /**
     * Limit how many TeamMembers to delete.
     */
    limit?: number;
  };

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
  };

  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null;
    _min: EventMinAggregateOutputType | null;
    _max: EventMaxAggregateOutputType | null;
  };

  export type EventMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    date: Date | null;
    projectId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type EventMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    date: Date | null;
    projectId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type EventCountAggregateOutputType = {
    id: number;
    title: number;
    description: number;
    date: number;
    projectId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type EventMinAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    date?: true;
    projectId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type EventMaxAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    date?: true;
    projectId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type EventCountAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    date?: true;
    projectId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type EventAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Events.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Events
     **/
    _count?: true | EventCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: EventMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: EventMaxAggregateInputType;
  };

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
    [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>;
  };

  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: EventWhereInput;
      orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[];
      by: EventScalarFieldEnum[] | EventScalarFieldEnum;
      having?: EventScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: EventCountAggregateInputType | true;
      _min?: EventMinAggregateInputType;
      _max?: EventMaxAggregateInputType;
    };

  export type EventGroupByOutputType = {
    id: string;
    title: string;
    description: string | null;
    date: Date;
    projectId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: EventCountAggregateOutputType | null;
    _min: EventMinAggregateOutputType | null;
    _max: EventMaxAggregateOutputType | null;
  };

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> & {
        [P in keyof T & keyof EventGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], EventGroupByOutputType[P]>
          : GetScalarType<T[P], EventGroupByOutputType[P]>;
      }
    >
  >;

  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        title?: boolean;
        description?: boolean;
        date?: boolean;
        projectId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        project?: boolean | ProjectDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['event']
    >;

  export type EventSelectScalar = {
    id?: boolean;
    title?: boolean;
    description?: boolean;
    date?: boolean;
    projectId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'id' | 'title' | 'description' | 'date' | 'projectId' | 'createdAt' | 'updatedAt',
      ExtArgs['result']['event']
    >;
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>;
  };

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Event';
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        description: string | null;
        date: Date;
        projectId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['event']
    >;
    composites: {};
  };

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<
    Prisma.$EventPayload,
    S
  >;

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    EventFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: EventCountAggregateInputType | true;
  };

  export interface EventDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event']; meta: { name: 'Event' } };
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(
      args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>
    ): Prisma__EventClient<
      $Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(
      args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EventClient<
      $Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(
      args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>
    ): Prisma__EventClient<
      $Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EventClient<
      $Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     *
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     *
     */
    findMany<T extends EventFindManyArgs>(
      args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     *
     */
    create<T extends EventCreateArgs>(
      args: SelectSubset<T, EventCreateArgs<ExtArgs>>
    ): Prisma__EventClient<
      $Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends EventCreateManyArgs>(
      args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     *
     */
    delete<T extends EventDeleteArgs>(
      args: SelectSubset<T, EventDeleteArgs<ExtArgs>>
    ): Prisma__EventClient<
      $Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends EventUpdateArgs>(
      args: SelectSubset<T, EventUpdateArgs<ExtArgs>>
    ): Prisma__EventClient<
      $Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends EventDeleteManyArgs>(
      args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends EventUpdateManyArgs>(
      args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(
      args: SelectSubset<T, EventUpsertArgs<ExtArgs>>
    ): Prisma__EventClient<
      $Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
     **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends EventAggregateArgs>(
      args: Subset<T, EventAggregateArgs>
    ): Prisma.PrismaPromise<GetEventAggregateType<T>>;

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Event model
     */
    readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ProjectDefaultArgs<ExtArgs>>
    ): Prisma__ProjectClient<
      | $Result.GetResult<
          Prisma.$ProjectPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<'Event', 'String'>;
    readonly title: FieldRef<'Event', 'String'>;
    readonly description: FieldRef<'Event', 'String'>;
    readonly date: FieldRef<'Event', 'DateTime'>;
    readonly projectId: FieldRef<'Event', 'String'>;
    readonly createdAt: FieldRef<'Event', 'DateTime'>;
    readonly updatedAt: FieldRef<'Event', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput;
  };

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput;
  };

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Events.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Events.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * Event findMany
   */
  export type EventFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Events.
     */
    skip?: number;
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Event
       */
      select?: EventSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Event
       */
      omit?: EventOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: EventInclude<ExtArgs> | null;
      /**
       * The data needed to create a Event.
       */
      data: XOR<EventCreateInput, EventUncheckedCreateInput>;
    };

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Event
       */
      select?: EventSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Event
       */
      omit?: EventOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: EventInclude<ExtArgs> | null;
      /**
       * The data needed to update a Event.
       */
      data: XOR<EventUpdateInput, EventUncheckedUpdateInput>;
      /**
       * Choose, which Event to update.
       */
      where: EventWhereUniqueInput;
    };

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>;
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput;
    /**
     * Limit how many Events to update.
     */
    limit?: number;
  };

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Event
       */
      select?: EventSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Event
       */
      omit?: EventOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: EventInclude<ExtArgs> | null;
      /**
       * The filter to search for the Event to update in case it exists.
       */
      where: EventWhereUniqueInput;
      /**
       * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
       */
      create: XOR<EventCreateInput, EventUncheckedCreateInput>;
      /**
       * In case the Event was found with the provided `where` argument, update it with this data.
       */
      update: XOR<EventUpdateInput, EventUncheckedUpdateInput>;
    };

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Event
       */
      select?: EventSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Event
       */
      omit?: EventOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: EventInclude<ExtArgs> | null;
      /**
       * Filter which Event to delete.
       */
      where: EventWhereUniqueInput;
    };

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput;
    /**
     * Limit how many Events to delete.
     */
    limit?: number;
  };

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Event
       */
      select?: EventSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Event
       */
      omit?: EventOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: EventInclude<ExtArgs> | null;
    };

  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null;
    _avg: AttendanceAvgAggregateOutputType | null;
    _sum: AttendanceSumAggregateOutputType | null;
    _min: AttendanceMinAggregateOutputType | null;
    _max: AttendanceMaxAggregateOutputType | null;
  };

  export type AttendanceAvgAggregateOutputType = {
    checkInLatitude: number | null;
    checkInLongitude: number | null;
    checkOutLatitude: number | null;
    checkOutLongitude: number | null;
    totalHours: number | null;
  };

  export type AttendanceSumAggregateOutputType = {
    checkInLatitude: number | null;
    checkInLongitude: number | null;
    checkOutLatitude: number | null;
    checkOutLongitude: number | null;
    totalHours: number | null;
  };

  export type AttendanceMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    checkInTime: Date | null;
    checkOutTime: Date | null;
    checkInLatitude: number | null;
    checkInLongitude: number | null;
    checkOutLatitude: number | null;
    checkOutLongitude: number | null;
    checkInIpAddress: string | null;
    checkOutIpAddress: string | null;
    checkInDeviceInfo: string | null;
    checkOutDeviceInfo: string | null;
    totalHours: number | null;
    notes: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    checkInLocationName: string | null;
    checkOutLocationName: string | null;
    projectId: string | null;
    taskId: string | null;
    autoCheckout: boolean | null;
  };

  export type AttendanceMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    checkInTime: Date | null;
    checkOutTime: Date | null;
    checkInLatitude: number | null;
    checkInLongitude: number | null;
    checkOutLatitude: number | null;
    checkOutLongitude: number | null;
    checkInIpAddress: string | null;
    checkOutIpAddress: string | null;
    checkInDeviceInfo: string | null;
    checkOutDeviceInfo: string | null;
    totalHours: number | null;
    notes: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    checkInLocationName: string | null;
    checkOutLocationName: string | null;
    projectId: string | null;
    taskId: string | null;
    autoCheckout: boolean | null;
  };

  export type AttendanceCountAggregateOutputType = {
    id: number;
    userId: number;
    checkInTime: number;
    checkOutTime: number;
    checkInLatitude: number;
    checkInLongitude: number;
    checkOutLatitude: number;
    checkOutLongitude: number;
    checkInIpAddress: number;
    checkOutIpAddress: number;
    checkInDeviceInfo: number;
    checkOutDeviceInfo: number;
    totalHours: number;
    notes: number;
    createdAt: number;
    updatedAt: number;
    checkInLocationName: number;
    checkOutLocationName: number;
    projectId: number;
    taskId: number;
    autoCheckout: number;
    _all: number;
  };

  export type AttendanceAvgAggregateInputType = {
    checkInLatitude?: true;
    checkInLongitude?: true;
    checkOutLatitude?: true;
    checkOutLongitude?: true;
    totalHours?: true;
  };

  export type AttendanceSumAggregateInputType = {
    checkInLatitude?: true;
    checkInLongitude?: true;
    checkOutLatitude?: true;
    checkOutLongitude?: true;
    totalHours?: true;
  };

  export type AttendanceMinAggregateInputType = {
    id?: true;
    userId?: true;
    checkInTime?: true;
    checkOutTime?: true;
    checkInLatitude?: true;
    checkInLongitude?: true;
    checkOutLatitude?: true;
    checkOutLongitude?: true;
    checkInIpAddress?: true;
    checkOutIpAddress?: true;
    checkInDeviceInfo?: true;
    checkOutDeviceInfo?: true;
    totalHours?: true;
    notes?: true;
    createdAt?: true;
    updatedAt?: true;
    checkInLocationName?: true;
    checkOutLocationName?: true;
    projectId?: true;
    taskId?: true;
    autoCheckout?: true;
  };

  export type AttendanceMaxAggregateInputType = {
    id?: true;
    userId?: true;
    checkInTime?: true;
    checkOutTime?: true;
    checkInLatitude?: true;
    checkInLongitude?: true;
    checkOutLatitude?: true;
    checkOutLongitude?: true;
    checkInIpAddress?: true;
    checkOutIpAddress?: true;
    checkInDeviceInfo?: true;
    checkOutDeviceInfo?: true;
    totalHours?: true;
    notes?: true;
    createdAt?: true;
    updatedAt?: true;
    checkInLocationName?: true;
    checkOutLocationName?: true;
    projectId?: true;
    taskId?: true;
    autoCheckout?: true;
  };

  export type AttendanceCountAggregateInputType = {
    id?: true;
    userId?: true;
    checkInTime?: true;
    checkOutTime?: true;
    checkInLatitude?: true;
    checkInLongitude?: true;
    checkOutLatitude?: true;
    checkOutLongitude?: true;
    checkInIpAddress?: true;
    checkOutIpAddress?: true;
    checkInDeviceInfo?: true;
    checkOutDeviceInfo?: true;
    totalHours?: true;
    notes?: true;
    createdAt?: true;
    updatedAt?: true;
    checkInLocationName?: true;
    checkOutLocationName?: true;
    projectId?: true;
    taskId?: true;
    autoCheckout?: true;
    _all?: true;
  };

  export type AttendanceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Attendances.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Attendances
     **/
    _count?: true | AttendanceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AttendanceAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AttendanceSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AttendanceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AttendanceMaxAggregateInputType;
  };

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
    [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>;
  };

  export type AttendanceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AttendanceWhereInput;
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[];
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum;
    having?: AttendanceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AttendanceCountAggregateInputType | true;
    _avg?: AttendanceAvgAggregateInputType;
    _sum?: AttendanceSumAggregateInputType;
    _min?: AttendanceMinAggregateInputType;
    _max?: AttendanceMaxAggregateInputType;
  };

  export type AttendanceGroupByOutputType = {
    id: string;
    userId: string;
    checkInTime: Date;
    checkOutTime: Date | null;
    checkInLatitude: number | null;
    checkInLongitude: number | null;
    checkOutLatitude: number | null;
    checkOutLongitude: number | null;
    checkInIpAddress: string | null;
    checkOutIpAddress: string | null;
    checkInDeviceInfo: string | null;
    checkOutDeviceInfo: string | null;
    totalHours: number | null;
    notes: string | null;
    createdAt: Date;
    updatedAt: Date;
    checkInLocationName: string | null;
    checkOutLocationName: string | null;
    projectId: string | null;
    taskId: string | null;
    autoCheckout: boolean;
    _count: AttendanceCountAggregateOutputType | null;
    _avg: AttendanceAvgAggregateOutputType | null;
    _sum: AttendanceSumAggregateOutputType | null;
    _min: AttendanceMinAggregateOutputType | null;
    _max: AttendanceMaxAggregateOutputType | null;
  };

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AttendanceGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
          : GetScalarType<T[P], AttendanceGroupByOutputType[P]>;
      }
    >
  >;

  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        checkInTime?: boolean;
        checkOutTime?: boolean;
        checkInLatitude?: boolean;
        checkInLongitude?: boolean;
        checkOutLatitude?: boolean;
        checkOutLongitude?: boolean;
        checkInIpAddress?: boolean;
        checkOutIpAddress?: boolean;
        checkInDeviceInfo?: boolean;
        checkOutDeviceInfo?: boolean;
        totalHours?: boolean;
        notes?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        checkInLocationName?: boolean;
        checkOutLocationName?: boolean;
        projectId?: boolean;
        taskId?: boolean;
        autoCheckout?: boolean;
        project?: boolean | Attendance$projectArgs<ExtArgs>;
        task?: boolean | Attendance$taskArgs<ExtArgs>;
        user?: boolean | UserDefaultArgs<ExtArgs>;
        correctionRequests?: boolean | Attendance$correctionRequestsArgs<ExtArgs>;
        _count?: boolean | AttendanceCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['attendance']
    >;

  export type AttendanceSelectScalar = {
    id?: boolean;
    userId?: boolean;
    checkInTime?: boolean;
    checkOutTime?: boolean;
    checkInLatitude?: boolean;
    checkInLongitude?: boolean;
    checkOutLatitude?: boolean;
    checkOutLongitude?: boolean;
    checkInIpAddress?: boolean;
    checkOutIpAddress?: boolean;
    checkInDeviceInfo?: boolean;
    checkOutDeviceInfo?: boolean;
    totalHours?: boolean;
    notes?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    checkInLocationName?: boolean;
    checkOutLocationName?: boolean;
    projectId?: boolean;
    taskId?: boolean;
    autoCheckout?: boolean;
  };

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'userId'
      | 'checkInTime'
      | 'checkOutTime'
      | 'checkInLatitude'
      | 'checkInLongitude'
      | 'checkOutLatitude'
      | 'checkOutLongitude'
      | 'checkInIpAddress'
      | 'checkOutIpAddress'
      | 'checkInDeviceInfo'
      | 'checkOutDeviceInfo'
      | 'totalHours'
      | 'notes'
      | 'createdAt'
      | 'updatedAt'
      | 'checkInLocationName'
      | 'checkOutLocationName'
      | 'projectId'
      | 'taskId'
      | 'autoCheckout',
      ExtArgs['result']['attendance']
    >;
  export type AttendanceInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    project?: boolean | Attendance$projectArgs<ExtArgs>;
    task?: boolean | Attendance$taskArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
    correctionRequests?: boolean | Attendance$correctionRequestsArgs<ExtArgs>;
    _count?: boolean | AttendanceCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $AttendancePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Attendance';
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null;
      task: Prisma.$TaskPayload<ExtArgs> | null;
      user: Prisma.$UserPayload<ExtArgs>;
      correctionRequests: Prisma.$AttendanceCorrectionRequestPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        checkInTime: Date;
        checkOutTime: Date | null;
        checkInLatitude: number | null;
        checkInLongitude: number | null;
        checkOutLatitude: number | null;
        checkOutLongitude: number | null;
        checkInIpAddress: string | null;
        checkOutIpAddress: string | null;
        checkInDeviceInfo: string | null;
        checkOutDeviceInfo: string | null;
        totalHours: number | null;
        notes: string | null;
        createdAt: Date;
        updatedAt: Date;
        checkInLocationName: string | null;
        checkOutLocationName: string | null;
        projectId: string | null;
        taskId: string | null;
        autoCheckout: boolean;
      },
      ExtArgs['result']['attendance']
    >;
    composites: {};
  };

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> =
    $Result.GetResult<Prisma.$AttendancePayload, S>;

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true;
    };

  export interface AttendanceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Attendance'];
      meta: { name: 'Attendance' };
    };
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(
      args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>
    ): Prisma__AttendanceClient<
      $Result.GetResult<
        Prisma.$AttendancePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AttendanceClient<
      $Result.GetResult<
        Prisma.$AttendancePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(
      args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>
    ): Prisma__AttendanceClient<
      $Result.GetResult<
        Prisma.$AttendancePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AttendanceClient<
      $Result.GetResult<
        Prisma.$AttendancePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     *
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AttendanceFindManyArgs>(
      args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     *
     */
    create<T extends AttendanceCreateArgs>(
      args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>
    ): Prisma__AttendanceClient<
      $Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AttendanceCreateManyArgs>(
      args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     *
     */
    delete<T extends AttendanceDeleteArgs>(
      args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>
    ): Prisma__AttendanceClient<
      $Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AttendanceUpdateArgs>(
      args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>
    ): Prisma__AttendanceClient<
      $Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(
      args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AttendanceUpdateManyArgs>(
      args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(
      args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>
    ): Prisma__AttendanceClient<
      $Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
     **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AttendanceAggregateArgs>(
      args: Subset<T, AttendanceAggregateArgs>
    ): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>;

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Attendance model
     */
    readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    project<T extends Attendance$projectArgs<ExtArgs> = {}>(
      args?: Subset<T, Attendance$projectArgs<ExtArgs>>
    ): Prisma__ProjectClient<
      $Result.GetResult<
        Prisma.$ProjectPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    task<T extends Attendance$taskArgs<ExtArgs> = {}>(
      args?: Subset<T, Attendance$taskArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<
        Prisma.$TaskPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    correctionRequests<T extends Attendance$correctionRequestsArgs<ExtArgs> = {}>(
      args?: Subset<T, Attendance$correctionRequestsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AttendanceCorrectionRequestPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<'Attendance', 'String'>;
    readonly userId: FieldRef<'Attendance', 'String'>;
    readonly checkInTime: FieldRef<'Attendance', 'DateTime'>;
    readonly checkOutTime: FieldRef<'Attendance', 'DateTime'>;
    readonly checkInLatitude: FieldRef<'Attendance', 'Float'>;
    readonly checkInLongitude: FieldRef<'Attendance', 'Float'>;
    readonly checkOutLatitude: FieldRef<'Attendance', 'Float'>;
    readonly checkOutLongitude: FieldRef<'Attendance', 'Float'>;
    readonly checkInIpAddress: FieldRef<'Attendance', 'String'>;
    readonly checkOutIpAddress: FieldRef<'Attendance', 'String'>;
    readonly checkInDeviceInfo: FieldRef<'Attendance', 'String'>;
    readonly checkOutDeviceInfo: FieldRef<'Attendance', 'String'>;
    readonly totalHours: FieldRef<'Attendance', 'Float'>;
    readonly notes: FieldRef<'Attendance', 'String'>;
    readonly createdAt: FieldRef<'Attendance', 'DateTime'>;
    readonly updatedAt: FieldRef<'Attendance', 'DateTime'>;
    readonly checkInLocationName: FieldRef<'Attendance', 'String'>;
    readonly checkOutLocationName: FieldRef<'Attendance', 'String'>;
    readonly projectId: FieldRef<'Attendance', 'String'>;
    readonly taskId: FieldRef<'Attendance', 'String'>;
    readonly autoCheckout: FieldRef<'Attendance', 'Boolean'>;
  }

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null;
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput;
  };

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null;
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput;
  };

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null;
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Attendances.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[];
  };

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null;
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Attendances.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[];
  };

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null;
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Attendances.
     */
    skip?: number;
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[];
  };

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null;
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>;
  };

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null;
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>;
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput;
  };

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>;
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput;
    /**
     * Limit how many Attendances to update.
     */
    limit?: number;
  };

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null;
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput;
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>;
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>;
  };

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null;
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput;
  };

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput;
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number;
  };

  /**
   * Attendance.project
   */
  export type Attendance$projectArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null;
    where?: ProjectWhereInput;
  };

  /**
   * Attendance.task
   */
  export type Attendance$taskArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    where?: TaskWhereInput;
  };

  /**
   * Attendance.correctionRequests
   */
  export type Attendance$correctionRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceCorrectionRequest
     */
    select?: AttendanceCorrectionRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceCorrectionRequest
     */
    omit?: AttendanceCorrectionRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCorrectionRequestInclude<ExtArgs> | null;
    where?: AttendanceCorrectionRequestWhereInput;
    orderBy?:
      | AttendanceCorrectionRequestOrderByWithRelationInput
      | AttendanceCorrectionRequestOrderByWithRelationInput[];
    cursor?: AttendanceCorrectionRequestWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | AttendanceCorrectionRequestScalarFieldEnum
      | AttendanceCorrectionRequestScalarFieldEnum[];
  };

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null;
  };

  /**
   * Model AttendanceSettings
   */

  export type AggregateAttendanceSettings = {
    _count: AttendanceSettingsCountAggregateOutputType | null;
    _avg: AttendanceSettingsAvgAggregateOutputType | null;
    _sum: AttendanceSettingsSumAggregateOutputType | null;
    _min: AttendanceSettingsMinAggregateOutputType | null;
    _max: AttendanceSettingsMaxAggregateOutputType | null;
  };

  export type AttendanceSettingsAvgAggregateOutputType = {
    workHoursPerDay: number | null;
  };

  export type AttendanceSettingsSumAggregateOutputType = {
    workHoursPerDay: number | null;
  };

  export type AttendanceSettingsMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    workHoursPerDay: number | null;
    workDays: string | null;
    reminderEnabled: boolean | null;
    reminderTime: string | null;
    autoCheckoutEnabled: boolean | null;
    autoCheckoutTime: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AttendanceSettingsMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    workHoursPerDay: number | null;
    workDays: string | null;
    reminderEnabled: boolean | null;
    reminderTime: string | null;
    autoCheckoutEnabled: boolean | null;
    autoCheckoutTime: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AttendanceSettingsCountAggregateOutputType = {
    id: number;
    userId: number;
    workHoursPerDay: number;
    workDays: number;
    reminderEnabled: number;
    reminderTime: number;
    autoCheckoutEnabled: number;
    autoCheckoutTime: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type AttendanceSettingsAvgAggregateInputType = {
    workHoursPerDay?: true;
  };

  export type AttendanceSettingsSumAggregateInputType = {
    workHoursPerDay?: true;
  };

  export type AttendanceSettingsMinAggregateInputType = {
    id?: true;
    userId?: true;
    workHoursPerDay?: true;
    workDays?: true;
    reminderEnabled?: true;
    reminderTime?: true;
    autoCheckoutEnabled?: true;
    autoCheckoutTime?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AttendanceSettingsMaxAggregateInputType = {
    id?: true;
    userId?: true;
    workHoursPerDay?: true;
    workDays?: true;
    reminderEnabled?: true;
    reminderTime?: true;
    autoCheckoutEnabled?: true;
    autoCheckoutTime?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AttendanceSettingsCountAggregateInputType = {
    id?: true;
    userId?: true;
    workHoursPerDay?: true;
    workDays?: true;
    reminderEnabled?: true;
    reminderTime?: true;
    autoCheckoutEnabled?: true;
    autoCheckoutTime?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type AttendanceSettingsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AttendanceSettings to aggregate.
     */
    where?: AttendanceSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AttendanceSettings to fetch.
     */
    orderBy?:
      | AttendanceSettingsOrderByWithRelationInput
      | AttendanceSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AttendanceSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AttendanceSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AttendanceSettings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AttendanceSettings
     **/
    _count?: true | AttendanceSettingsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AttendanceSettingsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AttendanceSettingsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AttendanceSettingsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AttendanceSettingsMaxAggregateInputType;
  };

  export type GetAttendanceSettingsAggregateType<T extends AttendanceSettingsAggregateArgs> = {
    [P in keyof T & keyof AggregateAttendanceSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceSettings[P]>
      : GetScalarType<T[P], AggregateAttendanceSettings[P]>;
  };

  export type AttendanceSettingsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AttendanceSettingsWhereInput;
    orderBy?:
      | AttendanceSettingsOrderByWithAggregationInput
      | AttendanceSettingsOrderByWithAggregationInput[];
    by: AttendanceSettingsScalarFieldEnum[] | AttendanceSettingsScalarFieldEnum;
    having?: AttendanceSettingsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AttendanceSettingsCountAggregateInputType | true;
    _avg?: AttendanceSettingsAvgAggregateInputType;
    _sum?: AttendanceSettingsSumAggregateInputType;
    _min?: AttendanceSettingsMinAggregateInputType;
    _max?: AttendanceSettingsMaxAggregateInputType;
  };

  export type AttendanceSettingsGroupByOutputType = {
    id: string;
    userId: string;
    workHoursPerDay: number;
    workDays: string;
    reminderEnabled: boolean;
    reminderTime: string | null;
    autoCheckoutEnabled: boolean;
    autoCheckoutTime: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: AttendanceSettingsCountAggregateOutputType | null;
    _avg: AttendanceSettingsAvgAggregateOutputType | null;
    _sum: AttendanceSettingsSumAggregateOutputType | null;
    _min: AttendanceSettingsMinAggregateOutputType | null;
    _max: AttendanceSettingsMaxAggregateOutputType | null;
  };

  type GetAttendanceSettingsGroupByPayload<T extends AttendanceSettingsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AttendanceSettingsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof AttendanceSettingsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceSettingsGroupByOutputType[P]>;
        }
      >
    >;

  export type AttendanceSettingsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      workHoursPerDay?: boolean;
      workDays?: boolean;
      reminderEnabled?: boolean;
      reminderTime?: boolean;
      autoCheckoutEnabled?: boolean;
      autoCheckoutTime?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['attendanceSettings']
  >;

  export type AttendanceSettingsSelectScalar = {
    id?: boolean;
    userId?: boolean;
    workHoursPerDay?: boolean;
    workDays?: boolean;
    reminderEnabled?: boolean;
    reminderTime?: boolean;
    autoCheckoutEnabled?: boolean;
    autoCheckoutTime?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type AttendanceSettingsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'userId'
    | 'workHoursPerDay'
    | 'workDays'
    | 'reminderEnabled'
    | 'reminderTime'
    | 'autoCheckoutEnabled'
    | 'autoCheckoutTime'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['attendanceSettings']
  >;
  export type AttendanceSettingsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AttendanceSettingsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'AttendanceSettings';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        workHoursPerDay: number;
        workDays: string;
        reminderEnabled: boolean;
        reminderTime: string | null;
        autoCheckoutEnabled: boolean;
        autoCheckoutTime: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['attendanceSettings']
    >;
    composites: {};
  };

  type AttendanceSettingsGetPayload<
    S extends boolean | null | undefined | AttendanceSettingsDefaultArgs,
  > = $Result.GetResult<Prisma.$AttendanceSettingsPayload, S>;

  type AttendanceSettingsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<AttendanceSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: AttendanceSettingsCountAggregateInputType | true;
  };

  export interface AttendanceSettingsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AttendanceSettings'];
      meta: { name: 'AttendanceSettings' };
    };
    /**
     * Find zero or one AttendanceSettings that matches the filter.
     * @param {AttendanceSettingsFindUniqueArgs} args - Arguments to find a AttendanceSettings
     * @example
     * // Get one AttendanceSettings
     * const attendanceSettings = await prisma.attendanceSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceSettingsFindUniqueArgs>(
      args: SelectSubset<T, AttendanceSettingsFindUniqueArgs<ExtArgs>>
    ): Prisma__AttendanceSettingsClient<
      $Result.GetResult<
        Prisma.$AttendanceSettingsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AttendanceSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceSettingsFindUniqueOrThrowArgs} args - Arguments to find a AttendanceSettings
     * @example
     * // Get one AttendanceSettings
     * const attendanceSettings = await prisma.attendanceSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceSettingsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AttendanceSettingsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AttendanceSettingsClient<
      $Result.GetResult<
        Prisma.$AttendanceSettingsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AttendanceSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSettingsFindFirstArgs} args - Arguments to find a AttendanceSettings
     * @example
     * // Get one AttendanceSettings
     * const attendanceSettings = await prisma.attendanceSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceSettingsFindFirstArgs>(
      args?: SelectSubset<T, AttendanceSettingsFindFirstArgs<ExtArgs>>
    ): Prisma__AttendanceSettingsClient<
      $Result.GetResult<
        Prisma.$AttendanceSettingsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AttendanceSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSettingsFindFirstOrThrowArgs} args - Arguments to find a AttendanceSettings
     * @example
     * // Get one AttendanceSettings
     * const attendanceSettings = await prisma.attendanceSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceSettingsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AttendanceSettingsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AttendanceSettingsClient<
      $Result.GetResult<
        Prisma.$AttendanceSettingsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AttendanceSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceSettings
     * const attendanceSettings = await prisma.attendanceSettings.findMany()
     *
     * // Get first 10 AttendanceSettings
     * const attendanceSettings = await prisma.attendanceSettings.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const attendanceSettingsWithIdOnly = await prisma.attendanceSettings.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AttendanceSettingsFindManyArgs>(
      args?: SelectSubset<T, AttendanceSettingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AttendanceSettingsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AttendanceSettings.
     * @param {AttendanceSettingsCreateArgs} args - Arguments to create a AttendanceSettings.
     * @example
     * // Create one AttendanceSettings
     * const AttendanceSettings = await prisma.attendanceSettings.create({
     *   data: {
     *     // ... data to create a AttendanceSettings
     *   }
     * })
     *
     */
    create<T extends AttendanceSettingsCreateArgs>(
      args: SelectSubset<T, AttendanceSettingsCreateArgs<ExtArgs>>
    ): Prisma__AttendanceSettingsClient<
      $Result.GetResult<Prisma.$AttendanceSettingsPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AttendanceSettings.
     * @param {AttendanceSettingsCreateManyArgs} args - Arguments to create many AttendanceSettings.
     * @example
     * // Create many AttendanceSettings
     * const attendanceSettings = await prisma.attendanceSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AttendanceSettingsCreateManyArgs>(
      args?: SelectSubset<T, AttendanceSettingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a AttendanceSettings.
     * @param {AttendanceSettingsDeleteArgs} args - Arguments to delete one AttendanceSettings.
     * @example
     * // Delete one AttendanceSettings
     * const AttendanceSettings = await prisma.attendanceSettings.delete({
     *   where: {
     *     // ... filter to delete one AttendanceSettings
     *   }
     * })
     *
     */
    delete<T extends AttendanceSettingsDeleteArgs>(
      args: SelectSubset<T, AttendanceSettingsDeleteArgs<ExtArgs>>
    ): Prisma__AttendanceSettingsClient<
      $Result.GetResult<Prisma.$AttendanceSettingsPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AttendanceSettings.
     * @param {AttendanceSettingsUpdateArgs} args - Arguments to update one AttendanceSettings.
     * @example
     * // Update one AttendanceSettings
     * const attendanceSettings = await prisma.attendanceSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AttendanceSettingsUpdateArgs>(
      args: SelectSubset<T, AttendanceSettingsUpdateArgs<ExtArgs>>
    ): Prisma__AttendanceSettingsClient<
      $Result.GetResult<Prisma.$AttendanceSettingsPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AttendanceSettings.
     * @param {AttendanceSettingsDeleteManyArgs} args - Arguments to filter AttendanceSettings to delete.
     * @example
     * // Delete a few AttendanceSettings
     * const { count } = await prisma.attendanceSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AttendanceSettingsDeleteManyArgs>(
      args?: SelectSubset<T, AttendanceSettingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AttendanceSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceSettings
     * const attendanceSettings = await prisma.attendanceSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AttendanceSettingsUpdateManyArgs>(
      args: SelectSubset<T, AttendanceSettingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one AttendanceSettings.
     * @param {AttendanceSettingsUpsertArgs} args - Arguments to update or create a AttendanceSettings.
     * @example
     * // Update or create a AttendanceSettings
     * const attendanceSettings = await prisma.attendanceSettings.upsert({
     *   create: {
     *     // ... data to create a AttendanceSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceSettings we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceSettingsUpsertArgs>(
      args: SelectSubset<T, AttendanceSettingsUpsertArgs<ExtArgs>>
    ): Prisma__AttendanceSettingsClient<
      $Result.GetResult<Prisma.$AttendanceSettingsPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AttendanceSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSettingsCountArgs} args - Arguments to filter AttendanceSettings to count.
     * @example
     * // Count the number of AttendanceSettings
     * const count = await prisma.attendanceSettings.count({
     *   where: {
     *     // ... the filter for the AttendanceSettings we want to count
     *   }
     * })
     **/
    count<T extends AttendanceSettingsCountArgs>(
      args?: Subset<T, AttendanceSettingsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceSettingsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AttendanceSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AttendanceSettingsAggregateArgs>(
      args: Subset<T, AttendanceSettingsAggregateArgs>
    ): Prisma.PrismaPromise<GetAttendanceSettingsAggregateType<T>>;

    /**
     * Group by AttendanceSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AttendanceSettingsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceSettingsGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AttendanceSettingsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAttendanceSettingsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AttendanceSettings model
     */
    readonly fields: AttendanceSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceSettingsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AttendanceSettings model
   */
  interface AttendanceSettingsFieldRefs {
    readonly id: FieldRef<'AttendanceSettings', 'String'>;
    readonly userId: FieldRef<'AttendanceSettings', 'String'>;
    readonly workHoursPerDay: FieldRef<'AttendanceSettings', 'Float'>;
    readonly workDays: FieldRef<'AttendanceSettings', 'String'>;
    readonly reminderEnabled: FieldRef<'AttendanceSettings', 'Boolean'>;
    readonly reminderTime: FieldRef<'AttendanceSettings', 'String'>;
    readonly autoCheckoutEnabled: FieldRef<'AttendanceSettings', 'Boolean'>;
    readonly autoCheckoutTime: FieldRef<'AttendanceSettings', 'String'>;
    readonly createdAt: FieldRef<'AttendanceSettings', 'DateTime'>;
    readonly updatedAt: FieldRef<'AttendanceSettings', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * AttendanceSettings findUnique
   */
  export type AttendanceSettingsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceSettings
     */
    select?: AttendanceSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceSettings
     */
    omit?: AttendanceSettingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSettingsInclude<ExtArgs> | null;
    /**
     * Filter, which AttendanceSettings to fetch.
     */
    where: AttendanceSettingsWhereUniqueInput;
  };

  /**
   * AttendanceSettings findUniqueOrThrow
   */
  export type AttendanceSettingsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceSettings
     */
    select?: AttendanceSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceSettings
     */
    omit?: AttendanceSettingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSettingsInclude<ExtArgs> | null;
    /**
     * Filter, which AttendanceSettings to fetch.
     */
    where: AttendanceSettingsWhereUniqueInput;
  };

  /**
   * AttendanceSettings findFirst
   */
  export type AttendanceSettingsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceSettings
     */
    select?: AttendanceSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceSettings
     */
    omit?: AttendanceSettingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSettingsInclude<ExtArgs> | null;
    /**
     * Filter, which AttendanceSettings to fetch.
     */
    where?: AttendanceSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AttendanceSettings to fetch.
     */
    orderBy?:
      | AttendanceSettingsOrderByWithRelationInput
      | AttendanceSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AttendanceSettings.
     */
    cursor?: AttendanceSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AttendanceSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AttendanceSettings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AttendanceSettings.
     */
    distinct?: AttendanceSettingsScalarFieldEnum | AttendanceSettingsScalarFieldEnum[];
  };

  /**
   * AttendanceSettings findFirstOrThrow
   */
  export type AttendanceSettingsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceSettings
     */
    select?: AttendanceSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceSettings
     */
    omit?: AttendanceSettingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSettingsInclude<ExtArgs> | null;
    /**
     * Filter, which AttendanceSettings to fetch.
     */
    where?: AttendanceSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AttendanceSettings to fetch.
     */
    orderBy?:
      | AttendanceSettingsOrderByWithRelationInput
      | AttendanceSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AttendanceSettings.
     */
    cursor?: AttendanceSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AttendanceSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AttendanceSettings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AttendanceSettings.
     */
    distinct?: AttendanceSettingsScalarFieldEnum | AttendanceSettingsScalarFieldEnum[];
  };

  /**
   * AttendanceSettings findMany
   */
  export type AttendanceSettingsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceSettings
     */
    select?: AttendanceSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceSettings
     */
    omit?: AttendanceSettingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSettingsInclude<ExtArgs> | null;
    /**
     * Filter, which AttendanceSettings to fetch.
     */
    where?: AttendanceSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AttendanceSettings to fetch.
     */
    orderBy?:
      | AttendanceSettingsOrderByWithRelationInput
      | AttendanceSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AttendanceSettings.
     */
    cursor?: AttendanceSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AttendanceSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AttendanceSettings.
     */
    skip?: number;
    distinct?: AttendanceSettingsScalarFieldEnum | AttendanceSettingsScalarFieldEnum[];
  };

  /**
   * AttendanceSettings create
   */
  export type AttendanceSettingsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceSettings
     */
    select?: AttendanceSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceSettings
     */
    omit?: AttendanceSettingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSettingsInclude<ExtArgs> | null;
    /**
     * The data needed to create a AttendanceSettings.
     */
    data: XOR<AttendanceSettingsCreateInput, AttendanceSettingsUncheckedCreateInput>;
  };

  /**
   * AttendanceSettings createMany
   */
  export type AttendanceSettingsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AttendanceSettings.
     */
    data: AttendanceSettingsCreateManyInput | AttendanceSettingsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AttendanceSettings update
   */
  export type AttendanceSettingsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceSettings
     */
    select?: AttendanceSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceSettings
     */
    omit?: AttendanceSettingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSettingsInclude<ExtArgs> | null;
    /**
     * The data needed to update a AttendanceSettings.
     */
    data: XOR<AttendanceSettingsUpdateInput, AttendanceSettingsUncheckedUpdateInput>;
    /**
     * Choose, which AttendanceSettings to update.
     */
    where: AttendanceSettingsWhereUniqueInput;
  };

  /**
   * AttendanceSettings updateMany
   */
  export type AttendanceSettingsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AttendanceSettings.
     */
    data: XOR<
      AttendanceSettingsUpdateManyMutationInput,
      AttendanceSettingsUncheckedUpdateManyInput
    >;
    /**
     * Filter which AttendanceSettings to update
     */
    where?: AttendanceSettingsWhereInput;
    /**
     * Limit how many AttendanceSettings to update.
     */
    limit?: number;
  };

  /**
   * AttendanceSettings upsert
   */
  export type AttendanceSettingsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceSettings
     */
    select?: AttendanceSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceSettings
     */
    omit?: AttendanceSettingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSettingsInclude<ExtArgs> | null;
    /**
     * The filter to search for the AttendanceSettings to update in case it exists.
     */
    where: AttendanceSettingsWhereUniqueInput;
    /**
     * In case the AttendanceSettings found by the `where` argument doesn't exist, create a new AttendanceSettings with this data.
     */
    create: XOR<AttendanceSettingsCreateInput, AttendanceSettingsUncheckedCreateInput>;
    /**
     * In case the AttendanceSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceSettingsUpdateInput, AttendanceSettingsUncheckedUpdateInput>;
  };

  /**
   * AttendanceSettings delete
   */
  export type AttendanceSettingsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceSettings
     */
    select?: AttendanceSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceSettings
     */
    omit?: AttendanceSettingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSettingsInclude<ExtArgs> | null;
    /**
     * Filter which AttendanceSettings to delete.
     */
    where: AttendanceSettingsWhereUniqueInput;
  };

  /**
   * AttendanceSettings deleteMany
   */
  export type AttendanceSettingsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AttendanceSettings to delete
     */
    where?: AttendanceSettingsWhereInput;
    /**
     * Limit how many AttendanceSettings to delete.
     */
    limit?: number;
  };

  /**
   * AttendanceSettings without action
   */
  export type AttendanceSettingsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceSettings
     */
    select?: AttendanceSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceSettings
     */
    omit?: AttendanceSettingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSettingsInclude<ExtArgs> | null;
  };

  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null;
    _min: ActivityMinAggregateOutputType | null;
    _max: ActivityMaxAggregateOutputType | null;
  };

  export type ActivityMinAggregateOutputType = {
    id: string | null;
    action: string | null;
    entityType: string | null;
    entityId: string | null;
    description: string | null;
    userId: string | null;
    projectId: string | null;
    taskId: string | null;
    createdAt: Date | null;
  };

  export type ActivityMaxAggregateOutputType = {
    id: string | null;
    action: string | null;
    entityType: string | null;
    entityId: string | null;
    description: string | null;
    userId: string | null;
    projectId: string | null;
    taskId: string | null;
    createdAt: Date | null;
  };

  export type ActivityCountAggregateOutputType = {
    id: number;
    action: number;
    entityType: number;
    entityId: number;
    description: number;
    userId: number;
    projectId: number;
    taskId: number;
    createdAt: number;
    _all: number;
  };

  export type ActivityMinAggregateInputType = {
    id?: true;
    action?: true;
    entityType?: true;
    entityId?: true;
    description?: true;
    userId?: true;
    projectId?: true;
    taskId?: true;
    createdAt?: true;
  };

  export type ActivityMaxAggregateInputType = {
    id?: true;
    action?: true;
    entityType?: true;
    entityId?: true;
    description?: true;
    userId?: true;
    projectId?: true;
    taskId?: true;
    createdAt?: true;
  };

  export type ActivityCountAggregateInputType = {
    id?: true;
    action?: true;
    entityType?: true;
    entityId?: true;
    description?: true;
    userId?: true;
    projectId?: true;
    taskId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type ActivityAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Activities.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Activities
     **/
    _count?: true | ActivityCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ActivityMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ActivityMaxAggregateInputType;
  };

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
    [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>;
  };

  export type ActivityGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ActivityWhereInput;
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[];
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum;
    having?: ActivityScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ActivityCountAggregateInputType | true;
    _min?: ActivityMinAggregateInputType;
    _max?: ActivityMaxAggregateInputType;
  };

  export type ActivityGroupByOutputType = {
    id: string;
    action: string;
    entityType: string;
    entityId: string;
    description: string | null;
    userId: string;
    projectId: string | null;
    taskId: string | null;
    createdAt: Date;
    _count: ActivityCountAggregateOutputType | null;
    _min: ActivityMinAggregateOutputType | null;
    _max: ActivityMaxAggregateOutputType | null;
  };

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ActivityGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
          : GetScalarType<T[P], ActivityGroupByOutputType[P]>;
      }
    >
  >;

  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        action?: boolean;
        entityType?: boolean;
        entityId?: boolean;
        description?: boolean;
        userId?: boolean;
        projectId?: boolean;
        taskId?: boolean;
        createdAt?: boolean;
        project?: boolean | Activity$projectArgs<ExtArgs>;
        task?: boolean | Activity$taskArgs<ExtArgs>;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['activity']
    >;

  export type ActivitySelectScalar = {
    id?: boolean;
    action?: boolean;
    entityType?: boolean;
    entityId?: boolean;
    description?: boolean;
    userId?: boolean;
    projectId?: boolean;
    taskId?: boolean;
    createdAt?: boolean;
  };

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'action'
      | 'entityType'
      | 'entityId'
      | 'description'
      | 'userId'
      | 'projectId'
      | 'taskId'
      | 'createdAt',
      ExtArgs['result']['activity']
    >;
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      project?: boolean | Activity$projectArgs<ExtArgs>;
      task?: boolean | Activity$taskArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    };

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Activity';
      objects: {
        project: Prisma.$ProjectPayload<ExtArgs> | null;
        task: Prisma.$TaskPayload<ExtArgs> | null;
        user: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          action: string;
          entityType: string;
          entityId: string;
          description: string | null;
          userId: string;
          projectId: string | null;
          taskId: string | null;
          createdAt: Date;
        },
        ExtArgs['result']['activity']
      >;
      composites: {};
    };

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> =
    $Result.GetResult<Prisma.$ActivityPayload, S>;

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ActivityFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ActivityCountAggregateInputType | true;
  };

  export interface ActivityDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Activity'];
      meta: { name: 'Activity' };
    };
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(
      args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>
    ): Prisma__ActivityClient<
      $Result.GetResult<
        Prisma.$ActivityPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ActivityClient<
      $Result.GetResult<
        Prisma.$ActivityPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(
      args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>
    ): Prisma__ActivityClient<
      $Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ActivityClient<
      $Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     *
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ActivityFindManyArgs>(
      args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     *
     */
    create<T extends ActivityCreateArgs>(
      args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>
    ): Prisma__ActivityClient<
      $Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ActivityCreateManyArgs>(
      args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     *
     */
    delete<T extends ActivityDeleteArgs>(
      args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>
    ): Prisma__ActivityClient<
      $Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ActivityUpdateArgs>(
      args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>
    ): Prisma__ActivityClient<
      $Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ActivityDeleteManyArgs>(
      args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ActivityUpdateManyArgs>(
      args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(
      args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>
    ): Prisma__ActivityClient<
      $Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
     **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ActivityAggregateArgs>(
      args: Subset<T, ActivityAggregateArgs>
    ): Prisma.PrismaPromise<GetActivityAggregateType<T>>;

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Activity model
     */
    readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    project<T extends Activity$projectArgs<ExtArgs> = {}>(
      args?: Subset<T, Activity$projectArgs<ExtArgs>>
    ): Prisma__ProjectClient<
      $Result.GetResult<
        Prisma.$ProjectPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    task<T extends Activity$taskArgs<ExtArgs> = {}>(
      args?: Subset<T, Activity$taskArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<
        Prisma.$TaskPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<'Activity', 'String'>;
    readonly action: FieldRef<'Activity', 'String'>;
    readonly entityType: FieldRef<'Activity', 'String'>;
    readonly entityId: FieldRef<'Activity', 'String'>;
    readonly description: FieldRef<'Activity', 'String'>;
    readonly userId: FieldRef<'Activity', 'String'>;
    readonly projectId: FieldRef<'Activity', 'String'>;
    readonly taskId: FieldRef<'Activity', 'String'>;
    readonly createdAt: FieldRef<'Activity', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null;
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput;
  };

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null;
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput;
  };

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null;
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Activities.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[];
  };

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null;
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Activities.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[];
  };

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null;
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Activities.
     */
    skip?: number;
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[];
  };

  /**
   * Activity create
   */
  export type ActivityCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null;
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>;
  };

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null;
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>;
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput;
  };

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>;
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput;
    /**
     * Limit how many Activities to update.
     */
    limit?: number;
  };

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null;
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput;
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>;
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>;
  };

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null;
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput;
  };

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput;
    /**
     * Limit how many Activities to delete.
     */
    limit?: number;
  };

  /**
   * Activity.project
   */
  export type Activity$projectArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null;
    where?: ProjectWhereInput;
  };

  /**
   * Activity.task
   */
  export type Activity$taskArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    where?: TaskWhereInput;
  };

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null;
  };

  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null;
    _avg: DocumentAvgAggregateOutputType | null;
    _sum: DocumentSumAggregateOutputType | null;
    _min: DocumentMinAggregateOutputType | null;
    _max: DocumentMaxAggregateOutputType | null;
  };

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null;
  };

  export type DocumentSumAggregateOutputType = {
    fileSize: number | null;
  };

  export type DocumentMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    fileType: string | null;
    fileSize: number | null;
    filePath: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type DocumentMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    fileType: string | null;
    fileSize: number | null;
    filePath: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type DocumentCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    fileType: number;
    fileSize: number;
    filePath: number;
    userId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type DocumentAvgAggregateInputType = {
    fileSize?: true;
  };

  export type DocumentSumAggregateInputType = {
    fileSize?: true;
  };

  export type DocumentMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    fileType?: true;
    fileSize?: true;
    filePath?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type DocumentMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    fileType?: true;
    fileSize?: true;
    filePath?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type DocumentCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    fileType?: true;
    fileSize?: true;
    filePath?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type DocumentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Documents
     **/
    _count?: true | DocumentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DocumentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DocumentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DocumentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DocumentMaxAggregateInputType;
  };

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
    [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>;
  };

  export type DocumentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DocumentWhereInput;
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[];
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum;
    having?: DocumentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DocumentCountAggregateInputType | true;
    _avg?: DocumentAvgAggregateInputType;
    _sum?: DocumentSumAggregateInputType;
    _min?: DocumentMinAggregateInputType;
    _max?: DocumentMaxAggregateInputType;
  };

  export type DocumentGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    fileType: string;
    fileSize: number;
    filePath: string;
    userId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: DocumentCountAggregateOutputType | null;
    _avg: DocumentAvgAggregateOutputType | null;
    _sum: DocumentSumAggregateOutputType | null;
    _min: DocumentMinAggregateOutputType | null;
    _max: DocumentMaxAggregateOutputType | null;
  };

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> & {
        [P in keyof T & keyof DocumentGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
          : GetScalarType<T[P], DocumentGroupByOutputType[P]>;
      }
    >
  >;

  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        description?: boolean;
        fileType?: boolean;
        fileSize?: boolean;
        filePath?: boolean;
        userId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['document']
    >;

  export type DocumentSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    fileType?: boolean;
    fileSize?: boolean;
    filePath?: boolean;
    userId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'description'
      | 'fileType'
      | 'fileSize'
      | 'filePath'
      | 'userId'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['document']
    >;
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      user?: boolean | UserDefaultArgs<ExtArgs>;
    };

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Document';
      objects: {
        user: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          name: string;
          description: string | null;
          fileType: string;
          fileSize: number;
          filePath: string;
          userId: string;
          createdAt: Date;
          updatedAt: Date;
        },
        ExtArgs['result']['document']
      >;
      composites: {};
    };

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> =
    $Result.GetResult<Prisma.$DocumentPayload, S>;

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    DocumentFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: DocumentCountAggregateInputType | true;
  };

  export interface DocumentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Document'];
      meta: { name: 'Document' };
    };
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     *
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DocumentFindManyArgs>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     *
     */
    create<T extends DocumentCreateArgs>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DocumentCreateManyArgs>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     *
     */
    delete<T extends DocumentDeleteArgs>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DocumentUpdateArgs>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DocumentDeleteManyArgs>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DocumentUpdateManyArgs>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
     **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DocumentAggregateArgs>(
      args: Subset<T, DocumentAggregateArgs>
    ): Prisma.PrismaPromise<GetDocumentAggregateType<T>>;

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Document model
     */
    readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<'Document', 'String'>;
    readonly name: FieldRef<'Document', 'String'>;
    readonly description: FieldRef<'Document', 'String'>;
    readonly fileType: FieldRef<'Document', 'String'>;
    readonly fileSize: FieldRef<'Document', 'Int'>;
    readonly filePath: FieldRef<'Document', 'String'>;
    readonly userId: FieldRef<'Document', 'String'>;
    readonly createdAt: FieldRef<'Document', 'DateTime'>;
    readonly updatedAt: FieldRef<'Document', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Document create
   */
  export type DocumentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>;
  };

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Document update
   */
  export type DocumentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>;
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>;
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput;
    /**
     * Limit how many Documents to update.
     */
    limit?: number;
  };

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput;
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>;
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>;
  };

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput;
    /**
     * Limit how many Documents to delete.
     */
    limit?: number;
  };

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
  };

  /**
   * Model AttendanceCorrectionRequest
   */

  export type AggregateAttendanceCorrectionRequest = {
    _count: AttendanceCorrectionRequestCountAggregateOutputType | null;
    _min: AttendanceCorrectionRequestMinAggregateOutputType | null;
    _max: AttendanceCorrectionRequestMaxAggregateOutputType | null;
  };

  export type AttendanceCorrectionRequestMinAggregateOutputType = {
    id: string | null;
    attendanceId: string | null;
    userId: string | null;
    originalCheckInTime: Date | null;
    originalCheckOutTime: Date | null;
    requestedCheckInTime: Date | null;
    requestedCheckOutTime: Date | null;
    reason: string | null;
    status: string | null;
    reviewedBy: string | null;
    reviewedAt: Date | null;
    reviewNotes: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AttendanceCorrectionRequestMaxAggregateOutputType = {
    id: string | null;
    attendanceId: string | null;
    userId: string | null;
    originalCheckInTime: Date | null;
    originalCheckOutTime: Date | null;
    requestedCheckInTime: Date | null;
    requestedCheckOutTime: Date | null;
    reason: string | null;
    status: string | null;
    reviewedBy: string | null;
    reviewedAt: Date | null;
    reviewNotes: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AttendanceCorrectionRequestCountAggregateOutputType = {
    id: number;
    attendanceId: number;
    userId: number;
    originalCheckInTime: number;
    originalCheckOutTime: number;
    requestedCheckInTime: number;
    requestedCheckOutTime: number;
    reason: number;
    status: number;
    reviewedBy: number;
    reviewedAt: number;
    reviewNotes: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type AttendanceCorrectionRequestMinAggregateInputType = {
    id?: true;
    attendanceId?: true;
    userId?: true;
    originalCheckInTime?: true;
    originalCheckOutTime?: true;
    requestedCheckInTime?: true;
    requestedCheckOutTime?: true;
    reason?: true;
    status?: true;
    reviewedBy?: true;
    reviewedAt?: true;
    reviewNotes?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AttendanceCorrectionRequestMaxAggregateInputType = {
    id?: true;
    attendanceId?: true;
    userId?: true;
    originalCheckInTime?: true;
    originalCheckOutTime?: true;
    requestedCheckInTime?: true;
    requestedCheckOutTime?: true;
    reason?: true;
    status?: true;
    reviewedBy?: true;
    reviewedAt?: true;
    reviewNotes?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AttendanceCorrectionRequestCountAggregateInputType = {
    id?: true;
    attendanceId?: true;
    userId?: true;
    originalCheckInTime?: true;
    originalCheckOutTime?: true;
    requestedCheckInTime?: true;
    requestedCheckOutTime?: true;
    reason?: true;
    status?: true;
    reviewedBy?: true;
    reviewedAt?: true;
    reviewNotes?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type AttendanceCorrectionRequestAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AttendanceCorrectionRequest to aggregate.
     */
    where?: AttendanceCorrectionRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AttendanceCorrectionRequests to fetch.
     */
    orderBy?:
      | AttendanceCorrectionRequestOrderByWithRelationInput
      | AttendanceCorrectionRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AttendanceCorrectionRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AttendanceCorrectionRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AttendanceCorrectionRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AttendanceCorrectionRequests
     **/
    _count?: true | AttendanceCorrectionRequestCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AttendanceCorrectionRequestMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AttendanceCorrectionRequestMaxAggregateInputType;
  };

  export type GetAttendanceCorrectionRequestAggregateType<
    T extends AttendanceCorrectionRequestAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAttendanceCorrectionRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceCorrectionRequest[P]>
      : GetScalarType<T[P], AggregateAttendanceCorrectionRequest[P]>;
  };

  export type AttendanceCorrectionRequestGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AttendanceCorrectionRequestWhereInput;
    orderBy?:
      | AttendanceCorrectionRequestOrderByWithAggregationInput
      | AttendanceCorrectionRequestOrderByWithAggregationInput[];
    by: AttendanceCorrectionRequestScalarFieldEnum[] | AttendanceCorrectionRequestScalarFieldEnum;
    having?: AttendanceCorrectionRequestScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AttendanceCorrectionRequestCountAggregateInputType | true;
    _min?: AttendanceCorrectionRequestMinAggregateInputType;
    _max?: AttendanceCorrectionRequestMaxAggregateInputType;
  };

  export type AttendanceCorrectionRequestGroupByOutputType = {
    id: string;
    attendanceId: string;
    userId: string;
    originalCheckInTime: Date;
    originalCheckOutTime: Date | null;
    requestedCheckInTime: Date;
    requestedCheckOutTime: Date | null;
    reason: string;
    status: string;
    reviewedBy: string | null;
    reviewedAt: Date | null;
    reviewNotes: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: AttendanceCorrectionRequestCountAggregateOutputType | null;
    _min: AttendanceCorrectionRequestMinAggregateOutputType | null;
    _max: AttendanceCorrectionRequestMaxAggregateOutputType | null;
  };

  type GetAttendanceCorrectionRequestGroupByPayload<
    T extends AttendanceCorrectionRequestGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceCorrectionRequestGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AttendanceCorrectionRequestGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AttendanceCorrectionRequestGroupByOutputType[P]>
          : GetScalarType<T[P], AttendanceCorrectionRequestGroupByOutputType[P]>;
      }
    >
  >;

  export type AttendanceCorrectionRequestSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      attendanceId?: boolean;
      userId?: boolean;
      originalCheckInTime?: boolean;
      originalCheckOutTime?: boolean;
      requestedCheckInTime?: boolean;
      requestedCheckOutTime?: boolean;
      reason?: boolean;
      status?: boolean;
      reviewedBy?: boolean;
      reviewedAt?: boolean;
      reviewNotes?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      attendance?: boolean | AttendanceDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['attendanceCorrectionRequest']
  >;

  export type AttendanceCorrectionRequestSelectScalar = {
    id?: boolean;
    attendanceId?: boolean;
    userId?: boolean;
    originalCheckInTime?: boolean;
    originalCheckOutTime?: boolean;
    requestedCheckInTime?: boolean;
    requestedCheckOutTime?: boolean;
    reason?: boolean;
    status?: boolean;
    reviewedBy?: boolean;
    reviewedAt?: boolean;
    reviewNotes?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type AttendanceCorrectionRequestOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'attendanceId'
    | 'userId'
    | 'originalCheckInTime'
    | 'originalCheckOutTime'
    | 'requestedCheckInTime'
    | 'requestedCheckOutTime'
    | 'reason'
    | 'status'
    | 'reviewedBy'
    | 'reviewedAt'
    | 'reviewNotes'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['attendanceCorrectionRequest']
  >;
  export type AttendanceCorrectionRequestInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AttendanceCorrectionRequestPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'AttendanceCorrectionRequest';
    objects: {
      attendance: Prisma.$AttendancePayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        attendanceId: string;
        userId: string;
        originalCheckInTime: Date;
        originalCheckOutTime: Date | null;
        requestedCheckInTime: Date;
        requestedCheckOutTime: Date | null;
        reason: string;
        status: string;
        reviewedBy: string | null;
        reviewedAt: Date | null;
        reviewNotes: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['attendanceCorrectionRequest']
    >;
    composites: {};
  };

  type AttendanceCorrectionRequestGetPayload<
    S extends boolean | null | undefined | AttendanceCorrectionRequestDefaultArgs,
  > = $Result.GetResult<Prisma.$AttendanceCorrectionRequestPayload, S>;

  type AttendanceCorrectionRequestCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<AttendanceCorrectionRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: AttendanceCorrectionRequestCountAggregateInputType | true;
  };

  export interface AttendanceCorrectionRequestDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AttendanceCorrectionRequest'];
      meta: { name: 'AttendanceCorrectionRequest' };
    };
    /**
     * Find zero or one AttendanceCorrectionRequest that matches the filter.
     * @param {AttendanceCorrectionRequestFindUniqueArgs} args - Arguments to find a AttendanceCorrectionRequest
     * @example
     * // Get one AttendanceCorrectionRequest
     * const attendanceCorrectionRequest = await prisma.attendanceCorrectionRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceCorrectionRequestFindUniqueArgs>(
      args: SelectSubset<T, AttendanceCorrectionRequestFindUniqueArgs<ExtArgs>>
    ): Prisma__AttendanceCorrectionRequestClient<
      $Result.GetResult<
        Prisma.$AttendanceCorrectionRequestPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AttendanceCorrectionRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceCorrectionRequestFindUniqueOrThrowArgs} args - Arguments to find a AttendanceCorrectionRequest
     * @example
     * // Get one AttendanceCorrectionRequest
     * const attendanceCorrectionRequest = await prisma.attendanceCorrectionRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceCorrectionRequestFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AttendanceCorrectionRequestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AttendanceCorrectionRequestClient<
      $Result.GetResult<
        Prisma.$AttendanceCorrectionRequestPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AttendanceCorrectionRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCorrectionRequestFindFirstArgs} args - Arguments to find a AttendanceCorrectionRequest
     * @example
     * // Get one AttendanceCorrectionRequest
     * const attendanceCorrectionRequest = await prisma.attendanceCorrectionRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceCorrectionRequestFindFirstArgs>(
      args?: SelectSubset<T, AttendanceCorrectionRequestFindFirstArgs<ExtArgs>>
    ): Prisma__AttendanceCorrectionRequestClient<
      $Result.GetResult<
        Prisma.$AttendanceCorrectionRequestPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AttendanceCorrectionRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCorrectionRequestFindFirstOrThrowArgs} args - Arguments to find a AttendanceCorrectionRequest
     * @example
     * // Get one AttendanceCorrectionRequest
     * const attendanceCorrectionRequest = await prisma.attendanceCorrectionRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceCorrectionRequestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AttendanceCorrectionRequestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AttendanceCorrectionRequestClient<
      $Result.GetResult<
        Prisma.$AttendanceCorrectionRequestPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AttendanceCorrectionRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCorrectionRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceCorrectionRequests
     * const attendanceCorrectionRequests = await prisma.attendanceCorrectionRequest.findMany()
     *
     * // Get first 10 AttendanceCorrectionRequests
     * const attendanceCorrectionRequests = await prisma.attendanceCorrectionRequest.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const attendanceCorrectionRequestWithIdOnly = await prisma.attendanceCorrectionRequest.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AttendanceCorrectionRequestFindManyArgs>(
      args?: SelectSubset<T, AttendanceCorrectionRequestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AttendanceCorrectionRequestPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AttendanceCorrectionRequest.
     * @param {AttendanceCorrectionRequestCreateArgs} args - Arguments to create a AttendanceCorrectionRequest.
     * @example
     * // Create one AttendanceCorrectionRequest
     * const AttendanceCorrectionRequest = await prisma.attendanceCorrectionRequest.create({
     *   data: {
     *     // ... data to create a AttendanceCorrectionRequest
     *   }
     * })
     *
     */
    create<T extends AttendanceCorrectionRequestCreateArgs>(
      args: SelectSubset<T, AttendanceCorrectionRequestCreateArgs<ExtArgs>>
    ): Prisma__AttendanceCorrectionRequestClient<
      $Result.GetResult<
        Prisma.$AttendanceCorrectionRequestPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AttendanceCorrectionRequests.
     * @param {AttendanceCorrectionRequestCreateManyArgs} args - Arguments to create many AttendanceCorrectionRequests.
     * @example
     * // Create many AttendanceCorrectionRequests
     * const attendanceCorrectionRequest = await prisma.attendanceCorrectionRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AttendanceCorrectionRequestCreateManyArgs>(
      args?: SelectSubset<T, AttendanceCorrectionRequestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a AttendanceCorrectionRequest.
     * @param {AttendanceCorrectionRequestDeleteArgs} args - Arguments to delete one AttendanceCorrectionRequest.
     * @example
     * // Delete one AttendanceCorrectionRequest
     * const AttendanceCorrectionRequest = await prisma.attendanceCorrectionRequest.delete({
     *   where: {
     *     // ... filter to delete one AttendanceCorrectionRequest
     *   }
     * })
     *
     */
    delete<T extends AttendanceCorrectionRequestDeleteArgs>(
      args: SelectSubset<T, AttendanceCorrectionRequestDeleteArgs<ExtArgs>>
    ): Prisma__AttendanceCorrectionRequestClient<
      $Result.GetResult<
        Prisma.$AttendanceCorrectionRequestPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AttendanceCorrectionRequest.
     * @param {AttendanceCorrectionRequestUpdateArgs} args - Arguments to update one AttendanceCorrectionRequest.
     * @example
     * // Update one AttendanceCorrectionRequest
     * const attendanceCorrectionRequest = await prisma.attendanceCorrectionRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AttendanceCorrectionRequestUpdateArgs>(
      args: SelectSubset<T, AttendanceCorrectionRequestUpdateArgs<ExtArgs>>
    ): Prisma__AttendanceCorrectionRequestClient<
      $Result.GetResult<
        Prisma.$AttendanceCorrectionRequestPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AttendanceCorrectionRequests.
     * @param {AttendanceCorrectionRequestDeleteManyArgs} args - Arguments to filter AttendanceCorrectionRequests to delete.
     * @example
     * // Delete a few AttendanceCorrectionRequests
     * const { count } = await prisma.attendanceCorrectionRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AttendanceCorrectionRequestDeleteManyArgs>(
      args?: SelectSubset<T, AttendanceCorrectionRequestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AttendanceCorrectionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCorrectionRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceCorrectionRequests
     * const attendanceCorrectionRequest = await prisma.attendanceCorrectionRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AttendanceCorrectionRequestUpdateManyArgs>(
      args: SelectSubset<T, AttendanceCorrectionRequestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one AttendanceCorrectionRequest.
     * @param {AttendanceCorrectionRequestUpsertArgs} args - Arguments to update or create a AttendanceCorrectionRequest.
     * @example
     * // Update or create a AttendanceCorrectionRequest
     * const attendanceCorrectionRequest = await prisma.attendanceCorrectionRequest.upsert({
     *   create: {
     *     // ... data to create a AttendanceCorrectionRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceCorrectionRequest we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceCorrectionRequestUpsertArgs>(
      args: SelectSubset<T, AttendanceCorrectionRequestUpsertArgs<ExtArgs>>
    ): Prisma__AttendanceCorrectionRequestClient<
      $Result.GetResult<
        Prisma.$AttendanceCorrectionRequestPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AttendanceCorrectionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCorrectionRequestCountArgs} args - Arguments to filter AttendanceCorrectionRequests to count.
     * @example
     * // Count the number of AttendanceCorrectionRequests
     * const count = await prisma.attendanceCorrectionRequest.count({
     *   where: {
     *     // ... the filter for the AttendanceCorrectionRequests we want to count
     *   }
     * })
     **/
    count<T extends AttendanceCorrectionRequestCountArgs>(
      args?: Subset<T, AttendanceCorrectionRequestCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCorrectionRequestCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AttendanceCorrectionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCorrectionRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AttendanceCorrectionRequestAggregateArgs>(
      args: Subset<T, AttendanceCorrectionRequestAggregateArgs>
    ): Prisma.PrismaPromise<GetAttendanceCorrectionRequestAggregateType<T>>;

    /**
     * Group by AttendanceCorrectionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCorrectionRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AttendanceCorrectionRequestGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceCorrectionRequestGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceCorrectionRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AttendanceCorrectionRequestGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAttendanceCorrectionRequestGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AttendanceCorrectionRequest model
     */
    readonly fields: AttendanceCorrectionRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceCorrectionRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceCorrectionRequestClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    attendance<T extends AttendanceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AttendanceDefaultArgs<ExtArgs>>
    ): Prisma__AttendanceClient<
      | $Result.GetResult<
          Prisma.$AttendancePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AttendanceCorrectionRequest model
   */
  interface AttendanceCorrectionRequestFieldRefs {
    readonly id: FieldRef<'AttendanceCorrectionRequest', 'String'>;
    readonly attendanceId: FieldRef<'AttendanceCorrectionRequest', 'String'>;
    readonly userId: FieldRef<'AttendanceCorrectionRequest', 'String'>;
    readonly originalCheckInTime: FieldRef<'AttendanceCorrectionRequest', 'DateTime'>;
    readonly originalCheckOutTime: FieldRef<'AttendanceCorrectionRequest', 'DateTime'>;
    readonly requestedCheckInTime: FieldRef<'AttendanceCorrectionRequest', 'DateTime'>;
    readonly requestedCheckOutTime: FieldRef<'AttendanceCorrectionRequest', 'DateTime'>;
    readonly reason: FieldRef<'AttendanceCorrectionRequest', 'String'>;
    readonly status: FieldRef<'AttendanceCorrectionRequest', 'String'>;
    readonly reviewedBy: FieldRef<'AttendanceCorrectionRequest', 'String'>;
    readonly reviewedAt: FieldRef<'AttendanceCorrectionRequest', 'DateTime'>;
    readonly reviewNotes: FieldRef<'AttendanceCorrectionRequest', 'String'>;
    readonly createdAt: FieldRef<'AttendanceCorrectionRequest', 'DateTime'>;
    readonly updatedAt: FieldRef<'AttendanceCorrectionRequest', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * AttendanceCorrectionRequest findUnique
   */
  export type AttendanceCorrectionRequestFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceCorrectionRequest
     */
    select?: AttendanceCorrectionRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceCorrectionRequest
     */
    omit?: AttendanceCorrectionRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCorrectionRequestInclude<ExtArgs> | null;
    /**
     * Filter, which AttendanceCorrectionRequest to fetch.
     */
    where: AttendanceCorrectionRequestWhereUniqueInput;
  };

  /**
   * AttendanceCorrectionRequest findUniqueOrThrow
   */
  export type AttendanceCorrectionRequestFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceCorrectionRequest
     */
    select?: AttendanceCorrectionRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceCorrectionRequest
     */
    omit?: AttendanceCorrectionRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCorrectionRequestInclude<ExtArgs> | null;
    /**
     * Filter, which AttendanceCorrectionRequest to fetch.
     */
    where: AttendanceCorrectionRequestWhereUniqueInput;
  };

  /**
   * AttendanceCorrectionRequest findFirst
   */
  export type AttendanceCorrectionRequestFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceCorrectionRequest
     */
    select?: AttendanceCorrectionRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceCorrectionRequest
     */
    omit?: AttendanceCorrectionRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCorrectionRequestInclude<ExtArgs> | null;
    /**
     * Filter, which AttendanceCorrectionRequest to fetch.
     */
    where?: AttendanceCorrectionRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AttendanceCorrectionRequests to fetch.
     */
    orderBy?:
      | AttendanceCorrectionRequestOrderByWithRelationInput
      | AttendanceCorrectionRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AttendanceCorrectionRequests.
     */
    cursor?: AttendanceCorrectionRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AttendanceCorrectionRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AttendanceCorrectionRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AttendanceCorrectionRequests.
     */
    distinct?:
      | AttendanceCorrectionRequestScalarFieldEnum
      | AttendanceCorrectionRequestScalarFieldEnum[];
  };

  /**
   * AttendanceCorrectionRequest findFirstOrThrow
   */
  export type AttendanceCorrectionRequestFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceCorrectionRequest
     */
    select?: AttendanceCorrectionRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceCorrectionRequest
     */
    omit?: AttendanceCorrectionRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCorrectionRequestInclude<ExtArgs> | null;
    /**
     * Filter, which AttendanceCorrectionRequest to fetch.
     */
    where?: AttendanceCorrectionRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AttendanceCorrectionRequests to fetch.
     */
    orderBy?:
      | AttendanceCorrectionRequestOrderByWithRelationInput
      | AttendanceCorrectionRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AttendanceCorrectionRequests.
     */
    cursor?: AttendanceCorrectionRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AttendanceCorrectionRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AttendanceCorrectionRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AttendanceCorrectionRequests.
     */
    distinct?:
      | AttendanceCorrectionRequestScalarFieldEnum
      | AttendanceCorrectionRequestScalarFieldEnum[];
  };

  /**
   * AttendanceCorrectionRequest findMany
   */
  export type AttendanceCorrectionRequestFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceCorrectionRequest
     */
    select?: AttendanceCorrectionRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceCorrectionRequest
     */
    omit?: AttendanceCorrectionRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCorrectionRequestInclude<ExtArgs> | null;
    /**
     * Filter, which AttendanceCorrectionRequests to fetch.
     */
    where?: AttendanceCorrectionRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AttendanceCorrectionRequests to fetch.
     */
    orderBy?:
      | AttendanceCorrectionRequestOrderByWithRelationInput
      | AttendanceCorrectionRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AttendanceCorrectionRequests.
     */
    cursor?: AttendanceCorrectionRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AttendanceCorrectionRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AttendanceCorrectionRequests.
     */
    skip?: number;
    distinct?:
      | AttendanceCorrectionRequestScalarFieldEnum
      | AttendanceCorrectionRequestScalarFieldEnum[];
  };

  /**
   * AttendanceCorrectionRequest create
   */
  export type AttendanceCorrectionRequestCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceCorrectionRequest
     */
    select?: AttendanceCorrectionRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceCorrectionRequest
     */
    omit?: AttendanceCorrectionRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCorrectionRequestInclude<ExtArgs> | null;
    /**
     * The data needed to create a AttendanceCorrectionRequest.
     */
    data: XOR<
      AttendanceCorrectionRequestCreateInput,
      AttendanceCorrectionRequestUncheckedCreateInput
    >;
  };

  /**
   * AttendanceCorrectionRequest createMany
   */
  export type AttendanceCorrectionRequestCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AttendanceCorrectionRequests.
     */
    data: AttendanceCorrectionRequestCreateManyInput | AttendanceCorrectionRequestCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AttendanceCorrectionRequest update
   */
  export type AttendanceCorrectionRequestUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceCorrectionRequest
     */
    select?: AttendanceCorrectionRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceCorrectionRequest
     */
    omit?: AttendanceCorrectionRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCorrectionRequestInclude<ExtArgs> | null;
    /**
     * The data needed to update a AttendanceCorrectionRequest.
     */
    data: XOR<
      AttendanceCorrectionRequestUpdateInput,
      AttendanceCorrectionRequestUncheckedUpdateInput
    >;
    /**
     * Choose, which AttendanceCorrectionRequest to update.
     */
    where: AttendanceCorrectionRequestWhereUniqueInput;
  };

  /**
   * AttendanceCorrectionRequest updateMany
   */
  export type AttendanceCorrectionRequestUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AttendanceCorrectionRequests.
     */
    data: XOR<
      AttendanceCorrectionRequestUpdateManyMutationInput,
      AttendanceCorrectionRequestUncheckedUpdateManyInput
    >;
    /**
     * Filter which AttendanceCorrectionRequests to update
     */
    where?: AttendanceCorrectionRequestWhereInput;
    /**
     * Limit how many AttendanceCorrectionRequests to update.
     */
    limit?: number;
  };

  /**
   * AttendanceCorrectionRequest upsert
   */
  export type AttendanceCorrectionRequestUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceCorrectionRequest
     */
    select?: AttendanceCorrectionRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceCorrectionRequest
     */
    omit?: AttendanceCorrectionRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCorrectionRequestInclude<ExtArgs> | null;
    /**
     * The filter to search for the AttendanceCorrectionRequest to update in case it exists.
     */
    where: AttendanceCorrectionRequestWhereUniqueInput;
    /**
     * In case the AttendanceCorrectionRequest found by the `where` argument doesn't exist, create a new AttendanceCorrectionRequest with this data.
     */
    create: XOR<
      AttendanceCorrectionRequestCreateInput,
      AttendanceCorrectionRequestUncheckedCreateInput
    >;
    /**
     * In case the AttendanceCorrectionRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      AttendanceCorrectionRequestUpdateInput,
      AttendanceCorrectionRequestUncheckedUpdateInput
    >;
  };

  /**
   * AttendanceCorrectionRequest delete
   */
  export type AttendanceCorrectionRequestDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceCorrectionRequest
     */
    select?: AttendanceCorrectionRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceCorrectionRequest
     */
    omit?: AttendanceCorrectionRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCorrectionRequestInclude<ExtArgs> | null;
    /**
     * Filter which AttendanceCorrectionRequest to delete.
     */
    where: AttendanceCorrectionRequestWhereUniqueInput;
  };

  /**
   * AttendanceCorrectionRequest deleteMany
   */
  export type AttendanceCorrectionRequestDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AttendanceCorrectionRequests to delete
     */
    where?: AttendanceCorrectionRequestWhereInput;
    /**
     * Limit how many AttendanceCorrectionRequests to delete.
     */
    limit?: number;
  };

  /**
   * AttendanceCorrectionRequest without action
   */
  export type AttendanceCorrectionRequestDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AttendanceCorrectionRequest
     */
    select?: AttendanceCorrectionRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AttendanceCorrectionRequest
     */
    omit?: AttendanceCorrectionRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCorrectionRequestInclude<ExtArgs> | null;
  };

  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null;
    _min: CommentMinAggregateOutputType | null;
    _max: CommentMaxAggregateOutputType | null;
  };

  export type CommentMinAggregateOutputType = {
    id: string | null;
    content: string | null;
    taskId: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CommentMaxAggregateOutputType = {
    id: string | null;
    content: string | null;
    taskId: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CommentCountAggregateOutputType = {
    id: number;
    content: number;
    taskId: number;
    userId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type CommentMinAggregateInputType = {
    id?: true;
    content?: true;
    taskId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CommentMaxAggregateInputType = {
    id?: true;
    content?: true;
    taskId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CommentCountAggregateInputType = {
    id?: true;
    content?: true;
    taskId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type CommentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Comments
     **/
    _count?: true | CommentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CommentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CommentMaxAggregateInputType;
  };

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
    [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>;
  };

  export type CommentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[];
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum;
    having?: CommentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CommentCountAggregateInputType | true;
    _min?: CommentMinAggregateInputType;
    _max?: CommentMaxAggregateInputType;
  };

  export type CommentGroupByOutputType = {
    id: string;
    content: string;
    taskId: string;
    userId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: CommentCountAggregateOutputType | null;
    _min: CommentMinAggregateOutputType | null;
    _max: CommentMaxAggregateOutputType | null;
  };

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> & {
        [P in keyof T & keyof CommentGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
          : GetScalarType<T[P], CommentGroupByOutputType[P]>;
      }
    >
  >;

  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        content?: boolean;
        taskId?: boolean;
        userId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        task?: boolean | TaskDefaultArgs<ExtArgs>;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['comment']
    >;

  export type CommentSelectScalar = {
    id?: boolean;
    content?: boolean;
    taskId?: boolean;
    userId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'id' | 'content' | 'taskId' | 'userId' | 'createdAt' | 'updatedAt',
      ExtArgs['result']['comment']
    >;
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Comment';
      objects: {
        task: Prisma.$TaskPayload<ExtArgs>;
        user: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          content: string;
          taskId: string;
          userId: string;
          createdAt: Date;
          updatedAt: Date;
        },
        ExtArgs['result']['comment']
      >;
      composites: {};
    };

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> =
    $Result.GetResult<Prisma.$CommentPayload, S>;

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    CommentFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: CommentCountAggregateInputType | true;
  };

  export interface CommentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment']; meta: { name: 'Comment' } };
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     *
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CommentFindManyArgs>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     *
     */
    create<T extends CommentCreateArgs>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CommentCreateManyArgs>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     *
     */
    delete<T extends CommentDeleteArgs>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CommentUpdateArgs>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CommentDeleteManyArgs>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CommentUpdateManyArgs>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
     **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CommentAggregateArgs>(
      args: Subset<T, CommentAggregateArgs>
    ): Prisma.PrismaPromise<GetCommentAggregateType<T>>;

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Comment model
     */
    readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TaskDefaultArgs<ExtArgs>>
    ): Prisma__TaskClient<
      | $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<'Comment', 'String'>;
    readonly content: FieldRef<'Comment', 'String'>;
    readonly taskId: FieldRef<'Comment', 'String'>;
    readonly userId: FieldRef<'Comment', 'String'>;
    readonly createdAt: FieldRef<'Comment', 'DateTime'>;
    readonly updatedAt: FieldRef<'Comment', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput;
  };

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput;
  };

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number;
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * Comment create
   */
  export type CommentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>;
  };

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Comment update
   */
  export type CommentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>;
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput;
  };

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>;
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput;
    /**
     * Limit how many Comments to update.
     */
    limit?: number;
  };

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput;
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>;
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>;
  };

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput;
  };

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput;
    /**
     * Limit how many Comments to delete.
     */
    limit?: number;
  };

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
  };

  /**
   * Model TaskAttachment
   */

  export type AggregateTaskAttachment = {
    _count: TaskAttachmentCountAggregateOutputType | null;
    _avg: TaskAttachmentAvgAggregateOutputType | null;
    _sum: TaskAttachmentSumAggregateOutputType | null;
    _min: TaskAttachmentMinAggregateOutputType | null;
    _max: TaskAttachmentMaxAggregateOutputType | null;
  };

  export type TaskAttachmentAvgAggregateOutputType = {
    fileSize: number | null;
  };

  export type TaskAttachmentSumAggregateOutputType = {
    fileSize: number | null;
  };

  export type TaskAttachmentMinAggregateOutputType = {
    id: string | null;
    filename: string | null;
    fileUrl: string | null;
    fileSize: number | null;
    fileType: string | null;
    taskId: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TaskAttachmentMaxAggregateOutputType = {
    id: string | null;
    filename: string | null;
    fileUrl: string | null;
    fileSize: number | null;
    fileType: string | null;
    taskId: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TaskAttachmentCountAggregateOutputType = {
    id: number;
    filename: number;
    fileUrl: number;
    fileSize: number;
    fileType: number;
    taskId: number;
    userId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type TaskAttachmentAvgAggregateInputType = {
    fileSize?: true;
  };

  export type TaskAttachmentSumAggregateInputType = {
    fileSize?: true;
  };

  export type TaskAttachmentMinAggregateInputType = {
    id?: true;
    filename?: true;
    fileUrl?: true;
    fileSize?: true;
    fileType?: true;
    taskId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TaskAttachmentMaxAggregateInputType = {
    id?: true;
    filename?: true;
    fileUrl?: true;
    fileSize?: true;
    fileType?: true;
    taskId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TaskAttachmentCountAggregateInputType = {
    id?: true;
    filename?: true;
    fileUrl?: true;
    fileSize?: true;
    fileType?: true;
    taskId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type TaskAttachmentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TaskAttachment to aggregate.
     */
    where?: TaskAttachmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TaskAttachmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TaskAttachments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TaskAttachments
     **/
    _count?: true | TaskAttachmentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: TaskAttachmentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: TaskAttachmentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TaskAttachmentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TaskAttachmentMaxAggregateInputType;
  };

  export type GetTaskAttachmentAggregateType<T extends TaskAttachmentAggregateArgs> = {
    [P in keyof T & keyof AggregateTaskAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAttachment[P]>
      : GetScalarType<T[P], AggregateTaskAttachment[P]>;
  };

  export type TaskAttachmentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TaskAttachmentWhereInput;
    orderBy?:
      | TaskAttachmentOrderByWithAggregationInput
      | TaskAttachmentOrderByWithAggregationInput[];
    by: TaskAttachmentScalarFieldEnum[] | TaskAttachmentScalarFieldEnum;
    having?: TaskAttachmentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TaskAttachmentCountAggregateInputType | true;
    _avg?: TaskAttachmentAvgAggregateInputType;
    _sum?: TaskAttachmentSumAggregateInputType;
    _min?: TaskAttachmentMinAggregateInputType;
    _max?: TaskAttachmentMaxAggregateInputType;
  };

  export type TaskAttachmentGroupByOutputType = {
    id: string;
    filename: string;
    fileUrl: string;
    fileSize: number;
    fileType: string;
    taskId: string;
    userId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: TaskAttachmentCountAggregateOutputType | null;
    _avg: TaskAttachmentAvgAggregateOutputType | null;
    _sum: TaskAttachmentSumAggregateOutputType | null;
    _min: TaskAttachmentMinAggregateOutputType | null;
    _max: TaskAttachmentMaxAggregateOutputType | null;
  };

  type GetTaskAttachmentGroupByPayload<T extends TaskAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAttachmentGroupByOutputType, T['by']> & {
        [P in keyof T & keyof TaskAttachmentGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TaskAttachmentGroupByOutputType[P]>
          : GetScalarType<T[P], TaskAttachmentGroupByOutputType[P]>;
      }
    >
  >;

  export type TaskAttachmentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      filename?: boolean;
      fileUrl?: boolean;
      fileSize?: boolean;
      fileType?: boolean;
      taskId?: boolean;
      userId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      task?: boolean | TaskDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['taskAttachment']
  >;

  export type TaskAttachmentSelectScalar = {
    id?: boolean;
    filename?: boolean;
    fileUrl?: boolean;
    fileSize?: boolean;
    fileType?: boolean;
    taskId?: boolean;
    userId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type TaskAttachmentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'filename'
    | 'fileUrl'
    | 'fileSize'
    | 'fileType'
    | 'taskId'
    | 'userId'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['taskAttachment']
  >;
  export type TaskAttachmentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    task?: boolean | TaskDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $TaskAttachmentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'TaskAttachment';
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        filename: string;
        fileUrl: string;
        fileSize: number;
        fileType: string;
        taskId: string;
        userId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['taskAttachment']
    >;
    composites: {};
  };

  type TaskAttachmentGetPayload<S extends boolean | null | undefined | TaskAttachmentDefaultArgs> =
    $Result.GetResult<Prisma.$TaskAttachmentPayload, S>;

  type TaskAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskAttachmentCountAggregateInputType | true;
    };

  export interface TaskAttachmentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['TaskAttachment'];
      meta: { name: 'TaskAttachment' };
    };
    /**
     * Find zero or one TaskAttachment that matches the filter.
     * @param {TaskAttachmentFindUniqueArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAttachmentFindUniqueArgs>(
      args: SelectSubset<T, TaskAttachmentFindUniqueArgs<ExtArgs>>
    ): Prisma__TaskAttachmentClient<
      $Result.GetResult<
        Prisma.$TaskAttachmentPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one TaskAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskAttachmentFindUniqueOrThrowArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAttachmentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TaskAttachmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TaskAttachmentClient<
      $Result.GetResult<
        Prisma.$TaskAttachmentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TaskAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentFindFirstArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAttachmentFindFirstArgs>(
      args?: SelectSubset<T, TaskAttachmentFindFirstArgs<ExtArgs>>
    ): Prisma__TaskAttachmentClient<
      $Result.GetResult<
        Prisma.$TaskAttachmentPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TaskAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentFindFirstOrThrowArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAttachmentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TaskAttachmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TaskAttachmentClient<
      $Result.GetResult<
        Prisma.$TaskAttachmentPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more TaskAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAttachments
     * const taskAttachments = await prisma.taskAttachment.findMany()
     *
     * // Get first 10 TaskAttachments
     * const taskAttachments = await prisma.taskAttachment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const taskAttachmentWithIdOnly = await prisma.taskAttachment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TaskAttachmentFindManyArgs>(
      args?: SelectSubset<T, TaskAttachmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a TaskAttachment.
     * @param {TaskAttachmentCreateArgs} args - Arguments to create a TaskAttachment.
     * @example
     * // Create one TaskAttachment
     * const TaskAttachment = await prisma.taskAttachment.create({
     *   data: {
     *     // ... data to create a TaskAttachment
     *   }
     * })
     *
     */
    create<T extends TaskAttachmentCreateArgs>(
      args: SelectSubset<T, TaskAttachmentCreateArgs<ExtArgs>>
    ): Prisma__TaskAttachmentClient<
      $Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many TaskAttachments.
     * @param {TaskAttachmentCreateManyArgs} args - Arguments to create many TaskAttachments.
     * @example
     * // Create many TaskAttachments
     * const taskAttachment = await prisma.taskAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TaskAttachmentCreateManyArgs>(
      args?: SelectSubset<T, TaskAttachmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a TaskAttachment.
     * @param {TaskAttachmentDeleteArgs} args - Arguments to delete one TaskAttachment.
     * @example
     * // Delete one TaskAttachment
     * const TaskAttachment = await prisma.taskAttachment.delete({
     *   where: {
     *     // ... filter to delete one TaskAttachment
     *   }
     * })
     *
     */
    delete<T extends TaskAttachmentDeleteArgs>(
      args: SelectSubset<T, TaskAttachmentDeleteArgs<ExtArgs>>
    ): Prisma__TaskAttachmentClient<
      $Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one TaskAttachment.
     * @param {TaskAttachmentUpdateArgs} args - Arguments to update one TaskAttachment.
     * @example
     * // Update one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TaskAttachmentUpdateArgs>(
      args: SelectSubset<T, TaskAttachmentUpdateArgs<ExtArgs>>
    ): Prisma__TaskAttachmentClient<
      $Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more TaskAttachments.
     * @param {TaskAttachmentDeleteManyArgs} args - Arguments to filter TaskAttachments to delete.
     * @example
     * // Delete a few TaskAttachments
     * const { count } = await prisma.taskAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TaskAttachmentDeleteManyArgs>(
      args?: SelectSubset<T, TaskAttachmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TaskAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAttachments
     * const taskAttachment = await prisma.taskAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TaskAttachmentUpdateManyArgs>(
      args: SelectSubset<T, TaskAttachmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one TaskAttachment.
     * @param {TaskAttachmentUpsertArgs} args - Arguments to update or create a TaskAttachment.
     * @example
     * // Update or create a TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.upsert({
     *   create: {
     *     // ... data to create a TaskAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAttachment we want to update
     *   }
     * })
     */
    upsert<T extends TaskAttachmentUpsertArgs>(
      args: SelectSubset<T, TaskAttachmentUpsertArgs<ExtArgs>>
    ): Prisma__TaskAttachmentClient<
      $Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of TaskAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentCountArgs} args - Arguments to filter TaskAttachments to count.
     * @example
     * // Count the number of TaskAttachments
     * const count = await prisma.taskAttachment.count({
     *   where: {
     *     // ... the filter for the TaskAttachments we want to count
     *   }
     * })
     **/
    count<T extends TaskAttachmentCountArgs>(
      args?: Subset<T, TaskAttachmentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAttachmentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a TaskAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TaskAttachmentAggregateArgs>(
      args: Subset<T, TaskAttachmentAggregateArgs>
    ): Prisma.PrismaPromise<GetTaskAttachmentAggregateType<T>>;

    /**
     * Group by TaskAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TaskAttachmentGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: TaskAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TaskAttachmentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetTaskAttachmentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the TaskAttachment model
     */
    readonly fields: TaskAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAttachmentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TaskDefaultArgs<ExtArgs>>
    ): Prisma__TaskClient<
      | $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the TaskAttachment model
   */
  interface TaskAttachmentFieldRefs {
    readonly id: FieldRef<'TaskAttachment', 'String'>;
    readonly filename: FieldRef<'TaskAttachment', 'String'>;
    readonly fileUrl: FieldRef<'TaskAttachment', 'String'>;
    readonly fileSize: FieldRef<'TaskAttachment', 'Int'>;
    readonly fileType: FieldRef<'TaskAttachment', 'String'>;
    readonly taskId: FieldRef<'TaskAttachment', 'String'>;
    readonly userId: FieldRef<'TaskAttachment', 'String'>;
    readonly createdAt: FieldRef<'TaskAttachment', 'DateTime'>;
    readonly updatedAt: FieldRef<'TaskAttachment', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * TaskAttachment findUnique
   */
  export type TaskAttachmentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null;
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where: TaskAttachmentWhereUniqueInput;
  };

  /**
   * TaskAttachment findUniqueOrThrow
   */
  export type TaskAttachmentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null;
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where: TaskAttachmentWhereUniqueInput;
  };

  /**
   * TaskAttachment findFirst
   */
  export type TaskAttachmentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null;
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where?: TaskAttachmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TaskAttachments.
     */
    cursor?: TaskAttachmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TaskAttachments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TaskAttachments.
     */
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[];
  };

  /**
   * TaskAttachment findFirstOrThrow
   */
  export type TaskAttachmentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null;
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where?: TaskAttachmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TaskAttachments.
     */
    cursor?: TaskAttachmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TaskAttachments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TaskAttachments.
     */
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[];
  };

  /**
   * TaskAttachment findMany
   */
  export type TaskAttachmentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null;
    /**
     * Filter, which TaskAttachments to fetch.
     */
    where?: TaskAttachmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TaskAttachments.
     */
    cursor?: TaskAttachmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TaskAttachments.
     */
    skip?: number;
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[];
  };

  /**
   * TaskAttachment create
   */
  export type TaskAttachmentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null;
    /**
     * The data needed to create a TaskAttachment.
     */
    data: XOR<TaskAttachmentCreateInput, TaskAttachmentUncheckedCreateInput>;
  };

  /**
   * TaskAttachment createMany
   */
  export type TaskAttachmentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many TaskAttachments.
     */
    data: TaskAttachmentCreateManyInput | TaskAttachmentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * TaskAttachment update
   */
  export type TaskAttachmentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null;
    /**
     * The data needed to update a TaskAttachment.
     */
    data: XOR<TaskAttachmentUpdateInput, TaskAttachmentUncheckedUpdateInput>;
    /**
     * Choose, which TaskAttachment to update.
     */
    where: TaskAttachmentWhereUniqueInput;
  };

  /**
   * TaskAttachment updateMany
   */
  export type TaskAttachmentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update TaskAttachments.
     */
    data: XOR<TaskAttachmentUpdateManyMutationInput, TaskAttachmentUncheckedUpdateManyInput>;
    /**
     * Filter which TaskAttachments to update
     */
    where?: TaskAttachmentWhereInput;
    /**
     * Limit how many TaskAttachments to update.
     */
    limit?: number;
  };

  /**
   * TaskAttachment upsert
   */
  export type TaskAttachmentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null;
    /**
     * The filter to search for the TaskAttachment to update in case it exists.
     */
    where: TaskAttachmentWhereUniqueInput;
    /**
     * In case the TaskAttachment found by the `where` argument doesn't exist, create a new TaskAttachment with this data.
     */
    create: XOR<TaskAttachmentCreateInput, TaskAttachmentUncheckedCreateInput>;
    /**
     * In case the TaskAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAttachmentUpdateInput, TaskAttachmentUncheckedUpdateInput>;
  };

  /**
   * TaskAttachment delete
   */
  export type TaskAttachmentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null;
    /**
     * Filter which TaskAttachment to delete.
     */
    where: TaskAttachmentWhereUniqueInput;
  };

  /**
   * TaskAttachment deleteMany
   */
  export type TaskAttachmentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TaskAttachments to delete
     */
    where?: TaskAttachmentWhereInput;
    /**
     * Limit how many TaskAttachments to delete.
     */
    limit?: number;
  };

  /**
   * TaskAttachment without action
   */
  export type TaskAttachmentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null;
  };

  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  export type RoleMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    color: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RoleMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    color: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RoleCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    color: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type RoleMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    color?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RoleMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    color?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RoleCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    color?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type RoleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Roles
     **/
    _count?: true | RoleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RoleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RoleMaxAggregateInputType;
  };

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
    [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>;
  };

  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: RoleWhereInput;
      orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[];
      by: RoleScalarFieldEnum[] | RoleScalarFieldEnum;
      having?: RoleScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: RoleCountAggregateInputType | true;
      _min?: RoleMinAggregateInputType;
      _max?: RoleMaxAggregateInputType;
    };

  export type RoleGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    color: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: RoleCountAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> & {
        [P in keyof T & keyof RoleGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
          : GetScalarType<T[P], RoleGroupByOutputType[P]>;
      }
    >
  >;

  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        description?: boolean;
        color?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        permissions?: boolean | Role$permissionsArgs<ExtArgs>;
        _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['role']
    >;

  export type RoleSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    color?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'id' | 'name' | 'description' | 'color' | 'createdAt' | 'updatedAt',
      ExtArgs['result']['role']
    >;
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | Role$permissionsArgs<ExtArgs>;
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Role';
    objects: {
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        description: string | null;
        color: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['role']
    >;
    composites: {};
  };

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<
    Prisma.$RolePayload,
    S
  >;

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    RoleFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: RoleCountAggregateInputType | true;
  };

  export interface RoleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role']; meta: { name: 'Role' } };
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(
      args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(
      args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     *
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     *
     */
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     *
     */
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
     **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RoleAggregateArgs>(
      args: Subset<T, RoleAggregateArgs>
    ): Prisma.PrismaPromise<GetRoleAggregateType<T>>;

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Role model
     */
    readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Role$permissionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<'Role', 'String'>;
    readonly name: FieldRef<'Role', 'String'>;
    readonly description: FieldRef<'Role', 'String'>;
    readonly color: FieldRef<'Role', 'String'>;
    readonly createdAt: FieldRef<'Role', 'DateTime'>;
    readonly updatedAt: FieldRef<'Role', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Role
       */
      select?: RoleSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Role
       */
      omit?: RoleOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: RoleInclude<ExtArgs> | null;
      /**
       * Filter, which Roles to fetch.
       */
      where?: RoleWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Roles to fetch.
       */
      orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Roles.
       */
      cursor?: RoleWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Roles from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Roles.
       */
      skip?: number;
      distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
    };

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
  };

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>;
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput;
    /**
     * Limit how many Roles to update.
     */
    limit?: number;
  };

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput;
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
  };

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput;
    /**
     * Limit how many Roles to delete.
     */
    limit?: number;
  };

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null;
    where?: RolePermissionWhereInput;
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[];
    cursor?: RolePermissionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[];
  };

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Role
       */
      select?: RoleSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Role
       */
      omit?: RoleOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: RoleInclude<ExtArgs> | null;
    };

  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null;
    _min: PermissionMinAggregateOutputType | null;
    _max: PermissionMaxAggregateOutputType | null;
  };

  export type PermissionMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    category: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PermissionMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    category: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PermissionCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    category: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type PermissionMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    category?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PermissionMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    category?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PermissionCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    category?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type PermissionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Permissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Permissions
     **/
    _count?: true | PermissionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PermissionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PermissionMaxAggregateInputType;
  };

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
    [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>;
  };

  export type PermissionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[];
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum;
    having?: PermissionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PermissionCountAggregateInputType | true;
    _min?: PermissionMinAggregateInputType;
    _max?: PermissionMaxAggregateInputType;
  };

  export type PermissionGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    category: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: PermissionCountAggregateOutputType | null;
    _min: PermissionMinAggregateOutputType | null;
    _max: PermissionMaxAggregateOutputType | null;
  };

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> & {
        [P in keyof T & keyof PermissionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
          : GetScalarType<T[P], PermissionGroupByOutputType[P]>;
      }
    >
  >;

  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        description?: boolean;
        category?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        roles?: boolean | Permission$rolesArgs<ExtArgs>;
        _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['permission']
    >;

  export type PermissionSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    category?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'id' | 'name' | 'description' | 'category' | 'createdAt' | 'updatedAt',
      ExtArgs['result']['permission']
    >;
  export type PermissionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>;
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $PermissionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Permission';
    objects: {
      roles: Prisma.$RolePermissionPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        description: string | null;
        category: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['permission']
    >;
    composites: {};
  };

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> =
    $Result.GetResult<Prisma.$PermissionPayload, S>;

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true;
    };

  export interface PermissionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Permission'];
      meta: { name: 'Permission' };
    };
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(
      args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<
        Prisma.$PermissionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<
        Prisma.$PermissionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(
      args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<
        Prisma.$PermissionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<
        Prisma.$PermissionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     *
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PermissionFindManyArgs>(
      args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     *
     */
    create<T extends PermissionCreateArgs>(
      args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PermissionCreateManyArgs>(
      args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     *
     */
    delete<T extends PermissionDeleteArgs>(
      args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PermissionUpdateArgs>(
      args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PermissionDeleteManyArgs>(
      args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PermissionUpdateManyArgs>(
      args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(
      args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
     **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PermissionAggregateArgs>(
      args: Subset<T, PermissionAggregateArgs>
    ): Prisma.PrismaPromise<GetPermissionAggregateType<T>>;

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Permission model
     */
    readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(
      args?: Subset<T, Permission$rolesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<'Permission', 'String'>;
    readonly name: FieldRef<'Permission', 'String'>;
    readonly description: FieldRef<'Permission', 'String'>;
    readonly category: FieldRef<'Permission', 'String'>;
    readonly createdAt: FieldRef<'Permission', 'DateTime'>;
    readonly updatedAt: FieldRef<'Permission', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput;
  };

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput;
  };

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Permissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[];
  };

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Permissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[];
  };

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Permissions.
     */
    skip?: number;
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[];
  };

  /**
   * Permission create
   */
  export type PermissionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>;
  };

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>;
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput;
  };

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>;
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput;
    /**
     * Limit how many Permissions to update.
     */
    limit?: number;
  };

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput;
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>;
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>;
  };

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput;
  };

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput;
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number;
  };

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null;
    where?: RolePermissionWhereInput;
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[];
    cursor?: RolePermissionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[];
  };

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
  };

  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null;
    _min: RolePermissionMinAggregateOutputType | null;
    _max: RolePermissionMaxAggregateOutputType | null;
  };

  export type RolePermissionMinAggregateOutputType = {
    id: string | null;
    roleId: string | null;
    permissionId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RolePermissionMaxAggregateOutputType = {
    id: string | null;
    roleId: string | null;
    permissionId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RolePermissionCountAggregateOutputType = {
    id: number;
    roleId: number;
    permissionId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type RolePermissionMinAggregateInputType = {
    id?: true;
    roleId?: true;
    permissionId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RolePermissionMaxAggregateInputType = {
    id?: true;
    roleId?: true;
    permissionId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RolePermissionCountAggregateInputType = {
    id?: true;
    roleId?: true;
    permissionId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type RolePermissionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RolePermissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned RolePermissions
     **/
    _count?: true | RolePermissionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RolePermissionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RolePermissionMaxAggregateInputType;
  };

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
    [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>;
  };

  export type RolePermissionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RolePermissionWhereInput;
    orderBy?:
      | RolePermissionOrderByWithAggregationInput
      | RolePermissionOrderByWithAggregationInput[];
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum;
    having?: RolePermissionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RolePermissionCountAggregateInputType | true;
    _min?: RolePermissionMinAggregateInputType;
    _max?: RolePermissionMaxAggregateInputType;
  };

  export type RolePermissionGroupByOutputType = {
    id: string;
    roleId: string;
    permissionId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: RolePermissionCountAggregateOutputType | null;
    _min: RolePermissionMinAggregateOutputType | null;
    _max: RolePermissionMaxAggregateOutputType | null;
  };

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> & {
        [P in keyof T & keyof RolePermissionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
          : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>;
      }
    >
  >;

  export type RolePermissionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      roleId?: boolean;
      permissionId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      permission?: boolean | PermissionDefaultArgs<ExtArgs>;
      role?: boolean | RoleDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['rolePermission']
  >;

  export type RolePermissionSelectScalar = {
    id?: boolean;
    roleId?: boolean;
    permissionId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type RolePermissionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'roleId' | 'permissionId' | 'createdAt' | 'updatedAt',
    ExtArgs['result']['rolePermission']
  >;
  export type RolePermissionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    permission?: boolean | PermissionDefaultArgs<ExtArgs>;
    role?: boolean | RoleDefaultArgs<ExtArgs>;
  };

  export type $RolePermissionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'RolePermission';
    objects: {
      permission: Prisma.$PermissionPayload<ExtArgs>;
      role: Prisma.$RolePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        roleId: string;
        permissionId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['rolePermission']
    >;
    composites: {};
  };

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> =
    $Result.GetResult<Prisma.$RolePermissionPayload, S>;

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true;
    };

  export interface RolePermissionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'];
      meta: { name: 'RolePermission' };
    };
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(
      args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<
      $Result.GetResult<
        Prisma.$RolePermissionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<
      $Result.GetResult<
        Prisma.$RolePermissionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(
      args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<
      $Result.GetResult<
        Prisma.$RolePermissionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<
      $Result.GetResult<
        Prisma.$RolePermissionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     *
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RolePermissionFindManyArgs>(
      args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     *
     */
    create<T extends RolePermissionCreateArgs>(
      args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<
      $Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RolePermissionCreateManyArgs>(
      args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     *
     */
    delete<T extends RolePermissionDeleteArgs>(
      args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<
      $Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RolePermissionUpdateArgs>(
      args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<
      $Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(
      args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(
      args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(
      args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<
      $Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
     **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RolePermissionAggregateArgs>(
      args: Subset<T, RolePermissionAggregateArgs>
    ): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>;

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetRolePermissionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the RolePermission model
     */
    readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PermissionDefaultArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      | $Result.GetResult<
          Prisma.$PermissionPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, RoleDefaultArgs<ExtArgs>>
    ): Prisma__RoleClient<
      | $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<'RolePermission', 'String'>;
    readonly roleId: FieldRef<'RolePermission', 'String'>;
    readonly permissionId: FieldRef<'RolePermission', 'String'>;
    readonly createdAt: FieldRef<'RolePermission', 'DateTime'>;
    readonly updatedAt: FieldRef<'RolePermission', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null;
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput;
  };

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null;
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput;
  };

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null;
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RolePermissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[];
  };

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null;
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RolePermissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[];
  };

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null;
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RolePermissions.
     */
    skip?: number;
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[];
  };

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null;
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>;
  };

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null;
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>;
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput;
  };

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>;
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput;
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number;
  };

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null;
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput;
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>;
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>;
  };

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null;
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput;
  };

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput;
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number;
  };

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const UserScalarFieldEnum: {
    id: 'id';
    name: 'name';
    email: 'email';
    emailVerified: 'emailVerified';
    image: 'image';
    password: 'password';
    role: 'role';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    lastLogin: 'lastLogin';
    bio: 'bio';
    department: 'department';
    jobTitle: 'jobTitle';
    location: 'location';
    phone: 'phone';
    skills: 'skills';
    active: 'active';
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const AccountScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    type: 'type';
    provider: 'provider';
    providerAccountId: 'providerAccountId';
    refresh_token: 'refresh_token';
    access_token: 'access_token';
    expires_at: 'expires_at';
    token_type: 'token_type';
    scope: 'scope';
    id_token: 'id_token';
    session_state: 'session_state';
  };

  export type AccountScalarFieldEnum =
    (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum];

  export const SessionScalarFieldEnum: {
    id: 'id';
    sessionToken: 'sessionToken';
    userId: 'userId';
    expires: 'expires';
  };

  export type SessionScalarFieldEnum =
    (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier';
    token: 'token';
    expires: 'expires';
  };

  export type VerificationTokenScalarFieldEnum =
    (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum];

  export const ProjectScalarFieldEnum: {
    id: 'id';
    title: 'title';
    description: 'description';
    startDate: 'startDate';
    endDate: 'endDate';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    createdById: 'createdById';
    dueDate: 'dueDate';
    estimatedTime: 'estimatedTime';
    totalTimeSpent: 'totalTimeSpent';
  };

  export type ProjectScalarFieldEnum =
    (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum];

  export const ProjectStatusScalarFieldEnum: {
    id: 'id';
    name: 'name';
    color: 'color';
    description: 'description';
    isDefault: 'isDefault';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    order: 'order';
    projectId: 'projectId';
    isCompletedStatus: 'isCompletedStatus';
  };

  export type ProjectStatusScalarFieldEnum =
    (typeof ProjectStatusScalarFieldEnum)[keyof typeof ProjectStatusScalarFieldEnum];

  export const TaskScalarFieldEnum: {
    id: 'id';
    title: 'title';
    description: 'description';
    priority: 'priority';
    dueDate: 'dueDate';
    projectId: 'projectId';
    parentId: 'parentId';
    order: 'order';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    endDate: 'endDate';
    estimatedTime: 'estimatedTime';
    startDate: 'startDate';
    statusId: 'statusId';
    timeSpent: 'timeSpent';
    completed: 'completed';
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum];

  export const TaskAssigneeScalarFieldEnum: {
    id: 'id';
    taskId: 'taskId';
    userId: 'userId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type TaskAssigneeScalarFieldEnum =
    (typeof TaskAssigneeScalarFieldEnum)[keyof typeof TaskAssigneeScalarFieldEnum];

  export const TeamMemberScalarFieldEnum: {
    id: 'id';
    projectId: 'projectId';
    userId: 'userId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type TeamMemberScalarFieldEnum =
    (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum];

  export const EventScalarFieldEnum: {
    id: 'id';
    title: 'title';
    description: 'description';
    date: 'date';
    projectId: 'projectId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type EventScalarFieldEnum =
    (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum];

  export const AttendanceScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    checkInTime: 'checkInTime';
    checkOutTime: 'checkOutTime';
    checkInLatitude: 'checkInLatitude';
    checkInLongitude: 'checkInLongitude';
    checkOutLatitude: 'checkOutLatitude';
    checkOutLongitude: 'checkOutLongitude';
    checkInIpAddress: 'checkInIpAddress';
    checkOutIpAddress: 'checkOutIpAddress';
    checkInDeviceInfo: 'checkInDeviceInfo';
    checkOutDeviceInfo: 'checkOutDeviceInfo';
    totalHours: 'totalHours';
    notes: 'notes';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    checkInLocationName: 'checkInLocationName';
    checkOutLocationName: 'checkOutLocationName';
    projectId: 'projectId';
    taskId: 'taskId';
    autoCheckout: 'autoCheckout';
  };

  export type AttendanceScalarFieldEnum =
    (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum];

  export const AttendanceSettingsScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    workHoursPerDay: 'workHoursPerDay';
    workDays: 'workDays';
    reminderEnabled: 'reminderEnabled';
    reminderTime: 'reminderTime';
    autoCheckoutEnabled: 'autoCheckoutEnabled';
    autoCheckoutTime: 'autoCheckoutTime';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type AttendanceSettingsScalarFieldEnum =
    (typeof AttendanceSettingsScalarFieldEnum)[keyof typeof AttendanceSettingsScalarFieldEnum];

  export const ActivityScalarFieldEnum: {
    id: 'id';
    action: 'action';
    entityType: 'entityType';
    entityId: 'entityId';
    description: 'description';
    userId: 'userId';
    projectId: 'projectId';
    taskId: 'taskId';
    createdAt: 'createdAt';
  };

  export type ActivityScalarFieldEnum =
    (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum];

  export const DocumentScalarFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    fileType: 'fileType';
    fileSize: 'fileSize';
    filePath: 'filePath';
    userId: 'userId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type DocumentScalarFieldEnum =
    (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum];

  export const AttendanceCorrectionRequestScalarFieldEnum: {
    id: 'id';
    attendanceId: 'attendanceId';
    userId: 'userId';
    originalCheckInTime: 'originalCheckInTime';
    originalCheckOutTime: 'originalCheckOutTime';
    requestedCheckInTime: 'requestedCheckInTime';
    requestedCheckOutTime: 'requestedCheckOutTime';
    reason: 'reason';
    status: 'status';
    reviewedBy: 'reviewedBy';
    reviewedAt: 'reviewedAt';
    reviewNotes: 'reviewNotes';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type AttendanceCorrectionRequestScalarFieldEnum =
    (typeof AttendanceCorrectionRequestScalarFieldEnum)[keyof typeof AttendanceCorrectionRequestScalarFieldEnum];

  export const CommentScalarFieldEnum: {
    id: 'id';
    content: 'content';
    taskId: 'taskId';
    userId: 'userId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type CommentScalarFieldEnum =
    (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum];

  export const TaskAttachmentScalarFieldEnum: {
    id: 'id';
    filename: 'filename';
    fileUrl: 'fileUrl';
    fileSize: 'fileSize';
    fileType: 'fileType';
    taskId: 'taskId';
    userId: 'userId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type TaskAttachmentScalarFieldEnum =
    (typeof TaskAttachmentScalarFieldEnum)[keyof typeof TaskAttachmentScalarFieldEnum];

  export const RoleScalarFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    color: 'color';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum];

  export const PermissionScalarFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    category: 'category';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type PermissionScalarFieldEnum =
    (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum];

  export const RolePermissionScalarFieldEnum: {
    id: 'id';
    roleId: 'roleId';
    permissionId: 'permissionId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type RolePermissionScalarFieldEnum =
    (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const UserOrderByRelevanceFieldEnum: {
    id: 'id';
    name: 'name';
    email: 'email';
    image: 'image';
    password: 'password';
    role: 'role';
    bio: 'bio';
    department: 'department';
    jobTitle: 'jobTitle';
    location: 'location';
    phone: 'phone';
    skills: 'skills';
  };

  export type UserOrderByRelevanceFieldEnum =
    (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum];

  export const AccountOrderByRelevanceFieldEnum: {
    id: 'id';
    userId: 'userId';
    type: 'type';
    provider: 'provider';
    providerAccountId: 'providerAccountId';
    refresh_token: 'refresh_token';
    access_token: 'access_token';
    token_type: 'token_type';
    scope: 'scope';
    id_token: 'id_token';
    session_state: 'session_state';
  };

  export type AccountOrderByRelevanceFieldEnum =
    (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum];

  export const SessionOrderByRelevanceFieldEnum: {
    id: 'id';
    sessionToken: 'sessionToken';
    userId: 'userId';
  };

  export type SessionOrderByRelevanceFieldEnum =
    (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum];

  export const VerificationTokenOrderByRelevanceFieldEnum: {
    identifier: 'identifier';
    token: 'token';
  };

  export type VerificationTokenOrderByRelevanceFieldEnum =
    (typeof VerificationTokenOrderByRelevanceFieldEnum)[keyof typeof VerificationTokenOrderByRelevanceFieldEnum];

  export const ProjectOrderByRelevanceFieldEnum: {
    id: 'id';
    title: 'title';
    description: 'description';
    createdById: 'createdById';
  };

  export type ProjectOrderByRelevanceFieldEnum =
    (typeof ProjectOrderByRelevanceFieldEnum)[keyof typeof ProjectOrderByRelevanceFieldEnum];

  export const ProjectStatusOrderByRelevanceFieldEnum: {
    id: 'id';
    name: 'name';
    color: 'color';
    description: 'description';
    projectId: 'projectId';
  };

  export type ProjectStatusOrderByRelevanceFieldEnum =
    (typeof ProjectStatusOrderByRelevanceFieldEnum)[keyof typeof ProjectStatusOrderByRelevanceFieldEnum];

  export const TaskOrderByRelevanceFieldEnum: {
    id: 'id';
    title: 'title';
    description: 'description';
    priority: 'priority';
    projectId: 'projectId';
    parentId: 'parentId';
    statusId: 'statusId';
  };

  export type TaskOrderByRelevanceFieldEnum =
    (typeof TaskOrderByRelevanceFieldEnum)[keyof typeof TaskOrderByRelevanceFieldEnum];

  export const TaskAssigneeOrderByRelevanceFieldEnum: {
    id: 'id';
    taskId: 'taskId';
    userId: 'userId';
  };

  export type TaskAssigneeOrderByRelevanceFieldEnum =
    (typeof TaskAssigneeOrderByRelevanceFieldEnum)[keyof typeof TaskAssigneeOrderByRelevanceFieldEnum];

  export const TeamMemberOrderByRelevanceFieldEnum: {
    id: 'id';
    projectId: 'projectId';
    userId: 'userId';
  };

  export type TeamMemberOrderByRelevanceFieldEnum =
    (typeof TeamMemberOrderByRelevanceFieldEnum)[keyof typeof TeamMemberOrderByRelevanceFieldEnum];

  export const EventOrderByRelevanceFieldEnum: {
    id: 'id';
    title: 'title';
    description: 'description';
    projectId: 'projectId';
  };

  export type EventOrderByRelevanceFieldEnum =
    (typeof EventOrderByRelevanceFieldEnum)[keyof typeof EventOrderByRelevanceFieldEnum];

  export const AttendanceOrderByRelevanceFieldEnum: {
    id: 'id';
    userId: 'userId';
    checkInIpAddress: 'checkInIpAddress';
    checkOutIpAddress: 'checkOutIpAddress';
    checkInDeviceInfo: 'checkInDeviceInfo';
    checkOutDeviceInfo: 'checkOutDeviceInfo';
    notes: 'notes';
    checkInLocationName: 'checkInLocationName';
    checkOutLocationName: 'checkOutLocationName';
    projectId: 'projectId';
    taskId: 'taskId';
  };

  export type AttendanceOrderByRelevanceFieldEnum =
    (typeof AttendanceOrderByRelevanceFieldEnum)[keyof typeof AttendanceOrderByRelevanceFieldEnum];

  export const AttendanceSettingsOrderByRelevanceFieldEnum: {
    id: 'id';
    userId: 'userId';
    workDays: 'workDays';
    reminderTime: 'reminderTime';
    autoCheckoutTime: 'autoCheckoutTime';
  };

  export type AttendanceSettingsOrderByRelevanceFieldEnum =
    (typeof AttendanceSettingsOrderByRelevanceFieldEnum)[keyof typeof AttendanceSettingsOrderByRelevanceFieldEnum];

  export const ActivityOrderByRelevanceFieldEnum: {
    id: 'id';
    action: 'action';
    entityType: 'entityType';
    entityId: 'entityId';
    description: 'description';
    userId: 'userId';
    projectId: 'projectId';
    taskId: 'taskId';
  };

  export type ActivityOrderByRelevanceFieldEnum =
    (typeof ActivityOrderByRelevanceFieldEnum)[keyof typeof ActivityOrderByRelevanceFieldEnum];

  export const DocumentOrderByRelevanceFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    fileType: 'fileType';
    filePath: 'filePath';
    userId: 'userId';
  };

  export type DocumentOrderByRelevanceFieldEnum =
    (typeof DocumentOrderByRelevanceFieldEnum)[keyof typeof DocumentOrderByRelevanceFieldEnum];

  export const AttendanceCorrectionRequestOrderByRelevanceFieldEnum: {
    id: 'id';
    attendanceId: 'attendanceId';
    userId: 'userId';
    reason: 'reason';
    status: 'status';
    reviewedBy: 'reviewedBy';
    reviewNotes: 'reviewNotes';
  };

  export type AttendanceCorrectionRequestOrderByRelevanceFieldEnum =
    (typeof AttendanceCorrectionRequestOrderByRelevanceFieldEnum)[keyof typeof AttendanceCorrectionRequestOrderByRelevanceFieldEnum];

  export const CommentOrderByRelevanceFieldEnum: {
    id: 'id';
    content: 'content';
    taskId: 'taskId';
    userId: 'userId';
  };

  export type CommentOrderByRelevanceFieldEnum =
    (typeof CommentOrderByRelevanceFieldEnum)[keyof typeof CommentOrderByRelevanceFieldEnum];

  export const TaskAttachmentOrderByRelevanceFieldEnum: {
    id: 'id';
    filename: 'filename';
    fileUrl: 'fileUrl';
    fileType: 'fileType';
    taskId: 'taskId';
    userId: 'userId';
  };

  export type TaskAttachmentOrderByRelevanceFieldEnum =
    (typeof TaskAttachmentOrderByRelevanceFieldEnum)[keyof typeof TaskAttachmentOrderByRelevanceFieldEnum];

  export const RoleOrderByRelevanceFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    color: 'color';
  };

  export type RoleOrderByRelevanceFieldEnum =
    (typeof RoleOrderByRelevanceFieldEnum)[keyof typeof RoleOrderByRelevanceFieldEnum];

  export const PermissionOrderByRelevanceFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    category: 'category';
  };

  export type PermissionOrderByRelevanceFieldEnum =
    (typeof PermissionOrderByRelevanceFieldEnum)[keyof typeof PermissionOrderByRelevanceFieldEnum];

  export const RolePermissionOrderByRelevanceFieldEnum: {
    id: 'id';
    roleId: 'roleId';
    permissionId: 'permissionId';
  };

  export type RolePermissionOrderByRelevanceFieldEnum =
    (typeof RolePermissionOrderByRelevanceFieldEnum)[keyof typeof RolePermissionOrderByRelevanceFieldEnum];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>;

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<'User'> | string;
    name?: StringNullableFilter<'User'> | string | null;
    email?: StringFilter<'User'> | string;
    emailVerified?: DateTimeNullableFilter<'User'> | Date | string | null;
    image?: StringNullableFilter<'User'> | string | null;
    password?: StringNullableFilter<'User'> | string | null;
    role?: StringFilter<'User'> | string;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
    lastLogin?: DateTimeNullableFilter<'User'> | Date | string | null;
    bio?: StringNullableFilter<'User'> | string | null;
    department?: StringNullableFilter<'User'> | string | null;
    jobTitle?: StringNullableFilter<'User'> | string | null;
    location?: StringNullableFilter<'User'> | string | null;
    phone?: StringNullableFilter<'User'> | string | null;
    skills?: StringNullableFilter<'User'> | string | null;
    active?: BoolFilter<'User'> | boolean;
    accounts?: AccountListRelationFilter;
    activities?: ActivityListRelationFilter;
    attendanceRecords?: AttendanceListRelationFilter;
    correctionRequests?: AttendanceCorrectionRequestListRelationFilter;
    attendanceSettings?: XOR<
      AttendanceSettingsNullableScalarRelationFilter,
      AttendanceSettingsWhereInput
    > | null;
    comments?: CommentListRelationFilter;
    documents?: DocumentListRelationFilter;
    projects?: ProjectListRelationFilter;
    sessions?: SessionListRelationFilter;
    taskAssignments?: TaskAssigneeListRelationFilter;
    taskAttachments?: TaskAttachmentListRelationFilter;
    teams?: TeamMemberListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLogin?: SortOrderInput | SortOrder;
    bio?: SortOrderInput | SortOrder;
    department?: SortOrderInput | SortOrder;
    jobTitle?: SortOrderInput | SortOrder;
    location?: SortOrderInput | SortOrder;
    phone?: SortOrderInput | SortOrder;
    skills?: SortOrderInput | SortOrder;
    active?: SortOrder;
    accounts?: AccountOrderByRelationAggregateInput;
    activities?: ActivityOrderByRelationAggregateInput;
    attendanceRecords?: AttendanceOrderByRelationAggregateInput;
    correctionRequests?: AttendanceCorrectionRequestOrderByRelationAggregateInput;
    attendanceSettings?: AttendanceSettingsOrderByWithRelationInput;
    comments?: CommentOrderByRelationAggregateInput;
    documents?: DocumentOrderByRelationAggregateInput;
    projects?: ProjectOrderByRelationAggregateInput;
    sessions?: SessionOrderByRelationAggregateInput;
    taskAssignments?: TaskAssigneeOrderByRelationAggregateInput;
    taskAttachments?: TaskAttachmentOrderByRelationAggregateInput;
    teams?: TeamMemberOrderByRelationAggregateInput;
    _relevance?: UserOrderByRelevanceInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      name?: StringNullableFilter<'User'> | string | null;
      emailVerified?: DateTimeNullableFilter<'User'> | Date | string | null;
      image?: StringNullableFilter<'User'> | string | null;
      password?: StringNullableFilter<'User'> | string | null;
      role?: StringFilter<'User'> | string;
      createdAt?: DateTimeFilter<'User'> | Date | string;
      updatedAt?: DateTimeFilter<'User'> | Date | string;
      lastLogin?: DateTimeNullableFilter<'User'> | Date | string | null;
      bio?: StringNullableFilter<'User'> | string | null;
      department?: StringNullableFilter<'User'> | string | null;
      jobTitle?: StringNullableFilter<'User'> | string | null;
      location?: StringNullableFilter<'User'> | string | null;
      phone?: StringNullableFilter<'User'> | string | null;
      skills?: StringNullableFilter<'User'> | string | null;
      active?: BoolFilter<'User'> | boolean;
      accounts?: AccountListRelationFilter;
      activities?: ActivityListRelationFilter;
      attendanceRecords?: AttendanceListRelationFilter;
      correctionRequests?: AttendanceCorrectionRequestListRelationFilter;
      attendanceSettings?: XOR<
        AttendanceSettingsNullableScalarRelationFilter,
        AttendanceSettingsWhereInput
      > | null;
      comments?: CommentListRelationFilter;
      documents?: DocumentListRelationFilter;
      projects?: ProjectListRelationFilter;
      sessions?: SessionListRelationFilter;
      taskAssignments?: TaskAssigneeListRelationFilter;
      taskAttachments?: TaskAttachmentListRelationFilter;
      teams?: TeamMemberListRelationFilter;
    },
    'id' | 'email'
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLogin?: SortOrderInput | SortOrder;
    bio?: SortOrderInput | SortOrder;
    department?: SortOrderInput | SortOrder;
    jobTitle?: SortOrderInput | SortOrder;
    location?: SortOrderInput | SortOrder;
    phone?: SortOrderInput | SortOrder;
    skills?: SortOrderInput | SortOrder;
    active?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'User'> | string;
    name?: StringNullableWithAggregatesFilter<'User'> | string | null;
    email?: StringWithAggregatesFilter<'User'> | string;
    emailVerified?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    image?: StringNullableWithAggregatesFilter<'User'> | string | null;
    password?: StringNullableWithAggregatesFilter<'User'> | string | null;
    role?: StringWithAggregatesFilter<'User'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    lastLogin?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    bio?: StringNullableWithAggregatesFilter<'User'> | string | null;
    department?: StringNullableWithAggregatesFilter<'User'> | string | null;
    jobTitle?: StringNullableWithAggregatesFilter<'User'> | string | null;
    location?: StringNullableWithAggregatesFilter<'User'> | string | null;
    phone?: StringNullableWithAggregatesFilter<'User'> | string | null;
    skills?: StringNullableWithAggregatesFilter<'User'> | string | null;
    active?: BoolWithAggregatesFilter<'User'> | boolean;
  };

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[];
    OR?: AccountWhereInput[];
    NOT?: AccountWhereInput | AccountWhereInput[];
    id?: StringFilter<'Account'> | string;
    userId?: StringFilter<'Account'> | string;
    type?: StringFilter<'Account'> | string;
    provider?: StringFilter<'Account'> | string;
    providerAccountId?: StringFilter<'Account'> | string;
    refresh_token?: StringNullableFilter<'Account'> | string | null;
    access_token?: StringNullableFilter<'Account'> | string | null;
    expires_at?: IntNullableFilter<'Account'> | number | null;
    token_type?: StringNullableFilter<'Account'> | string | null;
    scope?: StringNullableFilter<'Account'> | string | null;
    id_token?: StringNullableFilter<'Account'> | string | null;
    session_state?: StringNullableFilter<'Account'> | string | null;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    user?: UserOrderByWithRelationInput;
    _relevance?: AccountOrderByRelevanceInput;
  };

  export type AccountWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput;
      AND?: AccountWhereInput | AccountWhereInput[];
      OR?: AccountWhereInput[];
      NOT?: AccountWhereInput | AccountWhereInput[];
      userId?: StringFilter<'Account'> | string;
      type?: StringFilter<'Account'> | string;
      provider?: StringFilter<'Account'> | string;
      providerAccountId?: StringFilter<'Account'> | string;
      refresh_token?: StringNullableFilter<'Account'> | string | null;
      access_token?: StringNullableFilter<'Account'> | string | null;
      expires_at?: IntNullableFilter<'Account'> | number | null;
      token_type?: StringNullableFilter<'Account'> | string | null;
      scope?: StringNullableFilter<'Account'> | string | null;
      id_token?: StringNullableFilter<'Account'> | string | null;
      session_state?: StringNullableFilter<'Account'> | string | null;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'provider_providerAccountId'
  >;

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    _count?: AccountCountOrderByAggregateInput;
    _avg?: AccountAvgOrderByAggregateInput;
    _max?: AccountMaxOrderByAggregateInput;
    _min?: AccountMinOrderByAggregateInput;
    _sum?: AccountSumOrderByAggregateInput;
  };

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[];
    OR?: AccountScalarWhereWithAggregatesInput[];
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Account'> | string;
    userId?: StringWithAggregatesFilter<'Account'> | string;
    type?: StringWithAggregatesFilter<'Account'> | string;
    provider?: StringWithAggregatesFilter<'Account'> | string;
    providerAccountId?: StringWithAggregatesFilter<'Account'> | string;
    refresh_token?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    access_token?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    expires_at?: IntNullableWithAggregatesFilter<'Account'> | number | null;
    token_type?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    scope?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    id_token?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    session_state?: StringNullableWithAggregatesFilter<'Account'> | string | null;
  };

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[];
    OR?: SessionWhereInput[];
    NOT?: SessionWhereInput | SessionWhereInput[];
    id?: StringFilter<'Session'> | string;
    sessionToken?: StringFilter<'Session'> | string;
    userId?: StringFilter<'Session'> | string;
    expires?: DateTimeFilter<'Session'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    user?: UserOrderByWithRelationInput;
    _relevance?: SessionOrderByRelevanceInput;
  };

  export type SessionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      sessionToken?: string;
      AND?: SessionWhereInput | SessionWhereInput[];
      OR?: SessionWhereInput[];
      NOT?: SessionWhereInput | SessionWhereInput[];
      userId?: StringFilter<'Session'> | string;
      expires?: DateTimeFilter<'Session'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'sessionToken'
  >;

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    _count?: SessionCountOrderByAggregateInput;
    _max?: SessionMaxOrderByAggregateInput;
    _min?: SessionMinOrderByAggregateInput;
  };

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[];
    OR?: SessionScalarWhereWithAggregatesInput[];
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Session'> | string;
    sessionToken?: StringWithAggregatesFilter<'Session'> | string;
    userId?: StringWithAggregatesFilter<'Session'> | string;
    expires?: DateTimeWithAggregatesFilter<'Session'> | Date | string;
  };

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
    OR?: VerificationTokenWhereInput[];
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
    identifier?: StringFilter<'VerificationToken'> | string;
    token?: StringFilter<'VerificationToken'> | string;
    expires?: DateTimeFilter<'VerificationToken'> | Date | string;
  };

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
    _relevance?: VerificationTokenOrderByRelevanceInput;
  };

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<
    {
      token?: string;
      identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput;
      AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
      OR?: VerificationTokenWhereInput[];
      NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
      identifier?: StringFilter<'VerificationToken'> | string;
      expires?: DateTimeFilter<'VerificationToken'> | Date | string;
    },
    'token' | 'identifier_token'
  >;

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
    _count?: VerificationTokenCountOrderByAggregateInput;
    _max?: VerificationTokenMaxOrderByAggregateInput;
    _min?: VerificationTokenMinOrderByAggregateInput;
  };

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?:
      | VerificationTokenScalarWhereWithAggregatesInput
      | VerificationTokenScalarWhereWithAggregatesInput[];
    OR?: VerificationTokenScalarWhereWithAggregatesInput[];
    NOT?:
      | VerificationTokenScalarWhereWithAggregatesInput
      | VerificationTokenScalarWhereWithAggregatesInput[];
    identifier?: StringWithAggregatesFilter<'VerificationToken'> | string;
    token?: StringWithAggregatesFilter<'VerificationToken'> | string;
    expires?: DateTimeWithAggregatesFilter<'VerificationToken'> | Date | string;
  };

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[];
    OR?: ProjectWhereInput[];
    NOT?: ProjectWhereInput | ProjectWhereInput[];
    id?: StringFilter<'Project'> | string;
    title?: StringFilter<'Project'> | string;
    description?: StringNullableFilter<'Project'> | string | null;
    startDate?: DateTimeNullableFilter<'Project'> | Date | string | null;
    endDate?: DateTimeNullableFilter<'Project'> | Date | string | null;
    createdAt?: DateTimeFilter<'Project'> | Date | string;
    updatedAt?: DateTimeFilter<'Project'> | Date | string;
    createdById?: StringFilter<'Project'> | string;
    dueDate?: DateTimeNullableFilter<'Project'> | Date | string | null;
    estimatedTime?: FloatNullableFilter<'Project'> | number | null;
    totalTimeSpent?: FloatNullableFilter<'Project'> | number | null;
    activities?: ActivityListRelationFilter;
    attendances?: AttendanceListRelationFilter;
    events?: EventListRelationFilter;
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    statuses?: ProjectStatusListRelationFilter;
    tasks?: TaskListRelationFilter;
    teamMembers?: TeamMemberListRelationFilter;
  };

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    startDate?: SortOrderInput | SortOrder;
    endDate?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdById?: SortOrder;
    dueDate?: SortOrderInput | SortOrder;
    estimatedTime?: SortOrderInput | SortOrder;
    totalTimeSpent?: SortOrderInput | SortOrder;
    activities?: ActivityOrderByRelationAggregateInput;
    attendances?: AttendanceOrderByRelationAggregateInput;
    events?: EventOrderByRelationAggregateInput;
    createdBy?: UserOrderByWithRelationInput;
    statuses?: ProjectStatusOrderByRelationAggregateInput;
    tasks?: TaskOrderByRelationAggregateInput;
    teamMembers?: TeamMemberOrderByRelationAggregateInput;
    _relevance?: ProjectOrderByRelevanceInput;
  };

  export type ProjectWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ProjectWhereInput | ProjectWhereInput[];
      OR?: ProjectWhereInput[];
      NOT?: ProjectWhereInput | ProjectWhereInput[];
      title?: StringFilter<'Project'> | string;
      description?: StringNullableFilter<'Project'> | string | null;
      startDate?: DateTimeNullableFilter<'Project'> | Date | string | null;
      endDate?: DateTimeNullableFilter<'Project'> | Date | string | null;
      createdAt?: DateTimeFilter<'Project'> | Date | string;
      updatedAt?: DateTimeFilter<'Project'> | Date | string;
      createdById?: StringFilter<'Project'> | string;
      dueDate?: DateTimeNullableFilter<'Project'> | Date | string | null;
      estimatedTime?: FloatNullableFilter<'Project'> | number | null;
      totalTimeSpent?: FloatNullableFilter<'Project'> | number | null;
      activities?: ActivityListRelationFilter;
      attendances?: AttendanceListRelationFilter;
      events?: EventListRelationFilter;
      createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
      statuses?: ProjectStatusListRelationFilter;
      tasks?: TaskListRelationFilter;
      teamMembers?: TeamMemberListRelationFilter;
    },
    'id'
  >;

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    startDate?: SortOrderInput | SortOrder;
    endDate?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdById?: SortOrder;
    dueDate?: SortOrderInput | SortOrder;
    estimatedTime?: SortOrderInput | SortOrder;
    totalTimeSpent?: SortOrderInput | SortOrder;
    _count?: ProjectCountOrderByAggregateInput;
    _avg?: ProjectAvgOrderByAggregateInput;
    _max?: ProjectMaxOrderByAggregateInput;
    _min?: ProjectMinOrderByAggregateInput;
    _sum?: ProjectSumOrderByAggregateInput;
  };

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[];
    OR?: ProjectScalarWhereWithAggregatesInput[];
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Project'> | string;
    title?: StringWithAggregatesFilter<'Project'> | string;
    description?: StringNullableWithAggregatesFilter<'Project'> | string | null;
    startDate?: DateTimeNullableWithAggregatesFilter<'Project'> | Date | string | null;
    endDate?: DateTimeNullableWithAggregatesFilter<'Project'> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Project'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Project'> | Date | string;
    createdById?: StringWithAggregatesFilter<'Project'> | string;
    dueDate?: DateTimeNullableWithAggregatesFilter<'Project'> | Date | string | null;
    estimatedTime?: FloatNullableWithAggregatesFilter<'Project'> | number | null;
    totalTimeSpent?: FloatNullableWithAggregatesFilter<'Project'> | number | null;
  };

  export type ProjectStatusWhereInput = {
    AND?: ProjectStatusWhereInput | ProjectStatusWhereInput[];
    OR?: ProjectStatusWhereInput[];
    NOT?: ProjectStatusWhereInput | ProjectStatusWhereInput[];
    id?: StringFilter<'ProjectStatus'> | string;
    name?: StringFilter<'ProjectStatus'> | string;
    color?: StringNullableFilter<'ProjectStatus'> | string | null;
    description?: StringNullableFilter<'ProjectStatus'> | string | null;
    isDefault?: BoolFilter<'ProjectStatus'> | boolean;
    createdAt?: DateTimeFilter<'ProjectStatus'> | Date | string;
    updatedAt?: DateTimeFilter<'ProjectStatus'> | Date | string;
    order?: IntFilter<'ProjectStatus'> | number;
    projectId?: StringFilter<'ProjectStatus'> | string;
    isCompletedStatus?: BoolFilter<'ProjectStatus'> | boolean;
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>;
    tasks?: TaskListRelationFilter;
  };

  export type ProjectStatusOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    color?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    order?: SortOrder;
    projectId?: SortOrder;
    isCompletedStatus?: SortOrder;
    project?: ProjectOrderByWithRelationInput;
    tasks?: TaskOrderByRelationAggregateInput;
    _relevance?: ProjectStatusOrderByRelevanceInput;
  };

  export type ProjectStatusWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      projectId_name?: ProjectStatusProjectIdNameCompoundUniqueInput;
      AND?: ProjectStatusWhereInput | ProjectStatusWhereInput[];
      OR?: ProjectStatusWhereInput[];
      NOT?: ProjectStatusWhereInput | ProjectStatusWhereInput[];
      name?: StringFilter<'ProjectStatus'> | string;
      color?: StringNullableFilter<'ProjectStatus'> | string | null;
      description?: StringNullableFilter<'ProjectStatus'> | string | null;
      isDefault?: BoolFilter<'ProjectStatus'> | boolean;
      createdAt?: DateTimeFilter<'ProjectStatus'> | Date | string;
      updatedAt?: DateTimeFilter<'ProjectStatus'> | Date | string;
      order?: IntFilter<'ProjectStatus'> | number;
      projectId?: StringFilter<'ProjectStatus'> | string;
      isCompletedStatus?: BoolFilter<'ProjectStatus'> | boolean;
      project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>;
      tasks?: TaskListRelationFilter;
    },
    'id' | 'projectId_name'
  >;

  export type ProjectStatusOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    color?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    order?: SortOrder;
    projectId?: SortOrder;
    isCompletedStatus?: SortOrder;
    _count?: ProjectStatusCountOrderByAggregateInput;
    _avg?: ProjectStatusAvgOrderByAggregateInput;
    _max?: ProjectStatusMaxOrderByAggregateInput;
    _min?: ProjectStatusMinOrderByAggregateInput;
    _sum?: ProjectStatusSumOrderByAggregateInput;
  };

  export type ProjectStatusScalarWhereWithAggregatesInput = {
    AND?:
      | ProjectStatusScalarWhereWithAggregatesInput
      | ProjectStatusScalarWhereWithAggregatesInput[];
    OR?: ProjectStatusScalarWhereWithAggregatesInput[];
    NOT?:
      | ProjectStatusScalarWhereWithAggregatesInput
      | ProjectStatusScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ProjectStatus'> | string;
    name?: StringWithAggregatesFilter<'ProjectStatus'> | string;
    color?: StringNullableWithAggregatesFilter<'ProjectStatus'> | string | null;
    description?: StringNullableWithAggregatesFilter<'ProjectStatus'> | string | null;
    isDefault?: BoolWithAggregatesFilter<'ProjectStatus'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'ProjectStatus'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'ProjectStatus'> | Date | string;
    order?: IntWithAggregatesFilter<'ProjectStatus'> | number;
    projectId?: StringWithAggregatesFilter<'ProjectStatus'> | string;
    isCompletedStatus?: BoolWithAggregatesFilter<'ProjectStatus'> | boolean;
  };

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[];
    OR?: TaskWhereInput[];
    NOT?: TaskWhereInput | TaskWhereInput[];
    id?: StringFilter<'Task'> | string;
    title?: StringFilter<'Task'> | string;
    description?: StringNullableFilter<'Task'> | string | null;
    priority?: StringFilter<'Task'> | string;
    dueDate?: DateTimeNullableFilter<'Task'> | Date | string | null;
    projectId?: StringFilter<'Task'> | string;
    parentId?: StringNullableFilter<'Task'> | string | null;
    order?: IntFilter<'Task'> | number;
    createdAt?: DateTimeFilter<'Task'> | Date | string;
    updatedAt?: DateTimeFilter<'Task'> | Date | string;
    endDate?: DateTimeNullableFilter<'Task'> | Date | string | null;
    estimatedTime?: FloatNullableFilter<'Task'> | number | null;
    startDate?: DateTimeNullableFilter<'Task'> | Date | string | null;
    statusId?: StringNullableFilter<'Task'> | string | null;
    timeSpent?: FloatNullableFilter<'Task'> | number | null;
    completed?: BoolFilter<'Task'> | boolean;
    activities?: ActivityListRelationFilter;
    attendances?: AttendanceListRelationFilter;
    comments?: CommentListRelationFilter;
    parent?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null;
    subtasks?: TaskListRelationFilter;
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>;
    status?: XOR<ProjectStatusNullableScalarRelationFilter, ProjectStatusWhereInput> | null;
    assignees?: TaskAssigneeListRelationFilter;
    attachments?: TaskAttachmentListRelationFilter;
  };

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    priority?: SortOrder;
    dueDate?: SortOrderInput | SortOrder;
    projectId?: SortOrder;
    parentId?: SortOrderInput | SortOrder;
    order?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    endDate?: SortOrderInput | SortOrder;
    estimatedTime?: SortOrderInput | SortOrder;
    startDate?: SortOrderInput | SortOrder;
    statusId?: SortOrderInput | SortOrder;
    timeSpent?: SortOrderInput | SortOrder;
    completed?: SortOrder;
    activities?: ActivityOrderByRelationAggregateInput;
    attendances?: AttendanceOrderByRelationAggregateInput;
    comments?: CommentOrderByRelationAggregateInput;
    parent?: TaskOrderByWithRelationInput;
    subtasks?: TaskOrderByRelationAggregateInput;
    project?: ProjectOrderByWithRelationInput;
    status?: ProjectStatusOrderByWithRelationInput;
    assignees?: TaskAssigneeOrderByRelationAggregateInput;
    attachments?: TaskAttachmentOrderByRelationAggregateInput;
    _relevance?: TaskOrderByRelevanceInput;
  };

  export type TaskWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: TaskWhereInput | TaskWhereInput[];
      OR?: TaskWhereInput[];
      NOT?: TaskWhereInput | TaskWhereInput[];
      title?: StringFilter<'Task'> | string;
      description?: StringNullableFilter<'Task'> | string | null;
      priority?: StringFilter<'Task'> | string;
      dueDate?: DateTimeNullableFilter<'Task'> | Date | string | null;
      projectId?: StringFilter<'Task'> | string;
      parentId?: StringNullableFilter<'Task'> | string | null;
      order?: IntFilter<'Task'> | number;
      createdAt?: DateTimeFilter<'Task'> | Date | string;
      updatedAt?: DateTimeFilter<'Task'> | Date | string;
      endDate?: DateTimeNullableFilter<'Task'> | Date | string | null;
      estimatedTime?: FloatNullableFilter<'Task'> | number | null;
      startDate?: DateTimeNullableFilter<'Task'> | Date | string | null;
      statusId?: StringNullableFilter<'Task'> | string | null;
      timeSpent?: FloatNullableFilter<'Task'> | number | null;
      completed?: BoolFilter<'Task'> | boolean;
      activities?: ActivityListRelationFilter;
      attendances?: AttendanceListRelationFilter;
      comments?: CommentListRelationFilter;
      parent?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null;
      subtasks?: TaskListRelationFilter;
      project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>;
      status?: XOR<ProjectStatusNullableScalarRelationFilter, ProjectStatusWhereInput> | null;
      assignees?: TaskAssigneeListRelationFilter;
      attachments?: TaskAttachmentListRelationFilter;
    },
    'id'
  >;

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    priority?: SortOrder;
    dueDate?: SortOrderInput | SortOrder;
    projectId?: SortOrder;
    parentId?: SortOrderInput | SortOrder;
    order?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    endDate?: SortOrderInput | SortOrder;
    estimatedTime?: SortOrderInput | SortOrder;
    startDate?: SortOrderInput | SortOrder;
    statusId?: SortOrderInput | SortOrder;
    timeSpent?: SortOrderInput | SortOrder;
    completed?: SortOrder;
    _count?: TaskCountOrderByAggregateInput;
    _avg?: TaskAvgOrderByAggregateInput;
    _max?: TaskMaxOrderByAggregateInput;
    _min?: TaskMinOrderByAggregateInput;
    _sum?: TaskSumOrderByAggregateInput;
  };

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[];
    OR?: TaskScalarWhereWithAggregatesInput[];
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Task'> | string;
    title?: StringWithAggregatesFilter<'Task'> | string;
    description?: StringNullableWithAggregatesFilter<'Task'> | string | null;
    priority?: StringWithAggregatesFilter<'Task'> | string;
    dueDate?: DateTimeNullableWithAggregatesFilter<'Task'> | Date | string | null;
    projectId?: StringWithAggregatesFilter<'Task'> | string;
    parentId?: StringNullableWithAggregatesFilter<'Task'> | string | null;
    order?: IntWithAggregatesFilter<'Task'> | number;
    createdAt?: DateTimeWithAggregatesFilter<'Task'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Task'> | Date | string;
    endDate?: DateTimeNullableWithAggregatesFilter<'Task'> | Date | string | null;
    estimatedTime?: FloatNullableWithAggregatesFilter<'Task'> | number | null;
    startDate?: DateTimeNullableWithAggregatesFilter<'Task'> | Date | string | null;
    statusId?: StringNullableWithAggregatesFilter<'Task'> | string | null;
    timeSpent?: FloatNullableWithAggregatesFilter<'Task'> | number | null;
    completed?: BoolWithAggregatesFilter<'Task'> | boolean;
  };

  export type TaskAssigneeWhereInput = {
    AND?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[];
    OR?: TaskAssigneeWhereInput[];
    NOT?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[];
    id?: StringFilter<'TaskAssignee'> | string;
    taskId?: StringFilter<'TaskAssignee'> | string;
    userId?: StringFilter<'TaskAssignee'> | string;
    createdAt?: DateTimeFilter<'TaskAssignee'> | Date | string;
    updatedAt?: DateTimeFilter<'TaskAssignee'> | Date | string;
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type TaskAssigneeOrderByWithRelationInput = {
    id?: SortOrder;
    taskId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    task?: TaskOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    _relevance?: TaskAssigneeOrderByRelevanceInput;
  };

  export type TaskAssigneeWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      taskId_userId?: TaskAssigneeTaskIdUserIdCompoundUniqueInput;
      AND?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[];
      OR?: TaskAssigneeWhereInput[];
      NOT?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[];
      taskId?: StringFilter<'TaskAssignee'> | string;
      userId?: StringFilter<'TaskAssignee'> | string;
      createdAt?: DateTimeFilter<'TaskAssignee'> | Date | string;
      updatedAt?: DateTimeFilter<'TaskAssignee'> | Date | string;
      task?: XOR<TaskScalarRelationFilter, TaskWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'taskId_userId'
  >;

  export type TaskAssigneeOrderByWithAggregationInput = {
    id?: SortOrder;
    taskId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: TaskAssigneeCountOrderByAggregateInput;
    _max?: TaskAssigneeMaxOrderByAggregateInput;
    _min?: TaskAssigneeMinOrderByAggregateInput;
  };

  export type TaskAssigneeScalarWhereWithAggregatesInput = {
    AND?: TaskAssigneeScalarWhereWithAggregatesInput | TaskAssigneeScalarWhereWithAggregatesInput[];
    OR?: TaskAssigneeScalarWhereWithAggregatesInput[];
    NOT?: TaskAssigneeScalarWhereWithAggregatesInput | TaskAssigneeScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'TaskAssignee'> | string;
    taskId?: StringWithAggregatesFilter<'TaskAssignee'> | string;
    userId?: StringWithAggregatesFilter<'TaskAssignee'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'TaskAssignee'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'TaskAssignee'> | Date | string;
  };

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[];
    OR?: TeamMemberWhereInput[];
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[];
    id?: StringFilter<'TeamMember'> | string;
    projectId?: StringFilter<'TeamMember'> | string;
    userId?: StringFilter<'TeamMember'> | string;
    createdAt?: DateTimeFilter<'TeamMember'> | Date | string;
    updatedAt?: DateTimeFilter<'TeamMember'> | Date | string;
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder;
    projectId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    project?: ProjectOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    _relevance?: TeamMemberOrderByRelevanceInput;
  };

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      projectId_userId?: TeamMemberProjectIdUserIdCompoundUniqueInput;
      AND?: TeamMemberWhereInput | TeamMemberWhereInput[];
      OR?: TeamMemberWhereInput[];
      NOT?: TeamMemberWhereInput | TeamMemberWhereInput[];
      projectId?: StringFilter<'TeamMember'> | string;
      userId?: StringFilter<'TeamMember'> | string;
      createdAt?: DateTimeFilter<'TeamMember'> | Date | string;
      updatedAt?: DateTimeFilter<'TeamMember'> | Date | string;
      project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'projectId_userId'
  >;

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder;
    projectId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: TeamMemberCountOrderByAggregateInput;
    _max?: TeamMemberMaxOrderByAggregateInput;
    _min?: TeamMemberMinOrderByAggregateInput;
  };

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[];
    OR?: TeamMemberScalarWhereWithAggregatesInput[];
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'TeamMember'> | string;
    projectId?: StringWithAggregatesFilter<'TeamMember'> | string;
    userId?: StringWithAggregatesFilter<'TeamMember'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'TeamMember'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'TeamMember'> | Date | string;
  };

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[];
    OR?: EventWhereInput[];
    NOT?: EventWhereInput | EventWhereInput[];
    id?: StringFilter<'Event'> | string;
    title?: StringFilter<'Event'> | string;
    description?: StringNullableFilter<'Event'> | string | null;
    date?: DateTimeFilter<'Event'> | Date | string;
    projectId?: StringFilter<'Event'> | string;
    createdAt?: DateTimeFilter<'Event'> | Date | string;
    updatedAt?: DateTimeFilter<'Event'> | Date | string;
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>;
  };

  export type EventOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    date?: SortOrder;
    projectId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    project?: ProjectOrderByWithRelationInput;
    _relevance?: EventOrderByRelevanceInput;
  };

  export type EventWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: EventWhereInput | EventWhereInput[];
      OR?: EventWhereInput[];
      NOT?: EventWhereInput | EventWhereInput[];
      title?: StringFilter<'Event'> | string;
      description?: StringNullableFilter<'Event'> | string | null;
      date?: DateTimeFilter<'Event'> | Date | string;
      projectId?: StringFilter<'Event'> | string;
      createdAt?: DateTimeFilter<'Event'> | Date | string;
      updatedAt?: DateTimeFilter<'Event'> | Date | string;
      project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>;
    },
    'id'
  >;

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    date?: SortOrder;
    projectId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: EventCountOrderByAggregateInput;
    _max?: EventMaxOrderByAggregateInput;
    _min?: EventMinOrderByAggregateInput;
  };

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[];
    OR?: EventScalarWhereWithAggregatesInput[];
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Event'> | string;
    title?: StringWithAggregatesFilter<'Event'> | string;
    description?: StringNullableWithAggregatesFilter<'Event'> | string | null;
    date?: DateTimeWithAggregatesFilter<'Event'> | Date | string;
    projectId?: StringWithAggregatesFilter<'Event'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Event'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Event'> | Date | string;
  };

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[];
    OR?: AttendanceWhereInput[];
    NOT?: AttendanceWhereInput | AttendanceWhereInput[];
    id?: StringFilter<'Attendance'> | string;
    userId?: StringFilter<'Attendance'> | string;
    checkInTime?: DateTimeFilter<'Attendance'> | Date | string;
    checkOutTime?: DateTimeNullableFilter<'Attendance'> | Date | string | null;
    checkInLatitude?: FloatNullableFilter<'Attendance'> | number | null;
    checkInLongitude?: FloatNullableFilter<'Attendance'> | number | null;
    checkOutLatitude?: FloatNullableFilter<'Attendance'> | number | null;
    checkOutLongitude?: FloatNullableFilter<'Attendance'> | number | null;
    checkInIpAddress?: StringNullableFilter<'Attendance'> | string | null;
    checkOutIpAddress?: StringNullableFilter<'Attendance'> | string | null;
    checkInDeviceInfo?: StringNullableFilter<'Attendance'> | string | null;
    checkOutDeviceInfo?: StringNullableFilter<'Attendance'> | string | null;
    totalHours?: FloatNullableFilter<'Attendance'> | number | null;
    notes?: StringNullableFilter<'Attendance'> | string | null;
    createdAt?: DateTimeFilter<'Attendance'> | Date | string;
    updatedAt?: DateTimeFilter<'Attendance'> | Date | string;
    checkInLocationName?: StringNullableFilter<'Attendance'> | string | null;
    checkOutLocationName?: StringNullableFilter<'Attendance'> | string | null;
    projectId?: StringNullableFilter<'Attendance'> | string | null;
    taskId?: StringNullableFilter<'Attendance'> | string | null;
    autoCheckout?: BoolFilter<'Attendance'> | boolean;
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null;
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    correctionRequests?: AttendanceCorrectionRequestListRelationFilter;
  };

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    checkInTime?: SortOrder;
    checkOutTime?: SortOrderInput | SortOrder;
    checkInLatitude?: SortOrderInput | SortOrder;
    checkInLongitude?: SortOrderInput | SortOrder;
    checkOutLatitude?: SortOrderInput | SortOrder;
    checkOutLongitude?: SortOrderInput | SortOrder;
    checkInIpAddress?: SortOrderInput | SortOrder;
    checkOutIpAddress?: SortOrderInput | SortOrder;
    checkInDeviceInfo?: SortOrderInput | SortOrder;
    checkOutDeviceInfo?: SortOrderInput | SortOrder;
    totalHours?: SortOrderInput | SortOrder;
    notes?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    checkInLocationName?: SortOrderInput | SortOrder;
    checkOutLocationName?: SortOrderInput | SortOrder;
    projectId?: SortOrderInput | SortOrder;
    taskId?: SortOrderInput | SortOrder;
    autoCheckout?: SortOrder;
    project?: ProjectOrderByWithRelationInput;
    task?: TaskOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    correctionRequests?: AttendanceCorrectionRequestOrderByRelationAggregateInput;
    _relevance?: AttendanceOrderByRelevanceInput;
  };

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AttendanceWhereInput | AttendanceWhereInput[];
      OR?: AttendanceWhereInput[];
      NOT?: AttendanceWhereInput | AttendanceWhereInput[];
      userId?: StringFilter<'Attendance'> | string;
      checkInTime?: DateTimeFilter<'Attendance'> | Date | string;
      checkOutTime?: DateTimeNullableFilter<'Attendance'> | Date | string | null;
      checkInLatitude?: FloatNullableFilter<'Attendance'> | number | null;
      checkInLongitude?: FloatNullableFilter<'Attendance'> | number | null;
      checkOutLatitude?: FloatNullableFilter<'Attendance'> | number | null;
      checkOutLongitude?: FloatNullableFilter<'Attendance'> | number | null;
      checkInIpAddress?: StringNullableFilter<'Attendance'> | string | null;
      checkOutIpAddress?: StringNullableFilter<'Attendance'> | string | null;
      checkInDeviceInfo?: StringNullableFilter<'Attendance'> | string | null;
      checkOutDeviceInfo?: StringNullableFilter<'Attendance'> | string | null;
      totalHours?: FloatNullableFilter<'Attendance'> | number | null;
      notes?: StringNullableFilter<'Attendance'> | string | null;
      createdAt?: DateTimeFilter<'Attendance'> | Date | string;
      updatedAt?: DateTimeFilter<'Attendance'> | Date | string;
      checkInLocationName?: StringNullableFilter<'Attendance'> | string | null;
      checkOutLocationName?: StringNullableFilter<'Attendance'> | string | null;
      projectId?: StringNullableFilter<'Attendance'> | string | null;
      taskId?: StringNullableFilter<'Attendance'> | string | null;
      autoCheckout?: BoolFilter<'Attendance'> | boolean;
      project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null;
      task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      correctionRequests?: AttendanceCorrectionRequestListRelationFilter;
    },
    'id'
  >;

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    checkInTime?: SortOrder;
    checkOutTime?: SortOrderInput | SortOrder;
    checkInLatitude?: SortOrderInput | SortOrder;
    checkInLongitude?: SortOrderInput | SortOrder;
    checkOutLatitude?: SortOrderInput | SortOrder;
    checkOutLongitude?: SortOrderInput | SortOrder;
    checkInIpAddress?: SortOrderInput | SortOrder;
    checkOutIpAddress?: SortOrderInput | SortOrder;
    checkInDeviceInfo?: SortOrderInput | SortOrder;
    checkOutDeviceInfo?: SortOrderInput | SortOrder;
    totalHours?: SortOrderInput | SortOrder;
    notes?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    checkInLocationName?: SortOrderInput | SortOrder;
    checkOutLocationName?: SortOrderInput | SortOrder;
    projectId?: SortOrderInput | SortOrder;
    taskId?: SortOrderInput | SortOrder;
    autoCheckout?: SortOrder;
    _count?: AttendanceCountOrderByAggregateInput;
    _avg?: AttendanceAvgOrderByAggregateInput;
    _max?: AttendanceMaxOrderByAggregateInput;
    _min?: AttendanceMinOrderByAggregateInput;
    _sum?: AttendanceSumOrderByAggregateInput;
  };

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[];
    OR?: AttendanceScalarWhereWithAggregatesInput[];
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Attendance'> | string;
    userId?: StringWithAggregatesFilter<'Attendance'> | string;
    checkInTime?: DateTimeWithAggregatesFilter<'Attendance'> | Date | string;
    checkOutTime?: DateTimeNullableWithAggregatesFilter<'Attendance'> | Date | string | null;
    checkInLatitude?: FloatNullableWithAggregatesFilter<'Attendance'> | number | null;
    checkInLongitude?: FloatNullableWithAggregatesFilter<'Attendance'> | number | null;
    checkOutLatitude?: FloatNullableWithAggregatesFilter<'Attendance'> | number | null;
    checkOutLongitude?: FloatNullableWithAggregatesFilter<'Attendance'> | number | null;
    checkInIpAddress?: StringNullableWithAggregatesFilter<'Attendance'> | string | null;
    checkOutIpAddress?: StringNullableWithAggregatesFilter<'Attendance'> | string | null;
    checkInDeviceInfo?: StringNullableWithAggregatesFilter<'Attendance'> | string | null;
    checkOutDeviceInfo?: StringNullableWithAggregatesFilter<'Attendance'> | string | null;
    totalHours?: FloatNullableWithAggregatesFilter<'Attendance'> | number | null;
    notes?: StringNullableWithAggregatesFilter<'Attendance'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Attendance'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Attendance'> | Date | string;
    checkInLocationName?: StringNullableWithAggregatesFilter<'Attendance'> | string | null;
    checkOutLocationName?: StringNullableWithAggregatesFilter<'Attendance'> | string | null;
    projectId?: StringNullableWithAggregatesFilter<'Attendance'> | string | null;
    taskId?: StringNullableWithAggregatesFilter<'Attendance'> | string | null;
    autoCheckout?: BoolWithAggregatesFilter<'Attendance'> | boolean;
  };

  export type AttendanceSettingsWhereInput = {
    AND?: AttendanceSettingsWhereInput | AttendanceSettingsWhereInput[];
    OR?: AttendanceSettingsWhereInput[];
    NOT?: AttendanceSettingsWhereInput | AttendanceSettingsWhereInput[];
    id?: StringFilter<'AttendanceSettings'> | string;
    userId?: StringFilter<'AttendanceSettings'> | string;
    workHoursPerDay?: FloatFilter<'AttendanceSettings'> | number;
    workDays?: StringFilter<'AttendanceSettings'> | string;
    reminderEnabled?: BoolFilter<'AttendanceSettings'> | boolean;
    reminderTime?: StringNullableFilter<'AttendanceSettings'> | string | null;
    autoCheckoutEnabled?: BoolFilter<'AttendanceSettings'> | boolean;
    autoCheckoutTime?: StringNullableFilter<'AttendanceSettings'> | string | null;
    createdAt?: DateTimeFilter<'AttendanceSettings'> | Date | string;
    updatedAt?: DateTimeFilter<'AttendanceSettings'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type AttendanceSettingsOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    workHoursPerDay?: SortOrder;
    workDays?: SortOrder;
    reminderEnabled?: SortOrder;
    reminderTime?: SortOrderInput | SortOrder;
    autoCheckoutEnabled?: SortOrder;
    autoCheckoutTime?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    _relevance?: AttendanceSettingsOrderByRelevanceInput;
  };

  export type AttendanceSettingsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      AND?: AttendanceSettingsWhereInput | AttendanceSettingsWhereInput[];
      OR?: AttendanceSettingsWhereInput[];
      NOT?: AttendanceSettingsWhereInput | AttendanceSettingsWhereInput[];
      workHoursPerDay?: FloatFilter<'AttendanceSettings'> | number;
      workDays?: StringFilter<'AttendanceSettings'> | string;
      reminderEnabled?: BoolFilter<'AttendanceSettings'> | boolean;
      reminderTime?: StringNullableFilter<'AttendanceSettings'> | string | null;
      autoCheckoutEnabled?: BoolFilter<'AttendanceSettings'> | boolean;
      autoCheckoutTime?: StringNullableFilter<'AttendanceSettings'> | string | null;
      createdAt?: DateTimeFilter<'AttendanceSettings'> | Date | string;
      updatedAt?: DateTimeFilter<'AttendanceSettings'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'userId'
  >;

  export type AttendanceSettingsOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    workHoursPerDay?: SortOrder;
    workDays?: SortOrder;
    reminderEnabled?: SortOrder;
    reminderTime?: SortOrderInput | SortOrder;
    autoCheckoutEnabled?: SortOrder;
    autoCheckoutTime?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: AttendanceSettingsCountOrderByAggregateInput;
    _avg?: AttendanceSettingsAvgOrderByAggregateInput;
    _max?: AttendanceSettingsMaxOrderByAggregateInput;
    _min?: AttendanceSettingsMinOrderByAggregateInput;
    _sum?: AttendanceSettingsSumOrderByAggregateInput;
  };

  export type AttendanceSettingsScalarWhereWithAggregatesInput = {
    AND?:
      | AttendanceSettingsScalarWhereWithAggregatesInput
      | AttendanceSettingsScalarWhereWithAggregatesInput[];
    OR?: AttendanceSettingsScalarWhereWithAggregatesInput[];
    NOT?:
      | AttendanceSettingsScalarWhereWithAggregatesInput
      | AttendanceSettingsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AttendanceSettings'> | string;
    userId?: StringWithAggregatesFilter<'AttendanceSettings'> | string;
    workHoursPerDay?: FloatWithAggregatesFilter<'AttendanceSettings'> | number;
    workDays?: StringWithAggregatesFilter<'AttendanceSettings'> | string;
    reminderEnabled?: BoolWithAggregatesFilter<'AttendanceSettings'> | boolean;
    reminderTime?: StringNullableWithAggregatesFilter<'AttendanceSettings'> | string | null;
    autoCheckoutEnabled?: BoolWithAggregatesFilter<'AttendanceSettings'> | boolean;
    autoCheckoutTime?: StringNullableWithAggregatesFilter<'AttendanceSettings'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'AttendanceSettings'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'AttendanceSettings'> | Date | string;
  };

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[];
    OR?: ActivityWhereInput[];
    NOT?: ActivityWhereInput | ActivityWhereInput[];
    id?: StringFilter<'Activity'> | string;
    action?: StringFilter<'Activity'> | string;
    entityType?: StringFilter<'Activity'> | string;
    entityId?: StringFilter<'Activity'> | string;
    description?: StringNullableFilter<'Activity'> | string | null;
    userId?: StringFilter<'Activity'> | string;
    projectId?: StringNullableFilter<'Activity'> | string | null;
    taskId?: StringNullableFilter<'Activity'> | string | null;
    createdAt?: DateTimeFilter<'Activity'> | Date | string;
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null;
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    description?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    projectId?: SortOrderInput | SortOrder;
    taskId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    project?: ProjectOrderByWithRelationInput;
    task?: TaskOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    _relevance?: ActivityOrderByRelevanceInput;
  };

  export type ActivityWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ActivityWhereInput | ActivityWhereInput[];
      OR?: ActivityWhereInput[];
      NOT?: ActivityWhereInput | ActivityWhereInput[];
      action?: StringFilter<'Activity'> | string;
      entityType?: StringFilter<'Activity'> | string;
      entityId?: StringFilter<'Activity'> | string;
      description?: StringNullableFilter<'Activity'> | string | null;
      userId?: StringFilter<'Activity'> | string;
      projectId?: StringNullableFilter<'Activity'> | string | null;
      taskId?: StringNullableFilter<'Activity'> | string | null;
      createdAt?: DateTimeFilter<'Activity'> | Date | string;
      project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null;
      task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    description?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    projectId?: SortOrderInput | SortOrder;
    taskId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: ActivityCountOrderByAggregateInput;
    _max?: ActivityMaxOrderByAggregateInput;
    _min?: ActivityMinOrderByAggregateInput;
  };

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[];
    OR?: ActivityScalarWhereWithAggregatesInput[];
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Activity'> | string;
    action?: StringWithAggregatesFilter<'Activity'> | string;
    entityType?: StringWithAggregatesFilter<'Activity'> | string;
    entityId?: StringWithAggregatesFilter<'Activity'> | string;
    description?: StringNullableWithAggregatesFilter<'Activity'> | string | null;
    userId?: StringWithAggregatesFilter<'Activity'> | string;
    projectId?: StringNullableWithAggregatesFilter<'Activity'> | string | null;
    taskId?: StringNullableWithAggregatesFilter<'Activity'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Activity'> | Date | string;
  };

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[];
    OR?: DocumentWhereInput[];
    NOT?: DocumentWhereInput | DocumentWhereInput[];
    id?: StringFilter<'Document'> | string;
    name?: StringFilter<'Document'> | string;
    description?: StringNullableFilter<'Document'> | string | null;
    fileType?: StringFilter<'Document'> | string;
    fileSize?: IntFilter<'Document'> | number;
    filePath?: StringFilter<'Document'> | string;
    userId?: StringFilter<'Document'> | string;
    createdAt?: DateTimeFilter<'Document'> | Date | string;
    updatedAt?: DateTimeFilter<'Document'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    fileType?: SortOrder;
    fileSize?: SortOrder;
    filePath?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    _relevance?: DocumentOrderByRelevanceInput;
  };

  export type DocumentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: DocumentWhereInput | DocumentWhereInput[];
      OR?: DocumentWhereInput[];
      NOT?: DocumentWhereInput | DocumentWhereInput[];
      name?: StringFilter<'Document'> | string;
      description?: StringNullableFilter<'Document'> | string | null;
      fileType?: StringFilter<'Document'> | string;
      fileSize?: IntFilter<'Document'> | number;
      filePath?: StringFilter<'Document'> | string;
      userId?: StringFilter<'Document'> | string;
      createdAt?: DateTimeFilter<'Document'> | Date | string;
      updatedAt?: DateTimeFilter<'Document'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    fileType?: SortOrder;
    fileSize?: SortOrder;
    filePath?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: DocumentCountOrderByAggregateInput;
    _avg?: DocumentAvgOrderByAggregateInput;
    _max?: DocumentMaxOrderByAggregateInput;
    _min?: DocumentMinOrderByAggregateInput;
    _sum?: DocumentSumOrderByAggregateInput;
  };

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[];
    OR?: DocumentScalarWhereWithAggregatesInput[];
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Document'> | string;
    name?: StringWithAggregatesFilter<'Document'> | string;
    description?: StringNullableWithAggregatesFilter<'Document'> | string | null;
    fileType?: StringWithAggregatesFilter<'Document'> | string;
    fileSize?: IntWithAggregatesFilter<'Document'> | number;
    filePath?: StringWithAggregatesFilter<'Document'> | string;
    userId?: StringWithAggregatesFilter<'Document'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Document'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Document'> | Date | string;
  };

  export type AttendanceCorrectionRequestWhereInput = {
    AND?: AttendanceCorrectionRequestWhereInput | AttendanceCorrectionRequestWhereInput[];
    OR?: AttendanceCorrectionRequestWhereInput[];
    NOT?: AttendanceCorrectionRequestWhereInput | AttendanceCorrectionRequestWhereInput[];
    id?: StringFilter<'AttendanceCorrectionRequest'> | string;
    attendanceId?: StringFilter<'AttendanceCorrectionRequest'> | string;
    userId?: StringFilter<'AttendanceCorrectionRequest'> | string;
    originalCheckInTime?: DateTimeFilter<'AttendanceCorrectionRequest'> | Date | string;
    originalCheckOutTime?:
      | DateTimeNullableFilter<'AttendanceCorrectionRequest'>
      | Date
      | string
      | null;
    requestedCheckInTime?: DateTimeFilter<'AttendanceCorrectionRequest'> | Date | string;
    requestedCheckOutTime?:
      | DateTimeNullableFilter<'AttendanceCorrectionRequest'>
      | Date
      | string
      | null;
    reason?: StringFilter<'AttendanceCorrectionRequest'> | string;
    status?: StringFilter<'AttendanceCorrectionRequest'> | string;
    reviewedBy?: StringNullableFilter<'AttendanceCorrectionRequest'> | string | null;
    reviewedAt?: DateTimeNullableFilter<'AttendanceCorrectionRequest'> | Date | string | null;
    reviewNotes?: StringNullableFilter<'AttendanceCorrectionRequest'> | string | null;
    createdAt?: DateTimeFilter<'AttendanceCorrectionRequest'> | Date | string;
    updatedAt?: DateTimeFilter<'AttendanceCorrectionRequest'> | Date | string;
    attendance?: XOR<AttendanceScalarRelationFilter, AttendanceWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type AttendanceCorrectionRequestOrderByWithRelationInput = {
    id?: SortOrder;
    attendanceId?: SortOrder;
    userId?: SortOrder;
    originalCheckInTime?: SortOrder;
    originalCheckOutTime?: SortOrderInput | SortOrder;
    requestedCheckInTime?: SortOrder;
    requestedCheckOutTime?: SortOrderInput | SortOrder;
    reason?: SortOrder;
    status?: SortOrder;
    reviewedBy?: SortOrderInput | SortOrder;
    reviewedAt?: SortOrderInput | SortOrder;
    reviewNotes?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    attendance?: AttendanceOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    _relevance?: AttendanceCorrectionRequestOrderByRelevanceInput;
  };

  export type AttendanceCorrectionRequestWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AttendanceCorrectionRequestWhereInput | AttendanceCorrectionRequestWhereInput[];
      OR?: AttendanceCorrectionRequestWhereInput[];
      NOT?: AttendanceCorrectionRequestWhereInput | AttendanceCorrectionRequestWhereInput[];
      attendanceId?: StringFilter<'AttendanceCorrectionRequest'> | string;
      userId?: StringFilter<'AttendanceCorrectionRequest'> | string;
      originalCheckInTime?: DateTimeFilter<'AttendanceCorrectionRequest'> | Date | string;
      originalCheckOutTime?:
        | DateTimeNullableFilter<'AttendanceCorrectionRequest'>
        | Date
        | string
        | null;
      requestedCheckInTime?: DateTimeFilter<'AttendanceCorrectionRequest'> | Date | string;
      requestedCheckOutTime?:
        | DateTimeNullableFilter<'AttendanceCorrectionRequest'>
        | Date
        | string
        | null;
      reason?: StringFilter<'AttendanceCorrectionRequest'> | string;
      status?: StringFilter<'AttendanceCorrectionRequest'> | string;
      reviewedBy?: StringNullableFilter<'AttendanceCorrectionRequest'> | string | null;
      reviewedAt?: DateTimeNullableFilter<'AttendanceCorrectionRequest'> | Date | string | null;
      reviewNotes?: StringNullableFilter<'AttendanceCorrectionRequest'> | string | null;
      createdAt?: DateTimeFilter<'AttendanceCorrectionRequest'> | Date | string;
      updatedAt?: DateTimeFilter<'AttendanceCorrectionRequest'> | Date | string;
      attendance?: XOR<AttendanceScalarRelationFilter, AttendanceWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type AttendanceCorrectionRequestOrderByWithAggregationInput = {
    id?: SortOrder;
    attendanceId?: SortOrder;
    userId?: SortOrder;
    originalCheckInTime?: SortOrder;
    originalCheckOutTime?: SortOrderInput | SortOrder;
    requestedCheckInTime?: SortOrder;
    requestedCheckOutTime?: SortOrderInput | SortOrder;
    reason?: SortOrder;
    status?: SortOrder;
    reviewedBy?: SortOrderInput | SortOrder;
    reviewedAt?: SortOrderInput | SortOrder;
    reviewNotes?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: AttendanceCorrectionRequestCountOrderByAggregateInput;
    _max?: AttendanceCorrectionRequestMaxOrderByAggregateInput;
    _min?: AttendanceCorrectionRequestMinOrderByAggregateInput;
  };

  export type AttendanceCorrectionRequestScalarWhereWithAggregatesInput = {
    AND?:
      | AttendanceCorrectionRequestScalarWhereWithAggregatesInput
      | AttendanceCorrectionRequestScalarWhereWithAggregatesInput[];
    OR?: AttendanceCorrectionRequestScalarWhereWithAggregatesInput[];
    NOT?:
      | AttendanceCorrectionRequestScalarWhereWithAggregatesInput
      | AttendanceCorrectionRequestScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AttendanceCorrectionRequest'> | string;
    attendanceId?: StringWithAggregatesFilter<'AttendanceCorrectionRequest'> | string;
    userId?: StringWithAggregatesFilter<'AttendanceCorrectionRequest'> | string;
    originalCheckInTime?:
      | DateTimeWithAggregatesFilter<'AttendanceCorrectionRequest'>
      | Date
      | string;
    originalCheckOutTime?:
      | DateTimeNullableWithAggregatesFilter<'AttendanceCorrectionRequest'>
      | Date
      | string
      | null;
    requestedCheckInTime?:
      | DateTimeWithAggregatesFilter<'AttendanceCorrectionRequest'>
      | Date
      | string;
    requestedCheckOutTime?:
      | DateTimeNullableWithAggregatesFilter<'AttendanceCorrectionRequest'>
      | Date
      | string
      | null;
    reason?: StringWithAggregatesFilter<'AttendanceCorrectionRequest'> | string;
    status?: StringWithAggregatesFilter<'AttendanceCorrectionRequest'> | string;
    reviewedBy?: StringNullableWithAggregatesFilter<'AttendanceCorrectionRequest'> | string | null;
    reviewedAt?:
      | DateTimeNullableWithAggregatesFilter<'AttendanceCorrectionRequest'>
      | Date
      | string
      | null;
    reviewNotes?: StringNullableWithAggregatesFilter<'AttendanceCorrectionRequest'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'AttendanceCorrectionRequest'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'AttendanceCorrectionRequest'> | Date | string;
  };

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[];
    OR?: CommentWhereInput[];
    NOT?: CommentWhereInput | CommentWhereInput[];
    id?: StringFilter<'Comment'> | string;
    content?: StringFilter<'Comment'> | string;
    taskId?: StringFilter<'Comment'> | string;
    userId?: StringFilter<'Comment'> | string;
    createdAt?: DateTimeFilter<'Comment'> | Date | string;
    updatedAt?: DateTimeFilter<'Comment'> | Date | string;
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder;
    content?: SortOrder;
    taskId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    task?: TaskOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    _relevance?: CommentOrderByRelevanceInput;
  };

  export type CommentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: CommentWhereInput | CommentWhereInput[];
      OR?: CommentWhereInput[];
      NOT?: CommentWhereInput | CommentWhereInput[];
      content?: StringFilter<'Comment'> | string;
      taskId?: StringFilter<'Comment'> | string;
      userId?: StringFilter<'Comment'> | string;
      createdAt?: DateTimeFilter<'Comment'> | Date | string;
      updatedAt?: DateTimeFilter<'Comment'> | Date | string;
      task?: XOR<TaskScalarRelationFilter, TaskWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder;
    content?: SortOrder;
    taskId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: CommentCountOrderByAggregateInput;
    _max?: CommentMaxOrderByAggregateInput;
    _min?: CommentMinOrderByAggregateInput;
  };

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[];
    OR?: CommentScalarWhereWithAggregatesInput[];
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Comment'> | string;
    content?: StringWithAggregatesFilter<'Comment'> | string;
    taskId?: StringWithAggregatesFilter<'Comment'> | string;
    userId?: StringWithAggregatesFilter<'Comment'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Comment'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Comment'> | Date | string;
  };

  export type TaskAttachmentWhereInput = {
    AND?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[];
    OR?: TaskAttachmentWhereInput[];
    NOT?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[];
    id?: StringFilter<'TaskAttachment'> | string;
    filename?: StringFilter<'TaskAttachment'> | string;
    fileUrl?: StringFilter<'TaskAttachment'> | string;
    fileSize?: IntFilter<'TaskAttachment'> | number;
    fileType?: StringFilter<'TaskAttachment'> | string;
    taskId?: StringFilter<'TaskAttachment'> | string;
    userId?: StringFilter<'TaskAttachment'> | string;
    createdAt?: DateTimeFilter<'TaskAttachment'> | Date | string;
    updatedAt?: DateTimeFilter<'TaskAttachment'> | Date | string;
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type TaskAttachmentOrderByWithRelationInput = {
    id?: SortOrder;
    filename?: SortOrder;
    fileUrl?: SortOrder;
    fileSize?: SortOrder;
    fileType?: SortOrder;
    taskId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    task?: TaskOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    _relevance?: TaskAttachmentOrderByRelevanceInput;
  };

  export type TaskAttachmentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[];
      OR?: TaskAttachmentWhereInput[];
      NOT?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[];
      filename?: StringFilter<'TaskAttachment'> | string;
      fileUrl?: StringFilter<'TaskAttachment'> | string;
      fileSize?: IntFilter<'TaskAttachment'> | number;
      fileType?: StringFilter<'TaskAttachment'> | string;
      taskId?: StringFilter<'TaskAttachment'> | string;
      userId?: StringFilter<'TaskAttachment'> | string;
      createdAt?: DateTimeFilter<'TaskAttachment'> | Date | string;
      updatedAt?: DateTimeFilter<'TaskAttachment'> | Date | string;
      task?: XOR<TaskScalarRelationFilter, TaskWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type TaskAttachmentOrderByWithAggregationInput = {
    id?: SortOrder;
    filename?: SortOrder;
    fileUrl?: SortOrder;
    fileSize?: SortOrder;
    fileType?: SortOrder;
    taskId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: TaskAttachmentCountOrderByAggregateInput;
    _avg?: TaskAttachmentAvgOrderByAggregateInput;
    _max?: TaskAttachmentMaxOrderByAggregateInput;
    _min?: TaskAttachmentMinOrderByAggregateInput;
    _sum?: TaskAttachmentSumOrderByAggregateInput;
  };

  export type TaskAttachmentScalarWhereWithAggregatesInput = {
    AND?:
      | TaskAttachmentScalarWhereWithAggregatesInput
      | TaskAttachmentScalarWhereWithAggregatesInput[];
    OR?: TaskAttachmentScalarWhereWithAggregatesInput[];
    NOT?:
      | TaskAttachmentScalarWhereWithAggregatesInput
      | TaskAttachmentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'TaskAttachment'> | string;
    filename?: StringWithAggregatesFilter<'TaskAttachment'> | string;
    fileUrl?: StringWithAggregatesFilter<'TaskAttachment'> | string;
    fileSize?: IntWithAggregatesFilter<'TaskAttachment'> | number;
    fileType?: StringWithAggregatesFilter<'TaskAttachment'> | string;
    taskId?: StringWithAggregatesFilter<'TaskAttachment'> | string;
    userId?: StringWithAggregatesFilter<'TaskAttachment'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'TaskAttachment'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'TaskAttachment'> | Date | string;
  };

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[];
    OR?: RoleWhereInput[];
    NOT?: RoleWhereInput | RoleWhereInput[];
    id?: StringFilter<'Role'> | string;
    name?: StringFilter<'Role'> | string;
    description?: StringNullableFilter<'Role'> | string | null;
    color?: StringNullableFilter<'Role'> | string | null;
    createdAt?: DateTimeFilter<'Role'> | Date | string;
    updatedAt?: DateTimeFilter<'Role'> | Date | string;
    permissions?: RolePermissionListRelationFilter;
  };

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    color?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    permissions?: RolePermissionOrderByRelationAggregateInput;
    _relevance?: RoleOrderByRelevanceInput;
  };

  export type RoleWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      name?: string;
      AND?: RoleWhereInput | RoleWhereInput[];
      OR?: RoleWhereInput[];
      NOT?: RoleWhereInput | RoleWhereInput[];
      description?: StringNullableFilter<'Role'> | string | null;
      color?: StringNullableFilter<'Role'> | string | null;
      createdAt?: DateTimeFilter<'Role'> | Date | string;
      updatedAt?: DateTimeFilter<'Role'> | Date | string;
      permissions?: RolePermissionListRelationFilter;
    },
    'id' | 'name'
  >;

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    color?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: RoleCountOrderByAggregateInput;
    _max?: RoleMaxOrderByAggregateInput;
    _min?: RoleMinOrderByAggregateInput;
  };

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[];
    OR?: RoleScalarWhereWithAggregatesInput[];
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Role'> | string;
    name?: StringWithAggregatesFilter<'Role'> | string;
    description?: StringNullableWithAggregatesFilter<'Role'> | string | null;
    color?: StringNullableWithAggregatesFilter<'Role'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Role'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Role'> | Date | string;
  };

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[];
    OR?: PermissionWhereInput[];
    NOT?: PermissionWhereInput | PermissionWhereInput[];
    id?: StringFilter<'Permission'> | string;
    name?: StringFilter<'Permission'> | string;
    description?: StringNullableFilter<'Permission'> | string | null;
    category?: StringNullableFilter<'Permission'> | string | null;
    createdAt?: DateTimeFilter<'Permission'> | Date | string;
    updatedAt?: DateTimeFilter<'Permission'> | Date | string;
    roles?: RolePermissionListRelationFilter;
  };

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    category?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    roles?: RolePermissionOrderByRelationAggregateInput;
    _relevance?: PermissionOrderByRelevanceInput;
  };

  export type PermissionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      name?: string;
      AND?: PermissionWhereInput | PermissionWhereInput[];
      OR?: PermissionWhereInput[];
      NOT?: PermissionWhereInput | PermissionWhereInput[];
      description?: StringNullableFilter<'Permission'> | string | null;
      category?: StringNullableFilter<'Permission'> | string | null;
      createdAt?: DateTimeFilter<'Permission'> | Date | string;
      updatedAt?: DateTimeFilter<'Permission'> | Date | string;
      roles?: RolePermissionListRelationFilter;
    },
    'id' | 'name'
  >;

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    category?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: PermissionCountOrderByAggregateInput;
    _max?: PermissionMaxOrderByAggregateInput;
    _min?: PermissionMinOrderByAggregateInput;
  };

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[];
    OR?: PermissionScalarWhereWithAggregatesInput[];
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Permission'> | string;
    name?: StringWithAggregatesFilter<'Permission'> | string;
    description?: StringNullableWithAggregatesFilter<'Permission'> | string | null;
    category?: StringNullableWithAggregatesFilter<'Permission'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Permission'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Permission'> | Date | string;
  };

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[];
    OR?: RolePermissionWhereInput[];
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[];
    id?: StringFilter<'RolePermission'> | string;
    roleId?: StringFilter<'RolePermission'> | string;
    permissionId?: StringFilter<'RolePermission'> | string;
    createdAt?: DateTimeFilter<'RolePermission'> | Date | string;
    updatedAt?: DateTimeFilter<'RolePermission'> | Date | string;
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>;
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>;
  };

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder;
    roleId?: SortOrder;
    permissionId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    permission?: PermissionOrderByWithRelationInput;
    role?: RoleOrderByWithRelationInput;
    _relevance?: RolePermissionOrderByRelevanceInput;
  };

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput;
      AND?: RolePermissionWhereInput | RolePermissionWhereInput[];
      OR?: RolePermissionWhereInput[];
      NOT?: RolePermissionWhereInput | RolePermissionWhereInput[];
      roleId?: StringFilter<'RolePermission'> | string;
      permissionId?: StringFilter<'RolePermission'> | string;
      createdAt?: DateTimeFilter<'RolePermission'> | Date | string;
      updatedAt?: DateTimeFilter<'RolePermission'> | Date | string;
      permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>;
      role?: XOR<RoleScalarRelationFilter, RoleWhereInput>;
    },
    'id' | 'roleId_permissionId'
  >;

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder;
    roleId?: SortOrder;
    permissionId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: RolePermissionCountOrderByAggregateInput;
    _max?: RolePermissionMaxOrderByAggregateInput;
    _min?: RolePermissionMinOrderByAggregateInput;
  };

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?:
      | RolePermissionScalarWhereWithAggregatesInput
      | RolePermissionScalarWhereWithAggregatesInput[];
    OR?: RolePermissionScalarWhereWithAggregatesInput[];
    NOT?:
      | RolePermissionScalarWhereWithAggregatesInput
      | RolePermissionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'RolePermission'> | string;
    roleId?: StringWithAggregatesFilter<'RolePermission'> | string;
    permissionId?: StringWithAggregatesFilter<'RolePermission'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'RolePermission'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'RolePermission'> | Date | string;
  };

  export type UserCreateInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    activities?: ActivityCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsCreateNestedOneWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    projects?: ProjectCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsUncheckedCreateNestedOneWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    activities?: ActivityUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUpdateOneWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    projects?: ProjectUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUncheckedUpdateOneWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    projects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type AccountCreateInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    user: UserCreateNestedOneWithoutAccountsInput;
  };

  export type AccountUncheckedCreateInput = {
    id?: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput;
  };

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountCreateManyInput = {
    id?: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SessionCreateInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
    user: UserCreateNestedOneWithoutSessionsInput;
  };

  export type SessionUncheckedCreateInput = {
    id?: string;
    sessionToken: string;
    userId: string;
    expires: Date | string;
  };

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput;
  };

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionCreateManyInput = {
    id?: string;
    sessionToken: string;
    userId: string;
    expires: Date | string;
  };

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenCreateInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenCreateManyInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProjectCreateInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    activities?: ActivityCreateNestedManyWithoutProjectInput;
    attendances?: AttendanceCreateNestedManyWithoutProjectInput;
    events?: EventCreateNestedManyWithoutProjectInput;
    createdBy: UserCreateNestedOneWithoutProjectsInput;
    statuses?: ProjectStatusCreateNestedManyWithoutProjectInput;
    tasks?: TaskCreateNestedManyWithoutProjectInput;
    teamMembers?: TeamMemberCreateNestedManyWithoutProjectInput;
  };

  export type ProjectUncheckedCreateInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdById: string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutProjectInput;
    events?: EventUncheckedCreateNestedManyWithoutProjectInput;
    statuses?: ProjectStatusUncheckedCreateNestedManyWithoutProjectInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput;
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutProjectInput;
  };

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    activities?: ActivityUpdateManyWithoutProjectNestedInput;
    attendances?: AttendanceUpdateManyWithoutProjectNestedInput;
    events?: EventUpdateManyWithoutProjectNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutProjectsNestedInput;
    statuses?: ProjectStatusUpdateManyWithoutProjectNestedInput;
    tasks?: TaskUpdateManyWithoutProjectNestedInput;
    teamMembers?: TeamMemberUpdateManyWithoutProjectNestedInput;
  };

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput;
    attendances?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput;
    events?: EventUncheckedUpdateManyWithoutProjectNestedInput;
    statuses?: ProjectStatusUncheckedUpdateManyWithoutProjectNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput;
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutProjectNestedInput;
  };

  export type ProjectCreateManyInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdById: string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
  };

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
  };

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
  };

  export type ProjectStatusCreateInput = {
    id?: string;
    name: string;
    color?: string | null;
    description?: string | null;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    order?: number;
    isCompletedStatus?: boolean;
    project: ProjectCreateNestedOneWithoutStatusesInput;
    tasks?: TaskCreateNestedManyWithoutStatusInput;
  };

  export type ProjectStatusUncheckedCreateInput = {
    id?: string;
    name: string;
    color?: string | null;
    description?: string | null;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    order?: number;
    projectId: string;
    isCompletedStatus?: boolean;
    tasks?: TaskUncheckedCreateNestedManyWithoutStatusInput;
  };

  export type ProjectStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: IntFieldUpdateOperationsInput | number;
    isCompletedStatus?: BoolFieldUpdateOperationsInput | boolean;
    project?: ProjectUpdateOneRequiredWithoutStatusesNestedInput;
    tasks?: TaskUpdateManyWithoutStatusNestedInput;
  };

  export type ProjectStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: IntFieldUpdateOperationsInput | number;
    projectId?: StringFieldUpdateOperationsInput | string;
    isCompletedStatus?: BoolFieldUpdateOperationsInput | boolean;
    tasks?: TaskUncheckedUpdateManyWithoutStatusNestedInput;
  };

  export type ProjectStatusCreateManyInput = {
    id?: string;
    name: string;
    color?: string | null;
    description?: string | null;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    order?: number;
    projectId: string;
    isCompletedStatus?: boolean;
  };

  export type ProjectStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: IntFieldUpdateOperationsInput | number;
    isCompletedStatus?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type ProjectStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: IntFieldUpdateOperationsInput | number;
    projectId?: StringFieldUpdateOperationsInput | string;
    isCompletedStatus?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type TaskCreateInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceCreateNestedManyWithoutTaskInput;
    comments?: CommentCreateNestedManyWithoutTaskInput;
    parent?: TaskCreateNestedOneWithoutSubtasksInput;
    subtasks?: TaskCreateNestedManyWithoutParentInput;
    project: ProjectCreateNestedOneWithoutTasksInput;
    status?: ProjectStatusCreateNestedOneWithoutTasksInput;
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput;
  };

  export type TaskUncheckedCreateInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    projectId: string;
    parentId?: string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    statusId?: string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityUncheckedCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTaskInput;
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput;
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentInput;
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput;
  };

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUpdateManyWithoutTaskNestedInput;
    comments?: CommentUpdateManyWithoutTaskNestedInput;
    parent?: TaskUpdateOneWithoutSubtasksNestedInput;
    subtasks?: TaskUpdateManyWithoutParentNestedInput;
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput;
    status?: ProjectStatusUpdateOneWithoutTasksNestedInput;
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput;
  };

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    projectId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    statusId?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUncheckedUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUncheckedUpdateManyWithoutTaskNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput;
    subtasks?: TaskUncheckedUpdateManyWithoutParentNestedInput;
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput;
  };

  export type TaskCreateManyInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    projectId: string;
    parentId?: string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    statusId?: string | null;
    timeSpent?: number | null;
    completed?: boolean;
  };

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    projectId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    statusId?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type TaskAssigneeCreateInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    task: TaskCreateNestedOneWithoutAssigneesInput;
    user: UserCreateNestedOneWithoutTaskAssignmentsInput;
  };

  export type TaskAssigneeUncheckedCreateInput = {
    id?: string;
    taskId: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TaskAssigneeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    task?: TaskUpdateOneRequiredWithoutAssigneesNestedInput;
    user?: UserUpdateOneRequiredWithoutTaskAssignmentsNestedInput;
  };

  export type TaskAssigneeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    taskId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TaskAssigneeCreateManyInput = {
    id?: string;
    taskId: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TaskAssigneeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TaskAssigneeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    taskId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberCreateInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    project: ProjectCreateNestedOneWithoutTeamMembersInput;
    user: UserCreateNestedOneWithoutTeamsInput;
  };

  export type TeamMemberUncheckedCreateInput = {
    id?: string;
    projectId: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    project?: ProjectUpdateOneRequiredWithoutTeamMembersNestedInput;
    user?: UserUpdateOneRequiredWithoutTeamsNestedInput;
  };

  export type TeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    projectId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberCreateManyInput = {
    id?: string;
    projectId: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    projectId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventCreateInput = {
    id?: string;
    title: string;
    description?: string | null;
    date: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    project: ProjectCreateNestedOneWithoutEventsInput;
  };

  export type EventUncheckedCreateInput = {
    id?: string;
    title: string;
    description?: string | null;
    date: Date | string;
    projectId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    project?: ProjectUpdateOneRequiredWithoutEventsNestedInput;
  };

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    projectId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventCreateManyInput = {
    id?: string;
    title: string;
    description?: string | null;
    date: Date | string;
    projectId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    projectId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AttendanceCreateInput = {
    id?: string;
    checkInTime?: Date | string;
    checkOutTime?: Date | string | null;
    checkInLatitude?: number | null;
    checkInLongitude?: number | null;
    checkOutLatitude?: number | null;
    checkOutLongitude?: number | null;
    checkInIpAddress?: string | null;
    checkOutIpAddress?: string | null;
    checkInDeviceInfo?: string | null;
    checkOutDeviceInfo?: string | null;
    totalHours?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    checkInLocationName?: string | null;
    checkOutLocationName?: string | null;
    autoCheckout?: boolean;
    project?: ProjectCreateNestedOneWithoutAttendancesInput;
    task?: TaskCreateNestedOneWithoutAttendancesInput;
    user: UserCreateNestedOneWithoutAttendanceRecordsInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutAttendanceInput;
  };

  export type AttendanceUncheckedCreateInput = {
    id?: string;
    userId: string;
    checkInTime?: Date | string;
    checkOutTime?: Date | string | null;
    checkInLatitude?: number | null;
    checkInLongitude?: number | null;
    checkOutLatitude?: number | null;
    checkOutLongitude?: number | null;
    checkInIpAddress?: string | null;
    checkOutIpAddress?: string | null;
    checkInDeviceInfo?: string | null;
    checkOutDeviceInfo?: string | null;
    totalHours?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    checkInLocationName?: string | null;
    checkOutLocationName?: string | null;
    projectId?: string | null;
    taskId?: string | null;
    autoCheckout?: boolean;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutAttendanceInput;
  };

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    checkInLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkInDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkInLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckout?: BoolFieldUpdateOperationsInput | boolean;
    project?: ProjectUpdateOneWithoutAttendancesNestedInput;
    task?: TaskUpdateOneWithoutAttendancesNestedInput;
    user?: UserUpdateOneRequiredWithoutAttendanceRecordsNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutAttendanceNestedInput;
  };

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    checkInLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkInDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkInLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    projectId?: NullableStringFieldUpdateOperationsInput | string | null;
    taskId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckout?: BoolFieldUpdateOperationsInput | boolean;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutAttendanceNestedInput;
  };

  export type AttendanceCreateManyInput = {
    id?: string;
    userId: string;
    checkInTime?: Date | string;
    checkOutTime?: Date | string | null;
    checkInLatitude?: number | null;
    checkInLongitude?: number | null;
    checkOutLatitude?: number | null;
    checkOutLongitude?: number | null;
    checkInIpAddress?: string | null;
    checkOutIpAddress?: string | null;
    checkInDeviceInfo?: string | null;
    checkOutDeviceInfo?: string | null;
    totalHours?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    checkInLocationName?: string | null;
    checkOutLocationName?: string | null;
    projectId?: string | null;
    taskId?: string | null;
    autoCheckout?: boolean;
  };

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    checkInLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkInDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkInLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckout?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    checkInLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkInDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkInLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    projectId?: NullableStringFieldUpdateOperationsInput | string | null;
    taskId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckout?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type AttendanceSettingsCreateInput = {
    id?: string;
    workHoursPerDay?: number;
    workDays?: string;
    reminderEnabled?: boolean;
    reminderTime?: string | null;
    autoCheckoutEnabled?: boolean;
    autoCheckoutTime?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutAttendanceSettingsInput;
  };

  export type AttendanceSettingsUncheckedCreateInput = {
    id?: string;
    userId: string;
    workHoursPerDay?: number;
    workDays?: string;
    reminderEnabled?: boolean;
    reminderTime?: string | null;
    autoCheckoutEnabled?: boolean;
    autoCheckoutTime?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AttendanceSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    workHoursPerDay?: FloatFieldUpdateOperationsInput | number;
    workDays?: StringFieldUpdateOperationsInput | string;
    reminderEnabled?: BoolFieldUpdateOperationsInput | boolean;
    reminderTime?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckoutEnabled?: BoolFieldUpdateOperationsInput | boolean;
    autoCheckoutTime?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutAttendanceSettingsNestedInput;
  };

  export type AttendanceSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    workHoursPerDay?: FloatFieldUpdateOperationsInput | number;
    workDays?: StringFieldUpdateOperationsInput | string;
    reminderEnabled?: BoolFieldUpdateOperationsInput | boolean;
    reminderTime?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckoutEnabled?: BoolFieldUpdateOperationsInput | boolean;
    autoCheckoutTime?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AttendanceSettingsCreateManyInput = {
    id?: string;
    userId: string;
    workHoursPerDay?: number;
    workDays?: string;
    reminderEnabled?: boolean;
    reminderTime?: string | null;
    autoCheckoutEnabled?: boolean;
    autoCheckoutTime?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AttendanceSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    workHoursPerDay?: FloatFieldUpdateOperationsInput | number;
    workDays?: StringFieldUpdateOperationsInput | string;
    reminderEnabled?: BoolFieldUpdateOperationsInput | boolean;
    reminderTime?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckoutEnabled?: BoolFieldUpdateOperationsInput | boolean;
    autoCheckoutTime?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AttendanceSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    workHoursPerDay?: FloatFieldUpdateOperationsInput | number;
    workDays?: StringFieldUpdateOperationsInput | string;
    reminderEnabled?: BoolFieldUpdateOperationsInput | boolean;
    reminderTime?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckoutEnabled?: BoolFieldUpdateOperationsInput | boolean;
    autoCheckoutTime?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ActivityCreateInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    description?: string | null;
    createdAt?: Date | string;
    project?: ProjectCreateNestedOneWithoutActivitiesInput;
    task?: TaskCreateNestedOneWithoutActivitiesInput;
    user: UserCreateNestedOneWithoutActivitiesInput;
  };

  export type ActivityUncheckedCreateInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    description?: string | null;
    userId: string;
    projectId?: string | null;
    taskId?: string | null;
    createdAt?: Date | string;
  };

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    project?: ProjectUpdateOneWithoutActivitiesNestedInput;
    task?: TaskUpdateOneWithoutActivitiesNestedInput;
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput;
  };

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
    projectId?: NullableStringFieldUpdateOperationsInput | string | null;
    taskId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ActivityCreateManyInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    description?: string | null;
    userId: string;
    projectId?: string | null;
    taskId?: string | null;
    createdAt?: Date | string;
  };

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
    projectId?: NullableStringFieldUpdateOperationsInput | string | null;
    taskId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    fileType: string;
    fileSize: number;
    filePath: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutDocumentsInput;
  };

  export type DocumentUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    fileType: string;
    fileSize: number;
    filePath: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    fileType?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    filePath?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput;
  };

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    fileType?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    filePath?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    fileType: string;
    fileSize: number;
    filePath: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    fileType?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    filePath?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    fileType?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    filePath?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AttendanceCorrectionRequestCreateInput = {
    id?: string;
    originalCheckInTime: Date | string;
    originalCheckOutTime?: Date | string | null;
    requestedCheckInTime: Date | string;
    requestedCheckOutTime?: Date | string | null;
    reason: string;
    status?: string;
    reviewedBy?: string | null;
    reviewedAt?: Date | string | null;
    reviewNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    attendance: AttendanceCreateNestedOneWithoutCorrectionRequestsInput;
    user: UserCreateNestedOneWithoutCorrectionRequestsInput;
  };

  export type AttendanceCorrectionRequestUncheckedCreateInput = {
    id?: string;
    attendanceId: string;
    userId: string;
    originalCheckInTime: Date | string;
    originalCheckOutTime?: Date | string | null;
    requestedCheckInTime: Date | string;
    requestedCheckOutTime?: Date | string | null;
    reason: string;
    status?: string;
    reviewedBy?: string | null;
    reviewedAt?: Date | string | null;
    reviewNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AttendanceCorrectionRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    originalCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    originalCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requestedCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    requestedCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    attendance?: AttendanceUpdateOneRequiredWithoutCorrectionRequestsNestedInput;
    user?: UserUpdateOneRequiredWithoutCorrectionRequestsNestedInput;
  };

  export type AttendanceCorrectionRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attendanceId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    originalCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    originalCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requestedCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    requestedCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AttendanceCorrectionRequestCreateManyInput = {
    id?: string;
    attendanceId: string;
    userId: string;
    originalCheckInTime: Date | string;
    originalCheckOutTime?: Date | string | null;
    requestedCheckInTime: Date | string;
    requestedCheckOutTime?: Date | string | null;
    reason: string;
    status?: string;
    reviewedBy?: string | null;
    reviewedAt?: Date | string | null;
    reviewNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AttendanceCorrectionRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    originalCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    originalCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requestedCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    requestedCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AttendanceCorrectionRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attendanceId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    originalCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    originalCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requestedCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    requestedCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentCreateInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    task: TaskCreateNestedOneWithoutCommentsInput;
    user: UserCreateNestedOneWithoutCommentsInput;
  };

  export type CommentUncheckedCreateInput = {
    id?: string;
    content: string;
    taskId: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput;
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput;
  };

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    taskId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentCreateManyInput = {
    id?: string;
    content: string;
    taskId: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    taskId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TaskAttachmentCreateInput = {
    id?: string;
    filename: string;
    fileUrl: string;
    fileSize: number;
    fileType: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    task: TaskCreateNestedOneWithoutAttachmentsInput;
    user: UserCreateNestedOneWithoutTaskAttachmentsInput;
  };

  export type TaskAttachmentUncheckedCreateInput = {
    id?: string;
    filename: string;
    fileUrl: string;
    fileSize: number;
    fileType: string;
    taskId: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TaskAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    task?: TaskUpdateOneRequiredWithoutAttachmentsNestedInput;
    user?: UserUpdateOneRequiredWithoutTaskAttachmentsNestedInput;
  };

  export type TaskAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    taskId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TaskAttachmentCreateManyInput = {
    id?: string;
    filename: string;
    fileUrl: string;
    fileSize: number;
    fileType: string;
    taskId: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TaskAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TaskAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    taskId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    color?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput;
  };

  export type RoleUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    color?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput;
  };

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput;
  };

  export type RoleCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    color?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PermissionCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    category?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    roles?: RolePermissionCreateNestedManyWithoutPermissionInput;
  };

  export type PermissionUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    category?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    roles?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput;
  };

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    roles?: RolePermissionUpdateManyWithoutPermissionNestedInput;
  };

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    roles?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput;
  };

  export type PermissionCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    category?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RolePermissionCreateInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    permission: PermissionCreateNestedOneWithoutRolesInput;
    role: RoleCreateNestedOneWithoutPermissionsInput;
  };

  export type RolePermissionUncheckedCreateInput = {
    id?: string;
    roleId: string;
    permissionId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RolePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput;
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput;
  };

  export type RolePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleId?: StringFieldUpdateOperationsInput | string;
    permissionId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RolePermissionCreateManyInput = {
    id?: string;
    roleId: string;
    permissionId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RolePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleId?: StringFieldUpdateOperationsInput | string;
    permissionId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[];
    notIn?: string[];
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | null;
    notIn?: Date[] | string[] | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[];
    notIn?: Date[] | string[];
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type AccountListRelationFilter = {
    every?: AccountWhereInput;
    some?: AccountWhereInput;
    none?: AccountWhereInput;
  };

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput;
    some?: ActivityWhereInput;
    none?: ActivityWhereInput;
  };

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput;
    some?: AttendanceWhereInput;
    none?: AttendanceWhereInput;
  };

  export type AttendanceCorrectionRequestListRelationFilter = {
    every?: AttendanceCorrectionRequestWhereInput;
    some?: AttendanceCorrectionRequestWhereInput;
    none?: AttendanceCorrectionRequestWhereInput;
  };

  export type AttendanceSettingsNullableScalarRelationFilter = {
    is?: AttendanceSettingsWhereInput | null;
    isNot?: AttendanceSettingsWhereInput | null;
  };

  export type CommentListRelationFilter = {
    every?: CommentWhereInput;
    some?: CommentWhereInput;
    none?: CommentWhereInput;
  };

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput;
    some?: DocumentWhereInput;
    none?: DocumentWhereInput;
  };

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput;
    some?: ProjectWhereInput;
    none?: ProjectWhereInput;
  };

  export type SessionListRelationFilter = {
    every?: SessionWhereInput;
    some?: SessionWhereInput;
    none?: SessionWhereInput;
  };

  export type TaskAssigneeListRelationFilter = {
    every?: TaskAssigneeWhereInput;
    some?: TaskAssigneeWhereInput;
    none?: TaskAssigneeWhereInput;
  };

  export type TaskAttachmentListRelationFilter = {
    every?: TaskAttachmentWhereInput;
    some?: TaskAttachmentWhereInput;
    none?: TaskAttachmentWhereInput;
  };

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput;
    some?: TeamMemberWhereInput;
    none?: TeamMemberWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AttendanceCorrectionRequestOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TaskAssigneeOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TaskAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    password?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLogin?: SortOrder;
    bio?: SortOrder;
    department?: SortOrder;
    jobTitle?: SortOrder;
    location?: SortOrder;
    phone?: SortOrder;
    skills?: SortOrder;
    active?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    password?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLogin?: SortOrder;
    bio?: SortOrder;
    department?: SortOrder;
    jobTitle?: SortOrder;
    location?: SortOrder;
    phone?: SortOrder;
    skills?: SortOrder;
    active?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    password?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLogin?: SortOrder;
    bio?: SortOrder;
    department?: SortOrder;
    jobTitle?: SortOrder;
    location?: SortOrder;
    phone?: SortOrder;
    skills?: SortOrder;
    active?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[];
    notIn?: string[];
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | null;
    notIn?: Date[] | string[] | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[];
    notIn?: Date[] | string[];
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type AccountOrderByRelevanceInput = {
    fields: AccountOrderByRelevanceFieldEnum | AccountOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string;
    providerAccountId: string;
  };

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder;
  };

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type SessionOrderByRelevanceInput = {
    fields: SessionOrderByRelevanceFieldEnum | SessionOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenOrderByRelevanceInput = {
    fields:
      | VerificationTokenOrderByRelevanceFieldEnum
      | VerificationTokenOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string;
    token: string;
  };

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type EventListRelationFilter = {
    every?: EventWhereInput;
    some?: EventWhereInput;
    none?: EventWhereInput;
  };

  export type ProjectStatusListRelationFilter = {
    every?: ProjectStatusWhereInput;
    some?: ProjectStatusWhereInput;
    none?: ProjectStatusWhereInput;
  };

  export type TaskListRelationFilter = {
    every?: TaskWhereInput;
    some?: TaskWhereInput;
    none?: TaskWhereInput;
  };

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ProjectStatusOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ProjectOrderByRelevanceInput = {
    fields: ProjectOrderByRelevanceFieldEnum | ProjectOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdById?: SortOrder;
    dueDate?: SortOrder;
    estimatedTime?: SortOrder;
    totalTimeSpent?: SortOrder;
  };

  export type ProjectAvgOrderByAggregateInput = {
    estimatedTime?: SortOrder;
    totalTimeSpent?: SortOrder;
  };

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdById?: SortOrder;
    dueDate?: SortOrder;
    estimatedTime?: SortOrder;
    totalTimeSpent?: SortOrder;
  };

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdById?: SortOrder;
    dueDate?: SortOrder;
    estimatedTime?: SortOrder;
    totalTimeSpent?: SortOrder;
  };

  export type ProjectSumOrderByAggregateInput = {
    estimatedTime?: SortOrder;
    totalTimeSpent?: SortOrder;
  };

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput;
    isNot?: ProjectWhereInput;
  };

  export type ProjectStatusOrderByRelevanceInput = {
    fields: ProjectStatusOrderByRelevanceFieldEnum | ProjectStatusOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ProjectStatusProjectIdNameCompoundUniqueInput = {
    projectId: string;
    name: string;
  };

  export type ProjectStatusCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    color?: SortOrder;
    description?: SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    order?: SortOrder;
    projectId?: SortOrder;
    isCompletedStatus?: SortOrder;
  };

  export type ProjectStatusAvgOrderByAggregateInput = {
    order?: SortOrder;
  };

  export type ProjectStatusMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    color?: SortOrder;
    description?: SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    order?: SortOrder;
    projectId?: SortOrder;
    isCompletedStatus?: SortOrder;
  };

  export type ProjectStatusMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    color?: SortOrder;
    description?: SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    order?: SortOrder;
    projectId?: SortOrder;
    isCompletedStatus?: SortOrder;
  };

  export type ProjectStatusSumOrderByAggregateInput = {
    order?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type TaskNullableScalarRelationFilter = {
    is?: TaskWhereInput | null;
    isNot?: TaskWhereInput | null;
  };

  export type ProjectStatusNullableScalarRelationFilter = {
    is?: ProjectStatusWhereInput | null;
    isNot?: ProjectStatusWhereInput | null;
  };

  export type TaskOrderByRelevanceInput = {
    fields: TaskOrderByRelevanceFieldEnum | TaskOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    priority?: SortOrder;
    dueDate?: SortOrder;
    projectId?: SortOrder;
    parentId?: SortOrder;
    order?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    endDate?: SortOrder;
    estimatedTime?: SortOrder;
    startDate?: SortOrder;
    statusId?: SortOrder;
    timeSpent?: SortOrder;
    completed?: SortOrder;
  };

  export type TaskAvgOrderByAggregateInput = {
    order?: SortOrder;
    estimatedTime?: SortOrder;
    timeSpent?: SortOrder;
  };

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    priority?: SortOrder;
    dueDate?: SortOrder;
    projectId?: SortOrder;
    parentId?: SortOrder;
    order?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    endDate?: SortOrder;
    estimatedTime?: SortOrder;
    startDate?: SortOrder;
    statusId?: SortOrder;
    timeSpent?: SortOrder;
    completed?: SortOrder;
  };

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    priority?: SortOrder;
    dueDate?: SortOrder;
    projectId?: SortOrder;
    parentId?: SortOrder;
    order?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    endDate?: SortOrder;
    estimatedTime?: SortOrder;
    startDate?: SortOrder;
    statusId?: SortOrder;
    timeSpent?: SortOrder;
    completed?: SortOrder;
  };

  export type TaskSumOrderByAggregateInput = {
    order?: SortOrder;
    estimatedTime?: SortOrder;
    timeSpent?: SortOrder;
  };

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput;
    isNot?: TaskWhereInput;
  };

  export type TaskAssigneeOrderByRelevanceInput = {
    fields: TaskAssigneeOrderByRelevanceFieldEnum | TaskAssigneeOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type TaskAssigneeTaskIdUserIdCompoundUniqueInput = {
    taskId: string;
    userId: string;
  };

  export type TaskAssigneeCountOrderByAggregateInput = {
    id?: SortOrder;
    taskId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TaskAssigneeMaxOrderByAggregateInput = {
    id?: SortOrder;
    taskId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TaskAssigneeMinOrderByAggregateInput = {
    id?: SortOrder;
    taskId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TeamMemberOrderByRelevanceInput = {
    fields: TeamMemberOrderByRelevanceFieldEnum | TeamMemberOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type TeamMemberProjectIdUserIdCompoundUniqueInput = {
    projectId: string;
    userId: string;
  };

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder;
    projectId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder;
    projectId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder;
    projectId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EventOrderByRelevanceInput = {
    fields: EventOrderByRelevanceFieldEnum | EventOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    date?: SortOrder;
    projectId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    date?: SortOrder;
    projectId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    date?: SortOrder;
    projectId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null;
    isNot?: ProjectWhereInput | null;
  };

  export type AttendanceOrderByRelevanceInput = {
    fields: AttendanceOrderByRelevanceFieldEnum | AttendanceOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    checkInTime?: SortOrder;
    checkOutTime?: SortOrder;
    checkInLatitude?: SortOrder;
    checkInLongitude?: SortOrder;
    checkOutLatitude?: SortOrder;
    checkOutLongitude?: SortOrder;
    checkInIpAddress?: SortOrder;
    checkOutIpAddress?: SortOrder;
    checkInDeviceInfo?: SortOrder;
    checkOutDeviceInfo?: SortOrder;
    totalHours?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    checkInLocationName?: SortOrder;
    checkOutLocationName?: SortOrder;
    projectId?: SortOrder;
    taskId?: SortOrder;
    autoCheckout?: SortOrder;
  };

  export type AttendanceAvgOrderByAggregateInput = {
    checkInLatitude?: SortOrder;
    checkInLongitude?: SortOrder;
    checkOutLatitude?: SortOrder;
    checkOutLongitude?: SortOrder;
    totalHours?: SortOrder;
  };

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    checkInTime?: SortOrder;
    checkOutTime?: SortOrder;
    checkInLatitude?: SortOrder;
    checkInLongitude?: SortOrder;
    checkOutLatitude?: SortOrder;
    checkOutLongitude?: SortOrder;
    checkInIpAddress?: SortOrder;
    checkOutIpAddress?: SortOrder;
    checkInDeviceInfo?: SortOrder;
    checkOutDeviceInfo?: SortOrder;
    totalHours?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    checkInLocationName?: SortOrder;
    checkOutLocationName?: SortOrder;
    projectId?: SortOrder;
    taskId?: SortOrder;
    autoCheckout?: SortOrder;
  };

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    checkInTime?: SortOrder;
    checkOutTime?: SortOrder;
    checkInLatitude?: SortOrder;
    checkInLongitude?: SortOrder;
    checkOutLatitude?: SortOrder;
    checkOutLongitude?: SortOrder;
    checkInIpAddress?: SortOrder;
    checkOutIpAddress?: SortOrder;
    checkInDeviceInfo?: SortOrder;
    checkOutDeviceInfo?: SortOrder;
    totalHours?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    checkInLocationName?: SortOrder;
    checkOutLocationName?: SortOrder;
    projectId?: SortOrder;
    taskId?: SortOrder;
    autoCheckout?: SortOrder;
  };

  export type AttendanceSumOrderByAggregateInput = {
    checkInLatitude?: SortOrder;
    checkInLongitude?: SortOrder;
    checkOutLatitude?: SortOrder;
    checkOutLongitude?: SortOrder;
    totalHours?: SortOrder;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type AttendanceSettingsOrderByRelevanceInput = {
    fields:
      | AttendanceSettingsOrderByRelevanceFieldEnum
      | AttendanceSettingsOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type AttendanceSettingsCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    workHoursPerDay?: SortOrder;
    workDays?: SortOrder;
    reminderEnabled?: SortOrder;
    reminderTime?: SortOrder;
    autoCheckoutEnabled?: SortOrder;
    autoCheckoutTime?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AttendanceSettingsAvgOrderByAggregateInput = {
    workHoursPerDay?: SortOrder;
  };

  export type AttendanceSettingsMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    workHoursPerDay?: SortOrder;
    workDays?: SortOrder;
    reminderEnabled?: SortOrder;
    reminderTime?: SortOrder;
    autoCheckoutEnabled?: SortOrder;
    autoCheckoutTime?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AttendanceSettingsMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    workHoursPerDay?: SortOrder;
    workDays?: SortOrder;
    reminderEnabled?: SortOrder;
    reminderTime?: SortOrder;
    autoCheckoutEnabled?: SortOrder;
    autoCheckoutTime?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AttendanceSettingsSumOrderByAggregateInput = {
    workHoursPerDay?: SortOrder;
  };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type ActivityOrderByRelevanceInput = {
    fields: ActivityOrderByRelevanceFieldEnum | ActivityOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    description?: SortOrder;
    userId?: SortOrder;
    projectId?: SortOrder;
    taskId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    description?: SortOrder;
    userId?: SortOrder;
    projectId?: SortOrder;
    taskId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    description?: SortOrder;
    userId?: SortOrder;
    projectId?: SortOrder;
    taskId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type DocumentOrderByRelevanceInput = {
    fields: DocumentOrderByRelevanceFieldEnum | DocumentOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    fileType?: SortOrder;
    fileSize?: SortOrder;
    filePath?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder;
  };

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    fileType?: SortOrder;
    fileSize?: SortOrder;
    filePath?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    fileType?: SortOrder;
    fileSize?: SortOrder;
    filePath?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder;
  };

  export type AttendanceScalarRelationFilter = {
    is?: AttendanceWhereInput;
    isNot?: AttendanceWhereInput;
  };

  export type AttendanceCorrectionRequestOrderByRelevanceInput = {
    fields:
      | AttendanceCorrectionRequestOrderByRelevanceFieldEnum
      | AttendanceCorrectionRequestOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type AttendanceCorrectionRequestCountOrderByAggregateInput = {
    id?: SortOrder;
    attendanceId?: SortOrder;
    userId?: SortOrder;
    originalCheckInTime?: SortOrder;
    originalCheckOutTime?: SortOrder;
    requestedCheckInTime?: SortOrder;
    requestedCheckOutTime?: SortOrder;
    reason?: SortOrder;
    status?: SortOrder;
    reviewedBy?: SortOrder;
    reviewedAt?: SortOrder;
    reviewNotes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AttendanceCorrectionRequestMaxOrderByAggregateInput = {
    id?: SortOrder;
    attendanceId?: SortOrder;
    userId?: SortOrder;
    originalCheckInTime?: SortOrder;
    originalCheckOutTime?: SortOrder;
    requestedCheckInTime?: SortOrder;
    requestedCheckOutTime?: SortOrder;
    reason?: SortOrder;
    status?: SortOrder;
    reviewedBy?: SortOrder;
    reviewedAt?: SortOrder;
    reviewNotes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AttendanceCorrectionRequestMinOrderByAggregateInput = {
    id?: SortOrder;
    attendanceId?: SortOrder;
    userId?: SortOrder;
    originalCheckInTime?: SortOrder;
    originalCheckOutTime?: SortOrder;
    requestedCheckInTime?: SortOrder;
    requestedCheckOutTime?: SortOrder;
    reason?: SortOrder;
    status?: SortOrder;
    reviewedBy?: SortOrder;
    reviewedAt?: SortOrder;
    reviewNotes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CommentOrderByRelevanceInput = {
    fields: CommentOrderByRelevanceFieldEnum | CommentOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder;
    content?: SortOrder;
    taskId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder;
    content?: SortOrder;
    taskId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder;
    content?: SortOrder;
    taskId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TaskAttachmentOrderByRelevanceInput = {
    fields: TaskAttachmentOrderByRelevanceFieldEnum | TaskAttachmentOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type TaskAttachmentCountOrderByAggregateInput = {
    id?: SortOrder;
    filename?: SortOrder;
    fileUrl?: SortOrder;
    fileSize?: SortOrder;
    fileType?: SortOrder;
    taskId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TaskAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder;
  };

  export type TaskAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder;
    filename?: SortOrder;
    fileUrl?: SortOrder;
    fileSize?: SortOrder;
    fileType?: SortOrder;
    taskId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TaskAttachmentMinOrderByAggregateInput = {
    id?: SortOrder;
    filename?: SortOrder;
    fileUrl?: SortOrder;
    fileSize?: SortOrder;
    fileType?: SortOrder;
    taskId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TaskAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder;
  };

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput;
    some?: RolePermissionWhereInput;
    none?: RolePermissionWhereInput;
  };

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RoleOrderByRelevanceInput = {
    fields: RoleOrderByRelevanceFieldEnum | RoleOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    color?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    color?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    color?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PermissionOrderByRelevanceInput = {
    fields: PermissionOrderByRelevanceFieldEnum | PermissionOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    category?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    category?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    category?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput;
    isNot?: PermissionWhereInput;
  };

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput;
    isNot?: RoleWhereInput;
  };

  export type RolePermissionOrderByRelevanceInput = {
    fields: RolePermissionOrderByRelevanceFieldEnum | RolePermissionOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string;
    permissionId: string;
  };

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder;
    roleId?: SortOrder;
    permissionId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder;
    roleId?: SortOrder;
    permissionId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder;
    roleId?: SortOrder;
    permissionId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AccountCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type ActivityCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
      | ActivityCreateWithoutUserInput[]
      | ActivityUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ActivityCreateOrConnectWithoutUserInput
      | ActivityCreateOrConnectWithoutUserInput[];
    createMany?: ActivityCreateManyUserInputEnvelope;
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
  };

  export type AttendanceCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
      | AttendanceCreateWithoutUserInput[]
      | AttendanceUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AttendanceCreateOrConnectWithoutUserInput
      | AttendanceCreateOrConnectWithoutUserInput[];
    createMany?: AttendanceCreateManyUserInputEnvelope;
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
  };

  export type AttendanceCorrectionRequestCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AttendanceCorrectionRequestCreateWithoutUserInput,
          AttendanceCorrectionRequestUncheckedCreateWithoutUserInput
        >
      | AttendanceCorrectionRequestCreateWithoutUserInput[]
      | AttendanceCorrectionRequestUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AttendanceCorrectionRequestCreateOrConnectWithoutUserInput
      | AttendanceCorrectionRequestCreateOrConnectWithoutUserInput[];
    createMany?: AttendanceCorrectionRequestCreateManyUserInputEnvelope;
    connect?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
  };

  export type AttendanceSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<
      AttendanceSettingsCreateWithoutUserInput,
      AttendanceSettingsUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: AttendanceSettingsCreateOrConnectWithoutUserInput;
    connect?: AttendanceSettingsWhereUniqueInput;
  };

  export type CommentCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
      | CommentCreateWithoutUserInput[]
      | CommentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutUserInput
      | CommentCreateOrConnectWithoutUserInput[];
    createMany?: CommentCreateManyUserInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type DocumentCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
      | DocumentCreateWithoutUserInput[]
      | DocumentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutUserInput
      | DocumentCreateOrConnectWithoutUserInput[];
    createMany?: DocumentCreateManyUserInputEnvelope;
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
  };

  export type ProjectCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput>
      | ProjectCreateWithoutCreatedByInput[]
      | ProjectUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ProjectCreateOrConnectWithoutCreatedByInput
      | ProjectCreateOrConnectWithoutCreatedByInput[];
    createMany?: ProjectCreateManyCreatedByInputEnvelope;
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
  };

  export type SessionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type TaskAssigneeCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput>
      | TaskAssigneeCreateWithoutUserInput[]
      | TaskAssigneeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TaskAssigneeCreateOrConnectWithoutUserInput
      | TaskAssigneeCreateOrConnectWithoutUserInput[];
    createMany?: TaskAssigneeCreateManyUserInputEnvelope;
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
  };

  export type TaskAttachmentCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<TaskAttachmentCreateWithoutUserInput, TaskAttachmentUncheckedCreateWithoutUserInput>
      | TaskAttachmentCreateWithoutUserInput[]
      | TaskAttachmentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TaskAttachmentCreateOrConnectWithoutUserInput
      | TaskAttachmentCreateOrConnectWithoutUserInput[];
    createMany?: TaskAttachmentCreateManyUserInputEnvelope;
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
  };

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
      | TeamMemberCreateWithoutUserInput[]
      | TeamMemberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutUserInput
      | TeamMemberCreateOrConnectWithoutUserInput[];
    createMany?: TeamMemberCreateManyUserInputEnvelope;
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
  };

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type ActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
      | ActivityCreateWithoutUserInput[]
      | ActivityUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ActivityCreateOrConnectWithoutUserInput
      | ActivityCreateOrConnectWithoutUserInput[];
    createMany?: ActivityCreateManyUserInputEnvelope;
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
  };

  export type AttendanceUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
      | AttendanceCreateWithoutUserInput[]
      | AttendanceUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AttendanceCreateOrConnectWithoutUserInput
      | AttendanceCreateOrConnectWithoutUserInput[];
    createMany?: AttendanceCreateManyUserInputEnvelope;
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
  };

  export type AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AttendanceCorrectionRequestCreateWithoutUserInput,
          AttendanceCorrectionRequestUncheckedCreateWithoutUserInput
        >
      | AttendanceCorrectionRequestCreateWithoutUserInput[]
      | AttendanceCorrectionRequestUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AttendanceCorrectionRequestCreateOrConnectWithoutUserInput
      | AttendanceCorrectionRequestCreateOrConnectWithoutUserInput[];
    createMany?: AttendanceCorrectionRequestCreateManyUserInputEnvelope;
    connect?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
  };

  export type AttendanceSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      AttendanceSettingsCreateWithoutUserInput,
      AttendanceSettingsUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: AttendanceSettingsCreateOrConnectWithoutUserInput;
    connect?: AttendanceSettingsWhereUniqueInput;
  };

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
      | CommentCreateWithoutUserInput[]
      | CommentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutUserInput
      | CommentCreateOrConnectWithoutUserInput[];
    createMany?: CommentCreateManyUserInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type DocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
      | DocumentCreateWithoutUserInput[]
      | DocumentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutUserInput
      | DocumentCreateOrConnectWithoutUserInput[];
    createMany?: DocumentCreateManyUserInputEnvelope;
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
  };

  export type ProjectUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput>
      | ProjectCreateWithoutCreatedByInput[]
      | ProjectUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ProjectCreateOrConnectWithoutCreatedByInput
      | ProjectCreateOrConnectWithoutCreatedByInput[];
    createMany?: ProjectCreateManyCreatedByInputEnvelope;
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
  };

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type TaskAssigneeUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput>
      | TaskAssigneeCreateWithoutUserInput[]
      | TaskAssigneeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TaskAssigneeCreateOrConnectWithoutUserInput
      | TaskAssigneeCreateOrConnectWithoutUserInput[];
    createMany?: TaskAssigneeCreateManyUserInputEnvelope;
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
  };

  export type TaskAttachmentUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<TaskAttachmentCreateWithoutUserInput, TaskAttachmentUncheckedCreateWithoutUserInput>
      | TaskAttachmentCreateWithoutUserInput[]
      | TaskAttachmentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TaskAttachmentCreateOrConnectWithoutUserInput
      | TaskAttachmentCreateOrConnectWithoutUserInput[];
    createMany?: TaskAttachmentCreateManyUserInputEnvelope;
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
  };

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
      | TeamMemberCreateWithoutUserInput[]
      | TeamMemberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutUserInput
      | TeamMemberCreateOrConnectWithoutUserInput[];
    createMany?: TeamMemberCreateManyUserInputEnvelope;
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type ActivityUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
      | ActivityCreateWithoutUserInput[]
      | ActivityUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ActivityCreateOrConnectWithoutUserInput
      | ActivityCreateOrConnectWithoutUserInput[];
    upsert?:
      | ActivityUpsertWithWhereUniqueWithoutUserInput
      | ActivityUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ActivityCreateManyUserInputEnvelope;
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    update?:
      | ActivityUpdateWithWhereUniqueWithoutUserInput
      | ActivityUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ActivityUpdateManyWithWhereWithoutUserInput
      | ActivityUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[];
  };

  export type AttendanceUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
      | AttendanceCreateWithoutUserInput[]
      | AttendanceUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AttendanceCreateOrConnectWithoutUserInput
      | AttendanceCreateOrConnectWithoutUserInput[];
    upsert?:
      | AttendanceUpsertWithWhereUniqueWithoutUserInput
      | AttendanceUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AttendanceCreateManyUserInputEnvelope;
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    update?:
      | AttendanceUpdateWithWhereUniqueWithoutUserInput
      | AttendanceUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AttendanceUpdateManyWithWhereWithoutUserInput
      | AttendanceUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[];
  };

  export type AttendanceCorrectionRequestUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AttendanceCorrectionRequestCreateWithoutUserInput,
          AttendanceCorrectionRequestUncheckedCreateWithoutUserInput
        >
      | AttendanceCorrectionRequestCreateWithoutUserInput[]
      | AttendanceCorrectionRequestUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AttendanceCorrectionRequestCreateOrConnectWithoutUserInput
      | AttendanceCorrectionRequestCreateOrConnectWithoutUserInput[];
    upsert?:
      | AttendanceCorrectionRequestUpsertWithWhereUniqueWithoutUserInput
      | AttendanceCorrectionRequestUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AttendanceCorrectionRequestCreateManyUserInputEnvelope;
    set?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    disconnect?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    delete?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    connect?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    update?:
      | AttendanceCorrectionRequestUpdateWithWhereUniqueWithoutUserInput
      | AttendanceCorrectionRequestUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AttendanceCorrectionRequestUpdateManyWithWhereWithoutUserInput
      | AttendanceCorrectionRequestUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | AttendanceCorrectionRequestScalarWhereInput
      | AttendanceCorrectionRequestScalarWhereInput[];
  };

  export type AttendanceSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      AttendanceSettingsCreateWithoutUserInput,
      AttendanceSettingsUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: AttendanceSettingsCreateOrConnectWithoutUserInput;
    upsert?: AttendanceSettingsUpsertWithoutUserInput;
    disconnect?: AttendanceSettingsWhereInput | boolean;
    delete?: AttendanceSettingsWhereInput | boolean;
    connect?: AttendanceSettingsWhereUniqueInput;
    update?: XOR<
      XOR<
        AttendanceSettingsUpdateToOneWithWhereWithoutUserInput,
        AttendanceSettingsUpdateWithoutUserInput
      >,
      AttendanceSettingsUncheckedUpdateWithoutUserInput
    >;
  };

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
      | CommentCreateWithoutUserInput[]
      | CommentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutUserInput
      | CommentCreateOrConnectWithoutUserInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutUserInput
      | CommentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: CommentCreateManyUserInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutUserInput
      | CommentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutUserInput
      | CommentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type DocumentUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
      | DocumentCreateWithoutUserInput[]
      | DocumentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutUserInput
      | DocumentCreateOrConnectWithoutUserInput[];
    upsert?:
      | DocumentUpsertWithWhereUniqueWithoutUserInput
      | DocumentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: DocumentCreateManyUserInputEnvelope;
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    update?:
      | DocumentUpdateWithWhereUniqueWithoutUserInput
      | DocumentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | DocumentUpdateManyWithWhereWithoutUserInput
      | DocumentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
  };

  export type ProjectUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput>
      | ProjectCreateWithoutCreatedByInput[]
      | ProjectUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ProjectCreateOrConnectWithoutCreatedByInput
      | ProjectCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | ProjectUpsertWithWhereUniqueWithoutCreatedByInput
      | ProjectUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: ProjectCreateManyCreatedByInputEnvelope;
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
    update?:
      | ProjectUpdateWithWhereUniqueWithoutCreatedByInput
      | ProjectUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | ProjectUpdateManyWithWhereWithoutCreatedByInput
      | ProjectUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[];
  };

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type TaskAssigneeUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput>
      | TaskAssigneeCreateWithoutUserInput[]
      | TaskAssigneeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TaskAssigneeCreateOrConnectWithoutUserInput
      | TaskAssigneeCreateOrConnectWithoutUserInput[];
    upsert?:
      | TaskAssigneeUpsertWithWhereUniqueWithoutUserInput
      | TaskAssigneeUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TaskAssigneeCreateManyUserInputEnvelope;
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    update?:
      | TaskAssigneeUpdateWithWhereUniqueWithoutUserInput
      | TaskAssigneeUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TaskAssigneeUpdateManyWithWhereWithoutUserInput
      | TaskAssigneeUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[];
  };

  export type TaskAttachmentUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<TaskAttachmentCreateWithoutUserInput, TaskAttachmentUncheckedCreateWithoutUserInput>
      | TaskAttachmentCreateWithoutUserInput[]
      | TaskAttachmentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TaskAttachmentCreateOrConnectWithoutUserInput
      | TaskAttachmentCreateOrConnectWithoutUserInput[];
    upsert?:
      | TaskAttachmentUpsertWithWhereUniqueWithoutUserInput
      | TaskAttachmentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TaskAttachmentCreateManyUserInputEnvelope;
    set?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    disconnect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    delete?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    update?:
      | TaskAttachmentUpdateWithWhereUniqueWithoutUserInput
      | TaskAttachmentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TaskAttachmentUpdateManyWithWhereWithoutUserInput
      | TaskAttachmentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[];
  };

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
      | TeamMemberCreateWithoutUserInput[]
      | TeamMemberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutUserInput
      | TeamMemberCreateOrConnectWithoutUserInput[];
    upsert?:
      | TeamMemberUpsertWithWhereUniqueWithoutUserInput
      | TeamMemberUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TeamMemberCreateManyUserInputEnvelope;
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    update?:
      | TeamMemberUpdateWithWhereUniqueWithoutUserInput
      | TeamMemberUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TeamMemberUpdateManyWithWhereWithoutUserInput
      | TeamMemberUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
  };

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type ActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
      | ActivityCreateWithoutUserInput[]
      | ActivityUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ActivityCreateOrConnectWithoutUserInput
      | ActivityCreateOrConnectWithoutUserInput[];
    upsert?:
      | ActivityUpsertWithWhereUniqueWithoutUserInput
      | ActivityUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ActivityCreateManyUserInputEnvelope;
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    update?:
      | ActivityUpdateWithWhereUniqueWithoutUserInput
      | ActivityUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ActivityUpdateManyWithWhereWithoutUserInput
      | ActivityUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[];
  };

  export type AttendanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
      | AttendanceCreateWithoutUserInput[]
      | AttendanceUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AttendanceCreateOrConnectWithoutUserInput
      | AttendanceCreateOrConnectWithoutUserInput[];
    upsert?:
      | AttendanceUpsertWithWhereUniqueWithoutUserInput
      | AttendanceUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AttendanceCreateManyUserInputEnvelope;
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    update?:
      | AttendanceUpdateWithWhereUniqueWithoutUserInput
      | AttendanceUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AttendanceUpdateManyWithWhereWithoutUserInput
      | AttendanceUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[];
  };

  export type AttendanceCorrectionRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AttendanceCorrectionRequestCreateWithoutUserInput,
          AttendanceCorrectionRequestUncheckedCreateWithoutUserInput
        >
      | AttendanceCorrectionRequestCreateWithoutUserInput[]
      | AttendanceCorrectionRequestUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AttendanceCorrectionRequestCreateOrConnectWithoutUserInput
      | AttendanceCorrectionRequestCreateOrConnectWithoutUserInput[];
    upsert?:
      | AttendanceCorrectionRequestUpsertWithWhereUniqueWithoutUserInput
      | AttendanceCorrectionRequestUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AttendanceCorrectionRequestCreateManyUserInputEnvelope;
    set?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    disconnect?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    delete?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    connect?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    update?:
      | AttendanceCorrectionRequestUpdateWithWhereUniqueWithoutUserInput
      | AttendanceCorrectionRequestUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AttendanceCorrectionRequestUpdateManyWithWhereWithoutUserInput
      | AttendanceCorrectionRequestUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | AttendanceCorrectionRequestScalarWhereInput
      | AttendanceCorrectionRequestScalarWhereInput[];
  };

  export type AttendanceSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      AttendanceSettingsCreateWithoutUserInput,
      AttendanceSettingsUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: AttendanceSettingsCreateOrConnectWithoutUserInput;
    upsert?: AttendanceSettingsUpsertWithoutUserInput;
    disconnect?: AttendanceSettingsWhereInput | boolean;
    delete?: AttendanceSettingsWhereInput | boolean;
    connect?: AttendanceSettingsWhereUniqueInput;
    update?: XOR<
      XOR<
        AttendanceSettingsUpdateToOneWithWhereWithoutUserInput,
        AttendanceSettingsUpdateWithoutUserInput
      >,
      AttendanceSettingsUncheckedUpdateWithoutUserInput
    >;
  };

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
      | CommentCreateWithoutUserInput[]
      | CommentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutUserInput
      | CommentCreateOrConnectWithoutUserInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutUserInput
      | CommentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: CommentCreateManyUserInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutUserInput
      | CommentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutUserInput
      | CommentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type DocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
      | DocumentCreateWithoutUserInput[]
      | DocumentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutUserInput
      | DocumentCreateOrConnectWithoutUserInput[];
    upsert?:
      | DocumentUpsertWithWhereUniqueWithoutUserInput
      | DocumentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: DocumentCreateManyUserInputEnvelope;
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    update?:
      | DocumentUpdateWithWhereUniqueWithoutUserInput
      | DocumentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | DocumentUpdateManyWithWhereWithoutUserInput
      | DocumentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
  };

  export type ProjectUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput>
      | ProjectCreateWithoutCreatedByInput[]
      | ProjectUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ProjectCreateOrConnectWithoutCreatedByInput
      | ProjectCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | ProjectUpsertWithWhereUniqueWithoutCreatedByInput
      | ProjectUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: ProjectCreateManyCreatedByInputEnvelope;
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
    update?:
      | ProjectUpdateWithWhereUniqueWithoutCreatedByInput
      | ProjectUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | ProjectUpdateManyWithWhereWithoutCreatedByInput
      | ProjectUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[];
  };

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput>
      | TaskAssigneeCreateWithoutUserInput[]
      | TaskAssigneeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TaskAssigneeCreateOrConnectWithoutUserInput
      | TaskAssigneeCreateOrConnectWithoutUserInput[];
    upsert?:
      | TaskAssigneeUpsertWithWhereUniqueWithoutUserInput
      | TaskAssigneeUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TaskAssigneeCreateManyUserInputEnvelope;
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    update?:
      | TaskAssigneeUpdateWithWhereUniqueWithoutUserInput
      | TaskAssigneeUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TaskAssigneeUpdateManyWithWhereWithoutUserInput
      | TaskAssigneeUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[];
  };

  export type TaskAttachmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<TaskAttachmentCreateWithoutUserInput, TaskAttachmentUncheckedCreateWithoutUserInput>
      | TaskAttachmentCreateWithoutUserInput[]
      | TaskAttachmentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TaskAttachmentCreateOrConnectWithoutUserInput
      | TaskAttachmentCreateOrConnectWithoutUserInput[];
    upsert?:
      | TaskAttachmentUpsertWithWhereUniqueWithoutUserInput
      | TaskAttachmentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TaskAttachmentCreateManyUserInputEnvelope;
    set?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    disconnect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    delete?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    update?:
      | TaskAttachmentUpdateWithWhereUniqueWithoutUserInput
      | TaskAttachmentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TaskAttachmentUpdateManyWithWhereWithoutUserInput
      | TaskAttachmentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[];
  };

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
      | TeamMemberCreateWithoutUserInput[]
      | TeamMemberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutUserInput
      | TeamMemberCreateOrConnectWithoutUserInput[];
    upsert?:
      | TeamMemberUpsertWithWhereUniqueWithoutUserInput
      | TeamMemberUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TeamMemberCreateManyUserInputEnvelope;
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    update?:
      | TeamMemberUpdateWithWhereUniqueWithoutUserInput
      | TeamMemberUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TeamMemberUpdateManyWithWhereWithoutUserInput
      | TeamMemberUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    upsert?: UserUpsertWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>,
      UserUncheckedUpdateWithoutAccountsInput
    >;
  };

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    upsert?: UserUpsertWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>,
      UserUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type ActivityCreateNestedManyWithoutProjectInput = {
    create?:
      | XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput>
      | ActivityCreateWithoutProjectInput[]
      | ActivityUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | ActivityCreateOrConnectWithoutProjectInput
      | ActivityCreateOrConnectWithoutProjectInput[];
    createMany?: ActivityCreateManyProjectInputEnvelope;
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
  };

  export type AttendanceCreateNestedManyWithoutProjectInput = {
    create?:
      | XOR<AttendanceCreateWithoutProjectInput, AttendanceUncheckedCreateWithoutProjectInput>
      | AttendanceCreateWithoutProjectInput[]
      | AttendanceUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | AttendanceCreateOrConnectWithoutProjectInput
      | AttendanceCreateOrConnectWithoutProjectInput[];
    createMany?: AttendanceCreateManyProjectInputEnvelope;
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
  };

  export type EventCreateNestedManyWithoutProjectInput = {
    create?:
      | XOR<EventCreateWithoutProjectInput, EventUncheckedCreateWithoutProjectInput>
      | EventCreateWithoutProjectInput[]
      | EventUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | EventCreateOrConnectWithoutProjectInput
      | EventCreateOrConnectWithoutProjectInput[];
    createMany?: EventCreateManyProjectInputEnvelope;
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[];
  };

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput;
    connect?: UserWhereUniqueInput;
  };

  export type ProjectStatusCreateNestedManyWithoutProjectInput = {
    create?:
      | XOR<ProjectStatusCreateWithoutProjectInput, ProjectStatusUncheckedCreateWithoutProjectInput>
      | ProjectStatusCreateWithoutProjectInput[]
      | ProjectStatusUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | ProjectStatusCreateOrConnectWithoutProjectInput
      | ProjectStatusCreateOrConnectWithoutProjectInput[];
    createMany?: ProjectStatusCreateManyProjectInputEnvelope;
    connect?: ProjectStatusWhereUniqueInput | ProjectStatusWhereUniqueInput[];
  };

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?:
      | XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
      | TaskCreateWithoutProjectInput[]
      | TaskUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutProjectInput
      | TaskCreateOrConnectWithoutProjectInput[];
    createMany?: TaskCreateManyProjectInputEnvelope;
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
  };

  export type TeamMemberCreateNestedManyWithoutProjectInput = {
    create?:
      | XOR<TeamMemberCreateWithoutProjectInput, TeamMemberUncheckedCreateWithoutProjectInput>
      | TeamMemberCreateWithoutProjectInput[]
      | TeamMemberUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutProjectInput
      | TeamMemberCreateOrConnectWithoutProjectInput[];
    createMany?: TeamMemberCreateManyProjectInputEnvelope;
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
  };

  export type ActivityUncheckedCreateNestedManyWithoutProjectInput = {
    create?:
      | XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput>
      | ActivityCreateWithoutProjectInput[]
      | ActivityUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | ActivityCreateOrConnectWithoutProjectInput
      | ActivityCreateOrConnectWithoutProjectInput[];
    createMany?: ActivityCreateManyProjectInputEnvelope;
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
  };

  export type AttendanceUncheckedCreateNestedManyWithoutProjectInput = {
    create?:
      | XOR<AttendanceCreateWithoutProjectInput, AttendanceUncheckedCreateWithoutProjectInput>
      | AttendanceCreateWithoutProjectInput[]
      | AttendanceUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | AttendanceCreateOrConnectWithoutProjectInput
      | AttendanceCreateOrConnectWithoutProjectInput[];
    createMany?: AttendanceCreateManyProjectInputEnvelope;
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
  };

  export type EventUncheckedCreateNestedManyWithoutProjectInput = {
    create?:
      | XOR<EventCreateWithoutProjectInput, EventUncheckedCreateWithoutProjectInput>
      | EventCreateWithoutProjectInput[]
      | EventUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | EventCreateOrConnectWithoutProjectInput
      | EventCreateOrConnectWithoutProjectInput[];
    createMany?: EventCreateManyProjectInputEnvelope;
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[];
  };

  export type ProjectStatusUncheckedCreateNestedManyWithoutProjectInput = {
    create?:
      | XOR<ProjectStatusCreateWithoutProjectInput, ProjectStatusUncheckedCreateWithoutProjectInput>
      | ProjectStatusCreateWithoutProjectInput[]
      | ProjectStatusUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | ProjectStatusCreateOrConnectWithoutProjectInput
      | ProjectStatusCreateOrConnectWithoutProjectInput[];
    createMany?: ProjectStatusCreateManyProjectInputEnvelope;
    connect?: ProjectStatusWhereUniqueInput | ProjectStatusWhereUniqueInput[];
  };

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?:
      | XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
      | TaskCreateWithoutProjectInput[]
      | TaskUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutProjectInput
      | TaskCreateOrConnectWithoutProjectInput[];
    createMany?: TaskCreateManyProjectInputEnvelope;
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
  };

  export type TeamMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?:
      | XOR<TeamMemberCreateWithoutProjectInput, TeamMemberUncheckedCreateWithoutProjectInput>
      | TeamMemberCreateWithoutProjectInput[]
      | TeamMemberUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutProjectInput
      | TeamMemberCreateOrConnectWithoutProjectInput[];
    createMany?: TeamMemberCreateManyProjectInputEnvelope;
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
  };

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type ActivityUpdateManyWithoutProjectNestedInput = {
    create?:
      | XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput>
      | ActivityCreateWithoutProjectInput[]
      | ActivityUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | ActivityCreateOrConnectWithoutProjectInput
      | ActivityCreateOrConnectWithoutProjectInput[];
    upsert?:
      | ActivityUpsertWithWhereUniqueWithoutProjectInput
      | ActivityUpsertWithWhereUniqueWithoutProjectInput[];
    createMany?: ActivityCreateManyProjectInputEnvelope;
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    update?:
      | ActivityUpdateWithWhereUniqueWithoutProjectInput
      | ActivityUpdateWithWhereUniqueWithoutProjectInput[];
    updateMany?:
      | ActivityUpdateManyWithWhereWithoutProjectInput
      | ActivityUpdateManyWithWhereWithoutProjectInput[];
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[];
  };

  export type AttendanceUpdateManyWithoutProjectNestedInput = {
    create?:
      | XOR<AttendanceCreateWithoutProjectInput, AttendanceUncheckedCreateWithoutProjectInput>
      | AttendanceCreateWithoutProjectInput[]
      | AttendanceUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | AttendanceCreateOrConnectWithoutProjectInput
      | AttendanceCreateOrConnectWithoutProjectInput[];
    upsert?:
      | AttendanceUpsertWithWhereUniqueWithoutProjectInput
      | AttendanceUpsertWithWhereUniqueWithoutProjectInput[];
    createMany?: AttendanceCreateManyProjectInputEnvelope;
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    update?:
      | AttendanceUpdateWithWhereUniqueWithoutProjectInput
      | AttendanceUpdateWithWhereUniqueWithoutProjectInput[];
    updateMany?:
      | AttendanceUpdateManyWithWhereWithoutProjectInput
      | AttendanceUpdateManyWithWhereWithoutProjectInput[];
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[];
  };

  export type EventUpdateManyWithoutProjectNestedInput = {
    create?:
      | XOR<EventCreateWithoutProjectInput, EventUncheckedCreateWithoutProjectInput>
      | EventCreateWithoutProjectInput[]
      | EventUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | EventCreateOrConnectWithoutProjectInput
      | EventCreateOrConnectWithoutProjectInput[];
    upsert?:
      | EventUpsertWithWhereUniqueWithoutProjectInput
      | EventUpsertWithWhereUniqueWithoutProjectInput[];
    createMany?: EventCreateManyProjectInputEnvelope;
    set?: EventWhereUniqueInput | EventWhereUniqueInput[];
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[];
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[];
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[];
    update?:
      | EventUpdateWithWhereUniqueWithoutProjectInput
      | EventUpdateWithWhereUniqueWithoutProjectInput[];
    updateMany?:
      | EventUpdateManyWithWhereWithoutProjectInput
      | EventUpdateManyWithWhereWithoutProjectInput[];
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[];
  };

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput;
    upsert?: UserUpsertWithoutProjectsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>,
      UserUncheckedUpdateWithoutProjectsInput
    >;
  };

  export type ProjectStatusUpdateManyWithoutProjectNestedInput = {
    create?:
      | XOR<ProjectStatusCreateWithoutProjectInput, ProjectStatusUncheckedCreateWithoutProjectInput>
      | ProjectStatusCreateWithoutProjectInput[]
      | ProjectStatusUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | ProjectStatusCreateOrConnectWithoutProjectInput
      | ProjectStatusCreateOrConnectWithoutProjectInput[];
    upsert?:
      | ProjectStatusUpsertWithWhereUniqueWithoutProjectInput
      | ProjectStatusUpsertWithWhereUniqueWithoutProjectInput[];
    createMany?: ProjectStatusCreateManyProjectInputEnvelope;
    set?: ProjectStatusWhereUniqueInput | ProjectStatusWhereUniqueInput[];
    disconnect?: ProjectStatusWhereUniqueInput | ProjectStatusWhereUniqueInput[];
    delete?: ProjectStatusWhereUniqueInput | ProjectStatusWhereUniqueInput[];
    connect?: ProjectStatusWhereUniqueInput | ProjectStatusWhereUniqueInput[];
    update?:
      | ProjectStatusUpdateWithWhereUniqueWithoutProjectInput
      | ProjectStatusUpdateWithWhereUniqueWithoutProjectInput[];
    updateMany?:
      | ProjectStatusUpdateManyWithWhereWithoutProjectInput
      | ProjectStatusUpdateManyWithWhereWithoutProjectInput[];
    deleteMany?: ProjectStatusScalarWhereInput | ProjectStatusScalarWhereInput[];
  };

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?:
      | XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
      | TaskCreateWithoutProjectInput[]
      | TaskUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutProjectInput
      | TaskCreateOrConnectWithoutProjectInput[];
    upsert?:
      | TaskUpsertWithWhereUniqueWithoutProjectInput
      | TaskUpsertWithWhereUniqueWithoutProjectInput[];
    createMany?: TaskCreateManyProjectInputEnvelope;
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    update?:
      | TaskUpdateWithWhereUniqueWithoutProjectInput
      | TaskUpdateWithWhereUniqueWithoutProjectInput[];
    updateMany?:
      | TaskUpdateManyWithWhereWithoutProjectInput
      | TaskUpdateManyWithWhereWithoutProjectInput[];
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[];
  };

  export type TeamMemberUpdateManyWithoutProjectNestedInput = {
    create?:
      | XOR<TeamMemberCreateWithoutProjectInput, TeamMemberUncheckedCreateWithoutProjectInput>
      | TeamMemberCreateWithoutProjectInput[]
      | TeamMemberUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutProjectInput
      | TeamMemberCreateOrConnectWithoutProjectInput[];
    upsert?:
      | TeamMemberUpsertWithWhereUniqueWithoutProjectInput
      | TeamMemberUpsertWithWhereUniqueWithoutProjectInput[];
    createMany?: TeamMemberCreateManyProjectInputEnvelope;
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    update?:
      | TeamMemberUpdateWithWhereUniqueWithoutProjectInput
      | TeamMemberUpdateWithWhereUniqueWithoutProjectInput[];
    updateMany?:
      | TeamMemberUpdateManyWithWhereWithoutProjectInput
      | TeamMemberUpdateManyWithWhereWithoutProjectInput[];
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
  };

  export type ActivityUncheckedUpdateManyWithoutProjectNestedInput = {
    create?:
      | XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput>
      | ActivityCreateWithoutProjectInput[]
      | ActivityUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | ActivityCreateOrConnectWithoutProjectInput
      | ActivityCreateOrConnectWithoutProjectInput[];
    upsert?:
      | ActivityUpsertWithWhereUniqueWithoutProjectInput
      | ActivityUpsertWithWhereUniqueWithoutProjectInput[];
    createMany?: ActivityCreateManyProjectInputEnvelope;
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    update?:
      | ActivityUpdateWithWhereUniqueWithoutProjectInput
      | ActivityUpdateWithWhereUniqueWithoutProjectInput[];
    updateMany?:
      | ActivityUpdateManyWithWhereWithoutProjectInput
      | ActivityUpdateManyWithWhereWithoutProjectInput[];
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[];
  };

  export type AttendanceUncheckedUpdateManyWithoutProjectNestedInput = {
    create?:
      | XOR<AttendanceCreateWithoutProjectInput, AttendanceUncheckedCreateWithoutProjectInput>
      | AttendanceCreateWithoutProjectInput[]
      | AttendanceUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | AttendanceCreateOrConnectWithoutProjectInput
      | AttendanceCreateOrConnectWithoutProjectInput[];
    upsert?:
      | AttendanceUpsertWithWhereUniqueWithoutProjectInput
      | AttendanceUpsertWithWhereUniqueWithoutProjectInput[];
    createMany?: AttendanceCreateManyProjectInputEnvelope;
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    update?:
      | AttendanceUpdateWithWhereUniqueWithoutProjectInput
      | AttendanceUpdateWithWhereUniqueWithoutProjectInput[];
    updateMany?:
      | AttendanceUpdateManyWithWhereWithoutProjectInput
      | AttendanceUpdateManyWithWhereWithoutProjectInput[];
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[];
  };

  export type EventUncheckedUpdateManyWithoutProjectNestedInput = {
    create?:
      | XOR<EventCreateWithoutProjectInput, EventUncheckedCreateWithoutProjectInput>
      | EventCreateWithoutProjectInput[]
      | EventUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | EventCreateOrConnectWithoutProjectInput
      | EventCreateOrConnectWithoutProjectInput[];
    upsert?:
      | EventUpsertWithWhereUniqueWithoutProjectInput
      | EventUpsertWithWhereUniqueWithoutProjectInput[];
    createMany?: EventCreateManyProjectInputEnvelope;
    set?: EventWhereUniqueInput | EventWhereUniqueInput[];
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[];
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[];
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[];
    update?:
      | EventUpdateWithWhereUniqueWithoutProjectInput
      | EventUpdateWithWhereUniqueWithoutProjectInput[];
    updateMany?:
      | EventUpdateManyWithWhereWithoutProjectInput
      | EventUpdateManyWithWhereWithoutProjectInput[];
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[];
  };

  export type ProjectStatusUncheckedUpdateManyWithoutProjectNestedInput = {
    create?:
      | XOR<ProjectStatusCreateWithoutProjectInput, ProjectStatusUncheckedCreateWithoutProjectInput>
      | ProjectStatusCreateWithoutProjectInput[]
      | ProjectStatusUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | ProjectStatusCreateOrConnectWithoutProjectInput
      | ProjectStatusCreateOrConnectWithoutProjectInput[];
    upsert?:
      | ProjectStatusUpsertWithWhereUniqueWithoutProjectInput
      | ProjectStatusUpsertWithWhereUniqueWithoutProjectInput[];
    createMany?: ProjectStatusCreateManyProjectInputEnvelope;
    set?: ProjectStatusWhereUniqueInput | ProjectStatusWhereUniqueInput[];
    disconnect?: ProjectStatusWhereUniqueInput | ProjectStatusWhereUniqueInput[];
    delete?: ProjectStatusWhereUniqueInput | ProjectStatusWhereUniqueInput[];
    connect?: ProjectStatusWhereUniqueInput | ProjectStatusWhereUniqueInput[];
    update?:
      | ProjectStatusUpdateWithWhereUniqueWithoutProjectInput
      | ProjectStatusUpdateWithWhereUniqueWithoutProjectInput[];
    updateMany?:
      | ProjectStatusUpdateManyWithWhereWithoutProjectInput
      | ProjectStatusUpdateManyWithWhereWithoutProjectInput[];
    deleteMany?: ProjectStatusScalarWhereInput | ProjectStatusScalarWhereInput[];
  };

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?:
      | XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
      | TaskCreateWithoutProjectInput[]
      | TaskUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutProjectInput
      | TaskCreateOrConnectWithoutProjectInput[];
    upsert?:
      | TaskUpsertWithWhereUniqueWithoutProjectInput
      | TaskUpsertWithWhereUniqueWithoutProjectInput[];
    createMany?: TaskCreateManyProjectInputEnvelope;
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    update?:
      | TaskUpdateWithWhereUniqueWithoutProjectInput
      | TaskUpdateWithWhereUniqueWithoutProjectInput[];
    updateMany?:
      | TaskUpdateManyWithWhereWithoutProjectInput
      | TaskUpdateManyWithWhereWithoutProjectInput[];
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[];
  };

  export type TeamMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?:
      | XOR<TeamMemberCreateWithoutProjectInput, TeamMemberUncheckedCreateWithoutProjectInput>
      | TeamMemberCreateWithoutProjectInput[]
      | TeamMemberUncheckedCreateWithoutProjectInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutProjectInput
      | TeamMemberCreateOrConnectWithoutProjectInput[];
    upsert?:
      | TeamMemberUpsertWithWhereUniqueWithoutProjectInput
      | TeamMemberUpsertWithWhereUniqueWithoutProjectInput[];
    createMany?: TeamMemberCreateManyProjectInputEnvelope;
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    update?:
      | TeamMemberUpdateWithWhereUniqueWithoutProjectInput
      | TeamMemberUpdateWithWhereUniqueWithoutProjectInput[];
    updateMany?:
      | TeamMemberUpdateManyWithWhereWithoutProjectInput
      | TeamMemberUpdateManyWithWhereWithoutProjectInput[];
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
  };

  export type ProjectCreateNestedOneWithoutStatusesInput = {
    create?: XOR<ProjectCreateWithoutStatusesInput, ProjectUncheckedCreateWithoutStatusesInput>;
    connectOrCreate?: ProjectCreateOrConnectWithoutStatusesInput;
    connect?: ProjectWhereUniqueInput;
  };

  export type TaskCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput>
      | TaskCreateWithoutStatusInput[]
      | TaskUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutStatusInput
      | TaskCreateOrConnectWithoutStatusInput[];
    createMany?: TaskCreateManyStatusInputEnvelope;
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
  };

  export type TaskUncheckedCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput>
      | TaskCreateWithoutStatusInput[]
      | TaskUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutStatusInput
      | TaskCreateOrConnectWithoutStatusInput[];
    createMany?: TaskCreateManyStatusInputEnvelope;
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type ProjectUpdateOneRequiredWithoutStatusesNestedInput = {
    create?: XOR<ProjectCreateWithoutStatusesInput, ProjectUncheckedCreateWithoutStatusesInput>;
    connectOrCreate?: ProjectCreateOrConnectWithoutStatusesInput;
    upsert?: ProjectUpsertWithoutStatusesInput;
    connect?: ProjectWhereUniqueInput;
    update?: XOR<
      XOR<ProjectUpdateToOneWithWhereWithoutStatusesInput, ProjectUpdateWithoutStatusesInput>,
      ProjectUncheckedUpdateWithoutStatusesInput
    >;
  };

  export type TaskUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput>
      | TaskCreateWithoutStatusInput[]
      | TaskUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutStatusInput
      | TaskCreateOrConnectWithoutStatusInput[];
    upsert?:
      | TaskUpsertWithWhereUniqueWithoutStatusInput
      | TaskUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: TaskCreateManyStatusInputEnvelope;
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    update?:
      | TaskUpdateWithWhereUniqueWithoutStatusInput
      | TaskUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | TaskUpdateManyWithWhereWithoutStatusInput
      | TaskUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[];
  };

  export type TaskUncheckedUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput>
      | TaskCreateWithoutStatusInput[]
      | TaskUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutStatusInput
      | TaskCreateOrConnectWithoutStatusInput[];
    upsert?:
      | TaskUpsertWithWhereUniqueWithoutStatusInput
      | TaskUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: TaskCreateManyStatusInputEnvelope;
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    update?:
      | TaskUpdateWithWhereUniqueWithoutStatusInput
      | TaskUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | TaskUpdateManyWithWhereWithoutStatusInput
      | TaskUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[];
  };

  export type ActivityCreateNestedManyWithoutTaskInput = {
    create?:
      | XOR<ActivityCreateWithoutTaskInput, ActivityUncheckedCreateWithoutTaskInput>
      | ActivityCreateWithoutTaskInput[]
      | ActivityUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | ActivityCreateOrConnectWithoutTaskInput
      | ActivityCreateOrConnectWithoutTaskInput[];
    createMany?: ActivityCreateManyTaskInputEnvelope;
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
  };

  export type AttendanceCreateNestedManyWithoutTaskInput = {
    create?:
      | XOR<AttendanceCreateWithoutTaskInput, AttendanceUncheckedCreateWithoutTaskInput>
      | AttendanceCreateWithoutTaskInput[]
      | AttendanceUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | AttendanceCreateOrConnectWithoutTaskInput
      | AttendanceCreateOrConnectWithoutTaskInput[];
    createMany?: AttendanceCreateManyTaskInputEnvelope;
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
  };

  export type CommentCreateNestedManyWithoutTaskInput = {
    create?:
      | XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>
      | CommentCreateWithoutTaskInput[]
      | CommentUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutTaskInput
      | CommentCreateOrConnectWithoutTaskInput[];
    createMany?: CommentCreateManyTaskInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type TaskCreateNestedOneWithoutSubtasksInput = {
    create?: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>;
    connectOrCreate?: TaskCreateOrConnectWithoutSubtasksInput;
    connect?: TaskWhereUniqueInput;
  };

  export type TaskCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<TaskCreateWithoutParentInput, TaskUncheckedCreateWithoutParentInput>
      | TaskCreateWithoutParentInput[]
      | TaskUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutParentInput
      | TaskCreateOrConnectWithoutParentInput[];
    createMany?: TaskCreateManyParentInputEnvelope;
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
  };

  export type ProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>;
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput;
    connect?: ProjectWhereUniqueInput;
  };

  export type ProjectStatusCreateNestedOneWithoutTasksInput = {
    create?: XOR<
      ProjectStatusCreateWithoutTasksInput,
      ProjectStatusUncheckedCreateWithoutTasksInput
    >;
    connectOrCreate?: ProjectStatusCreateOrConnectWithoutTasksInput;
    connect?: ProjectStatusWhereUniqueInput;
  };

  export type TaskAssigneeCreateNestedManyWithoutTaskInput = {
    create?:
      | XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput>
      | TaskAssigneeCreateWithoutTaskInput[]
      | TaskAssigneeUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | TaskAssigneeCreateOrConnectWithoutTaskInput
      | TaskAssigneeCreateOrConnectWithoutTaskInput[];
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope;
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
  };

  export type TaskAttachmentCreateNestedManyWithoutTaskInput = {
    create?:
      | XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput>
      | TaskAttachmentCreateWithoutTaskInput[]
      | TaskAttachmentUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | TaskAttachmentCreateOrConnectWithoutTaskInput
      | TaskAttachmentCreateOrConnectWithoutTaskInput[];
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope;
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
  };

  export type ActivityUncheckedCreateNestedManyWithoutTaskInput = {
    create?:
      | XOR<ActivityCreateWithoutTaskInput, ActivityUncheckedCreateWithoutTaskInput>
      | ActivityCreateWithoutTaskInput[]
      | ActivityUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | ActivityCreateOrConnectWithoutTaskInput
      | ActivityCreateOrConnectWithoutTaskInput[];
    createMany?: ActivityCreateManyTaskInputEnvelope;
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
  };

  export type AttendanceUncheckedCreateNestedManyWithoutTaskInput = {
    create?:
      | XOR<AttendanceCreateWithoutTaskInput, AttendanceUncheckedCreateWithoutTaskInput>
      | AttendanceCreateWithoutTaskInput[]
      | AttendanceUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | AttendanceCreateOrConnectWithoutTaskInput
      | AttendanceCreateOrConnectWithoutTaskInput[];
    createMany?: AttendanceCreateManyTaskInputEnvelope;
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
  };

  export type CommentUncheckedCreateNestedManyWithoutTaskInput = {
    create?:
      | XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>
      | CommentCreateWithoutTaskInput[]
      | CommentUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutTaskInput
      | CommentCreateOrConnectWithoutTaskInput[];
    createMany?: CommentCreateManyTaskInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type TaskUncheckedCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<TaskCreateWithoutParentInput, TaskUncheckedCreateWithoutParentInput>
      | TaskCreateWithoutParentInput[]
      | TaskUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutParentInput
      | TaskCreateOrConnectWithoutParentInput[];
    createMany?: TaskCreateManyParentInputEnvelope;
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
  };

  export type TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput = {
    create?:
      | XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput>
      | TaskAssigneeCreateWithoutTaskInput[]
      | TaskAssigneeUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | TaskAssigneeCreateOrConnectWithoutTaskInput
      | TaskAssigneeCreateOrConnectWithoutTaskInput[];
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope;
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
  };

  export type TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput = {
    create?:
      | XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput>
      | TaskAttachmentCreateWithoutTaskInput[]
      | TaskAttachmentUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | TaskAttachmentCreateOrConnectWithoutTaskInput
      | TaskAttachmentCreateOrConnectWithoutTaskInput[];
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope;
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
  };

  export type ActivityUpdateManyWithoutTaskNestedInput = {
    create?:
      | XOR<ActivityCreateWithoutTaskInput, ActivityUncheckedCreateWithoutTaskInput>
      | ActivityCreateWithoutTaskInput[]
      | ActivityUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | ActivityCreateOrConnectWithoutTaskInput
      | ActivityCreateOrConnectWithoutTaskInput[];
    upsert?:
      | ActivityUpsertWithWhereUniqueWithoutTaskInput
      | ActivityUpsertWithWhereUniqueWithoutTaskInput[];
    createMany?: ActivityCreateManyTaskInputEnvelope;
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    update?:
      | ActivityUpdateWithWhereUniqueWithoutTaskInput
      | ActivityUpdateWithWhereUniqueWithoutTaskInput[];
    updateMany?:
      | ActivityUpdateManyWithWhereWithoutTaskInput
      | ActivityUpdateManyWithWhereWithoutTaskInput[];
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[];
  };

  export type AttendanceUpdateManyWithoutTaskNestedInput = {
    create?:
      | XOR<AttendanceCreateWithoutTaskInput, AttendanceUncheckedCreateWithoutTaskInput>
      | AttendanceCreateWithoutTaskInput[]
      | AttendanceUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | AttendanceCreateOrConnectWithoutTaskInput
      | AttendanceCreateOrConnectWithoutTaskInput[];
    upsert?:
      | AttendanceUpsertWithWhereUniqueWithoutTaskInput
      | AttendanceUpsertWithWhereUniqueWithoutTaskInput[];
    createMany?: AttendanceCreateManyTaskInputEnvelope;
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    update?:
      | AttendanceUpdateWithWhereUniqueWithoutTaskInput
      | AttendanceUpdateWithWhereUniqueWithoutTaskInput[];
    updateMany?:
      | AttendanceUpdateManyWithWhereWithoutTaskInput
      | AttendanceUpdateManyWithWhereWithoutTaskInput[];
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[];
  };

  export type CommentUpdateManyWithoutTaskNestedInput = {
    create?:
      | XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>
      | CommentCreateWithoutTaskInput[]
      | CommentUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutTaskInput
      | CommentCreateOrConnectWithoutTaskInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutTaskInput
      | CommentUpsertWithWhereUniqueWithoutTaskInput[];
    createMany?: CommentCreateManyTaskInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutTaskInput
      | CommentUpdateWithWhereUniqueWithoutTaskInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutTaskInput
      | CommentUpdateManyWithWhereWithoutTaskInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type TaskUpdateOneWithoutSubtasksNestedInput = {
    create?: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>;
    connectOrCreate?: TaskCreateOrConnectWithoutSubtasksInput;
    upsert?: TaskUpsertWithoutSubtasksInput;
    disconnect?: TaskWhereInput | boolean;
    delete?: TaskWhereInput | boolean;
    connect?: TaskWhereUniqueInput;
    update?: XOR<
      XOR<TaskUpdateToOneWithWhereWithoutSubtasksInput, TaskUpdateWithoutSubtasksInput>,
      TaskUncheckedUpdateWithoutSubtasksInput
    >;
  };

  export type TaskUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<TaskCreateWithoutParentInput, TaskUncheckedCreateWithoutParentInput>
      | TaskCreateWithoutParentInput[]
      | TaskUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutParentInput
      | TaskCreateOrConnectWithoutParentInput[];
    upsert?:
      | TaskUpsertWithWhereUniqueWithoutParentInput
      | TaskUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: TaskCreateManyParentInputEnvelope;
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    update?:
      | TaskUpdateWithWhereUniqueWithoutParentInput
      | TaskUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | TaskUpdateManyWithWhereWithoutParentInput
      | TaskUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[];
  };

  export type ProjectUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>;
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput;
    upsert?: ProjectUpsertWithoutTasksInput;
    connect?: ProjectWhereUniqueInput;
    update?: XOR<
      XOR<ProjectUpdateToOneWithWhereWithoutTasksInput, ProjectUpdateWithoutTasksInput>,
      ProjectUncheckedUpdateWithoutTasksInput
    >;
  };

  export type ProjectStatusUpdateOneWithoutTasksNestedInput = {
    create?: XOR<
      ProjectStatusCreateWithoutTasksInput,
      ProjectStatusUncheckedCreateWithoutTasksInput
    >;
    connectOrCreate?: ProjectStatusCreateOrConnectWithoutTasksInput;
    upsert?: ProjectStatusUpsertWithoutTasksInput;
    disconnect?: ProjectStatusWhereInput | boolean;
    delete?: ProjectStatusWhereInput | boolean;
    connect?: ProjectStatusWhereUniqueInput;
    update?: XOR<
      XOR<ProjectStatusUpdateToOneWithWhereWithoutTasksInput, ProjectStatusUpdateWithoutTasksInput>,
      ProjectStatusUncheckedUpdateWithoutTasksInput
    >;
  };

  export type TaskAssigneeUpdateManyWithoutTaskNestedInput = {
    create?:
      | XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput>
      | TaskAssigneeCreateWithoutTaskInput[]
      | TaskAssigneeUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | TaskAssigneeCreateOrConnectWithoutTaskInput
      | TaskAssigneeCreateOrConnectWithoutTaskInput[];
    upsert?:
      | TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput
      | TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput[];
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope;
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    update?:
      | TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput
      | TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput[];
    updateMany?:
      | TaskAssigneeUpdateManyWithWhereWithoutTaskInput
      | TaskAssigneeUpdateManyWithWhereWithoutTaskInput[];
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[];
  };

  export type TaskAttachmentUpdateManyWithoutTaskNestedInput = {
    create?:
      | XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput>
      | TaskAttachmentCreateWithoutTaskInput[]
      | TaskAttachmentUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | TaskAttachmentCreateOrConnectWithoutTaskInput
      | TaskAttachmentCreateOrConnectWithoutTaskInput[];
    upsert?:
      | TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput
      | TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput[];
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope;
    set?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    disconnect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    delete?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    update?:
      | TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput
      | TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput[];
    updateMany?:
      | TaskAttachmentUpdateManyWithWhereWithoutTaskInput
      | TaskAttachmentUpdateManyWithWhereWithoutTaskInput[];
    deleteMany?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[];
  };

  export type ActivityUncheckedUpdateManyWithoutTaskNestedInput = {
    create?:
      | XOR<ActivityCreateWithoutTaskInput, ActivityUncheckedCreateWithoutTaskInput>
      | ActivityCreateWithoutTaskInput[]
      | ActivityUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | ActivityCreateOrConnectWithoutTaskInput
      | ActivityCreateOrConnectWithoutTaskInput[];
    upsert?:
      | ActivityUpsertWithWhereUniqueWithoutTaskInput
      | ActivityUpsertWithWhereUniqueWithoutTaskInput[];
    createMany?: ActivityCreateManyTaskInputEnvelope;
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[];
    update?:
      | ActivityUpdateWithWhereUniqueWithoutTaskInput
      | ActivityUpdateWithWhereUniqueWithoutTaskInput[];
    updateMany?:
      | ActivityUpdateManyWithWhereWithoutTaskInput
      | ActivityUpdateManyWithWhereWithoutTaskInput[];
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[];
  };

  export type AttendanceUncheckedUpdateManyWithoutTaskNestedInput = {
    create?:
      | XOR<AttendanceCreateWithoutTaskInput, AttendanceUncheckedCreateWithoutTaskInput>
      | AttendanceCreateWithoutTaskInput[]
      | AttendanceUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | AttendanceCreateOrConnectWithoutTaskInput
      | AttendanceCreateOrConnectWithoutTaskInput[];
    upsert?:
      | AttendanceUpsertWithWhereUniqueWithoutTaskInput
      | AttendanceUpsertWithWhereUniqueWithoutTaskInput[];
    createMany?: AttendanceCreateManyTaskInputEnvelope;
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[];
    update?:
      | AttendanceUpdateWithWhereUniqueWithoutTaskInput
      | AttendanceUpdateWithWhereUniqueWithoutTaskInput[];
    updateMany?:
      | AttendanceUpdateManyWithWhereWithoutTaskInput
      | AttendanceUpdateManyWithWhereWithoutTaskInput[];
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[];
  };

  export type CommentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?:
      | XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>
      | CommentCreateWithoutTaskInput[]
      | CommentUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutTaskInput
      | CommentCreateOrConnectWithoutTaskInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutTaskInput
      | CommentUpsertWithWhereUniqueWithoutTaskInput[];
    createMany?: CommentCreateManyTaskInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutTaskInput
      | CommentUpdateWithWhereUniqueWithoutTaskInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutTaskInput
      | CommentUpdateManyWithWhereWithoutTaskInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type TaskUncheckedUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<TaskCreateWithoutParentInput, TaskUncheckedCreateWithoutParentInput>
      | TaskCreateWithoutParentInput[]
      | TaskUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutParentInput
      | TaskCreateOrConnectWithoutParentInput[];
    upsert?:
      | TaskUpsertWithWhereUniqueWithoutParentInput
      | TaskUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: TaskCreateManyParentInputEnvelope;
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    update?:
      | TaskUpdateWithWhereUniqueWithoutParentInput
      | TaskUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | TaskUpdateManyWithWhereWithoutParentInput
      | TaskUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[];
  };

  export type TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput = {
    create?:
      | XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput>
      | TaskAssigneeCreateWithoutTaskInput[]
      | TaskAssigneeUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | TaskAssigneeCreateOrConnectWithoutTaskInput
      | TaskAssigneeCreateOrConnectWithoutTaskInput[];
    upsert?:
      | TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput
      | TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput[];
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope;
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[];
    update?:
      | TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput
      | TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput[];
    updateMany?:
      | TaskAssigneeUpdateManyWithWhereWithoutTaskInput
      | TaskAssigneeUpdateManyWithWhereWithoutTaskInput[];
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[];
  };

  export type TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?:
      | XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput>
      | TaskAttachmentCreateWithoutTaskInput[]
      | TaskAttachmentUncheckedCreateWithoutTaskInput[];
    connectOrCreate?:
      | TaskAttachmentCreateOrConnectWithoutTaskInput
      | TaskAttachmentCreateOrConnectWithoutTaskInput[];
    upsert?:
      | TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput
      | TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput[];
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope;
    set?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    disconnect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    delete?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[];
    update?:
      | TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput
      | TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput[];
    updateMany?:
      | TaskAttachmentUpdateManyWithWhereWithoutTaskInput
      | TaskAttachmentUpdateManyWithWhereWithoutTaskInput[];
    deleteMany?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[];
  };

  export type TaskCreateNestedOneWithoutAssigneesInput = {
    create?: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>;
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneesInput;
    connect?: TaskWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutTaskAssignmentsInput = {
    create?: XOR<
      UserCreateWithoutTaskAssignmentsInput,
      UserUncheckedCreateWithoutTaskAssignmentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTaskAssignmentsInput;
    connect?: UserWhereUniqueInput;
  };

  export type TaskUpdateOneRequiredWithoutAssigneesNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>;
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneesInput;
    upsert?: TaskUpsertWithoutAssigneesInput;
    connect?: TaskWhereUniqueInput;
    update?: XOR<
      XOR<TaskUpdateToOneWithWhereWithoutAssigneesInput, TaskUpdateWithoutAssigneesInput>,
      TaskUncheckedUpdateWithoutAssigneesInput
    >;
  };

  export type UserUpdateOneRequiredWithoutTaskAssignmentsNestedInput = {
    create?: XOR<
      UserCreateWithoutTaskAssignmentsInput,
      UserUncheckedCreateWithoutTaskAssignmentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTaskAssignmentsInput;
    upsert?: UserUpsertWithoutTaskAssignmentsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutTaskAssignmentsInput,
        UserUpdateWithoutTaskAssignmentsInput
      >,
      UserUncheckedUpdateWithoutTaskAssignmentsInput
    >;
  };

  export type ProjectCreateNestedOneWithoutTeamMembersInput = {
    create?: XOR<
      ProjectCreateWithoutTeamMembersInput,
      ProjectUncheckedCreateWithoutTeamMembersInput
    >;
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamMembersInput;
    connect?: ProjectWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutTeamsInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput;
    connect?: UserWhereUniqueInput;
  };

  export type ProjectUpdateOneRequiredWithoutTeamMembersNestedInput = {
    create?: XOR<
      ProjectCreateWithoutTeamMembersInput,
      ProjectUncheckedCreateWithoutTeamMembersInput
    >;
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamMembersInput;
    upsert?: ProjectUpsertWithoutTeamMembersInput;
    connect?: ProjectWhereUniqueInput;
    update?: XOR<
      XOR<ProjectUpdateToOneWithWhereWithoutTeamMembersInput, ProjectUpdateWithoutTeamMembersInput>,
      ProjectUncheckedUpdateWithoutTeamMembersInput
    >;
  };

  export type UserUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput;
    upsert?: UserUpsertWithoutTeamsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutTeamsInput, UserUpdateWithoutTeamsInput>,
      UserUncheckedUpdateWithoutTeamsInput
    >;
  };

  export type ProjectCreateNestedOneWithoutEventsInput = {
    create?: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>;
    connectOrCreate?: ProjectCreateOrConnectWithoutEventsInput;
    connect?: ProjectWhereUniqueInput;
  };

  export type ProjectUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>;
    connectOrCreate?: ProjectCreateOrConnectWithoutEventsInput;
    upsert?: ProjectUpsertWithoutEventsInput;
    connect?: ProjectWhereUniqueInput;
    update?: XOR<
      XOR<ProjectUpdateToOneWithWhereWithoutEventsInput, ProjectUpdateWithoutEventsInput>,
      ProjectUncheckedUpdateWithoutEventsInput
    >;
  };

  export type ProjectCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<
      ProjectCreateWithoutAttendancesInput,
      ProjectUncheckedCreateWithoutAttendancesInput
    >;
    connectOrCreate?: ProjectCreateOrConnectWithoutAttendancesInput;
    connect?: ProjectWhereUniqueInput;
  };

  export type TaskCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<TaskCreateWithoutAttendancesInput, TaskUncheckedCreateWithoutAttendancesInput>;
    connectOrCreate?: TaskCreateOrConnectWithoutAttendancesInput;
    connect?: TaskWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutAttendanceRecordsInput = {
    create?: XOR<
      UserCreateWithoutAttendanceRecordsInput,
      UserUncheckedCreateWithoutAttendanceRecordsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceRecordsInput;
    connect?: UserWhereUniqueInput;
  };

  export type AttendanceCorrectionRequestCreateNestedManyWithoutAttendanceInput = {
    create?:
      | XOR<
          AttendanceCorrectionRequestCreateWithoutAttendanceInput,
          AttendanceCorrectionRequestUncheckedCreateWithoutAttendanceInput
        >
      | AttendanceCorrectionRequestCreateWithoutAttendanceInput[]
      | AttendanceCorrectionRequestUncheckedCreateWithoutAttendanceInput[];
    connectOrCreate?:
      | AttendanceCorrectionRequestCreateOrConnectWithoutAttendanceInput
      | AttendanceCorrectionRequestCreateOrConnectWithoutAttendanceInput[];
    createMany?: AttendanceCorrectionRequestCreateManyAttendanceInputEnvelope;
    connect?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
  };

  export type AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutAttendanceInput = {
    create?:
      | XOR<
          AttendanceCorrectionRequestCreateWithoutAttendanceInput,
          AttendanceCorrectionRequestUncheckedCreateWithoutAttendanceInput
        >
      | AttendanceCorrectionRequestCreateWithoutAttendanceInput[]
      | AttendanceCorrectionRequestUncheckedCreateWithoutAttendanceInput[];
    connectOrCreate?:
      | AttendanceCorrectionRequestCreateOrConnectWithoutAttendanceInput
      | AttendanceCorrectionRequestCreateOrConnectWithoutAttendanceInput[];
    createMany?: AttendanceCorrectionRequestCreateManyAttendanceInputEnvelope;
    connect?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
  };

  export type ProjectUpdateOneWithoutAttendancesNestedInput = {
    create?: XOR<
      ProjectCreateWithoutAttendancesInput,
      ProjectUncheckedCreateWithoutAttendancesInput
    >;
    connectOrCreate?: ProjectCreateOrConnectWithoutAttendancesInput;
    upsert?: ProjectUpsertWithoutAttendancesInput;
    disconnect?: ProjectWhereInput | boolean;
    delete?: ProjectWhereInput | boolean;
    connect?: ProjectWhereUniqueInput;
    update?: XOR<
      XOR<ProjectUpdateToOneWithWhereWithoutAttendancesInput, ProjectUpdateWithoutAttendancesInput>,
      ProjectUncheckedUpdateWithoutAttendancesInput
    >;
  };

  export type TaskUpdateOneWithoutAttendancesNestedInput = {
    create?: XOR<TaskCreateWithoutAttendancesInput, TaskUncheckedCreateWithoutAttendancesInput>;
    connectOrCreate?: TaskCreateOrConnectWithoutAttendancesInput;
    upsert?: TaskUpsertWithoutAttendancesInput;
    disconnect?: TaskWhereInput | boolean;
    delete?: TaskWhereInput | boolean;
    connect?: TaskWhereUniqueInput;
    update?: XOR<
      XOR<TaskUpdateToOneWithWhereWithoutAttendancesInput, TaskUpdateWithoutAttendancesInput>,
      TaskUncheckedUpdateWithoutAttendancesInput
    >;
  };

  export type UserUpdateOneRequiredWithoutAttendanceRecordsNestedInput = {
    create?: XOR<
      UserCreateWithoutAttendanceRecordsInput,
      UserUncheckedCreateWithoutAttendanceRecordsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceRecordsInput;
    upsert?: UserUpsertWithoutAttendanceRecordsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAttendanceRecordsInput,
        UserUpdateWithoutAttendanceRecordsInput
      >,
      UserUncheckedUpdateWithoutAttendanceRecordsInput
    >;
  };

  export type AttendanceCorrectionRequestUpdateManyWithoutAttendanceNestedInput = {
    create?:
      | XOR<
          AttendanceCorrectionRequestCreateWithoutAttendanceInput,
          AttendanceCorrectionRequestUncheckedCreateWithoutAttendanceInput
        >
      | AttendanceCorrectionRequestCreateWithoutAttendanceInput[]
      | AttendanceCorrectionRequestUncheckedCreateWithoutAttendanceInput[];
    connectOrCreate?:
      | AttendanceCorrectionRequestCreateOrConnectWithoutAttendanceInput
      | AttendanceCorrectionRequestCreateOrConnectWithoutAttendanceInput[];
    upsert?:
      | AttendanceCorrectionRequestUpsertWithWhereUniqueWithoutAttendanceInput
      | AttendanceCorrectionRequestUpsertWithWhereUniqueWithoutAttendanceInput[];
    createMany?: AttendanceCorrectionRequestCreateManyAttendanceInputEnvelope;
    set?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    disconnect?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    delete?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    connect?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    update?:
      | AttendanceCorrectionRequestUpdateWithWhereUniqueWithoutAttendanceInput
      | AttendanceCorrectionRequestUpdateWithWhereUniqueWithoutAttendanceInput[];
    updateMany?:
      | AttendanceCorrectionRequestUpdateManyWithWhereWithoutAttendanceInput
      | AttendanceCorrectionRequestUpdateManyWithWhereWithoutAttendanceInput[];
    deleteMany?:
      | AttendanceCorrectionRequestScalarWhereInput
      | AttendanceCorrectionRequestScalarWhereInput[];
  };

  export type AttendanceCorrectionRequestUncheckedUpdateManyWithoutAttendanceNestedInput = {
    create?:
      | XOR<
          AttendanceCorrectionRequestCreateWithoutAttendanceInput,
          AttendanceCorrectionRequestUncheckedCreateWithoutAttendanceInput
        >
      | AttendanceCorrectionRequestCreateWithoutAttendanceInput[]
      | AttendanceCorrectionRequestUncheckedCreateWithoutAttendanceInput[];
    connectOrCreate?:
      | AttendanceCorrectionRequestCreateOrConnectWithoutAttendanceInput
      | AttendanceCorrectionRequestCreateOrConnectWithoutAttendanceInput[];
    upsert?:
      | AttendanceCorrectionRequestUpsertWithWhereUniqueWithoutAttendanceInput
      | AttendanceCorrectionRequestUpsertWithWhereUniqueWithoutAttendanceInput[];
    createMany?: AttendanceCorrectionRequestCreateManyAttendanceInputEnvelope;
    set?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    disconnect?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    delete?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    connect?:
      | AttendanceCorrectionRequestWhereUniqueInput
      | AttendanceCorrectionRequestWhereUniqueInput[];
    update?:
      | AttendanceCorrectionRequestUpdateWithWhereUniqueWithoutAttendanceInput
      | AttendanceCorrectionRequestUpdateWithWhereUniqueWithoutAttendanceInput[];
    updateMany?:
      | AttendanceCorrectionRequestUpdateManyWithWhereWithoutAttendanceInput
      | AttendanceCorrectionRequestUpdateManyWithWhereWithoutAttendanceInput[];
    deleteMany?:
      | AttendanceCorrectionRequestScalarWhereInput
      | AttendanceCorrectionRequestScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutAttendanceSettingsInput = {
    create?: XOR<
      UserCreateWithoutAttendanceSettingsInput,
      UserUncheckedCreateWithoutAttendanceSettingsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceSettingsInput;
    connect?: UserWhereUniqueInput;
  };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutAttendanceSettingsNestedInput = {
    create?: XOR<
      UserCreateWithoutAttendanceSettingsInput,
      UserUncheckedCreateWithoutAttendanceSettingsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceSettingsInput;
    upsert?: UserUpsertWithoutAttendanceSettingsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAttendanceSettingsInput,
        UserUpdateWithoutAttendanceSettingsInput
      >,
      UserUncheckedUpdateWithoutAttendanceSettingsInput
    >;
  };

  export type ProjectCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>;
    connectOrCreate?: ProjectCreateOrConnectWithoutActivitiesInput;
    connect?: ProjectWhereUniqueInput;
  };

  export type TaskCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<TaskCreateWithoutActivitiesInput, TaskUncheckedCreateWithoutActivitiesInput>;
    connectOrCreate?: TaskCreateOrConnectWithoutActivitiesInput;
    connect?: TaskWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput;
    connect?: UserWhereUniqueInput;
  };

  export type ProjectUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>;
    connectOrCreate?: ProjectCreateOrConnectWithoutActivitiesInput;
    upsert?: ProjectUpsertWithoutActivitiesInput;
    disconnect?: ProjectWhereInput | boolean;
    delete?: ProjectWhereInput | boolean;
    connect?: ProjectWhereUniqueInput;
    update?: XOR<
      XOR<ProjectUpdateToOneWithWhereWithoutActivitiesInput, ProjectUpdateWithoutActivitiesInput>,
      ProjectUncheckedUpdateWithoutActivitiesInput
    >;
  };

  export type TaskUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<TaskCreateWithoutActivitiesInput, TaskUncheckedCreateWithoutActivitiesInput>;
    connectOrCreate?: TaskCreateOrConnectWithoutActivitiesInput;
    upsert?: TaskUpsertWithoutActivitiesInput;
    disconnect?: TaskWhereInput | boolean;
    delete?: TaskWhereInput | boolean;
    connect?: TaskWhereUniqueInput;
    update?: XOR<
      XOR<TaskUpdateToOneWithWhereWithoutActivitiesInput, TaskUpdateWithoutActivitiesInput>,
      TaskUncheckedUpdateWithoutActivitiesInput
    >;
  };

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput;
    upsert?: UserUpsertWithoutActivitiesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>,
      UserUncheckedUpdateWithoutActivitiesInput
    >;
  };

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput;
    upsert?: UserUpsertWithoutDocumentsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutDocumentsInput, UserUpdateWithoutDocumentsInput>,
      UserUncheckedUpdateWithoutDocumentsInput
    >;
  };

  export type AttendanceCreateNestedOneWithoutCorrectionRequestsInput = {
    create?: XOR<
      AttendanceCreateWithoutCorrectionRequestsInput,
      AttendanceUncheckedCreateWithoutCorrectionRequestsInput
    >;
    connectOrCreate?: AttendanceCreateOrConnectWithoutCorrectionRequestsInput;
    connect?: AttendanceWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutCorrectionRequestsInput = {
    create?: XOR<
      UserCreateWithoutCorrectionRequestsInput,
      UserUncheckedCreateWithoutCorrectionRequestsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCorrectionRequestsInput;
    connect?: UserWhereUniqueInput;
  };

  export type AttendanceUpdateOneRequiredWithoutCorrectionRequestsNestedInput = {
    create?: XOR<
      AttendanceCreateWithoutCorrectionRequestsInput,
      AttendanceUncheckedCreateWithoutCorrectionRequestsInput
    >;
    connectOrCreate?: AttendanceCreateOrConnectWithoutCorrectionRequestsInput;
    upsert?: AttendanceUpsertWithoutCorrectionRequestsInput;
    connect?: AttendanceWhereUniqueInput;
    update?: XOR<
      XOR<
        AttendanceUpdateToOneWithWhereWithoutCorrectionRequestsInput,
        AttendanceUpdateWithoutCorrectionRequestsInput
      >,
      AttendanceUncheckedUpdateWithoutCorrectionRequestsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutCorrectionRequestsNestedInput = {
    create?: XOR<
      UserCreateWithoutCorrectionRequestsInput,
      UserUncheckedCreateWithoutCorrectionRequestsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCorrectionRequestsInput;
    upsert?: UserUpsertWithoutCorrectionRequestsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutCorrectionRequestsInput,
        UserUpdateWithoutCorrectionRequestsInput
      >,
      UserUncheckedUpdateWithoutCorrectionRequestsInput
    >;
  };

  export type TaskCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>;
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput;
    connect?: TaskWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput;
    connect?: UserWhereUniqueInput;
  };

  export type TaskUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>;
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput;
    upsert?: TaskUpsertWithoutCommentsInput;
    connect?: TaskWhereUniqueInput;
    update?: XOR<
      XOR<TaskUpdateToOneWithWhereWithoutCommentsInput, TaskUpdateWithoutCommentsInput>,
      TaskUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput;
    upsert?: UserUpsertWithoutCommentsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>,
      UserUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type TaskCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>;
    connectOrCreate?: TaskCreateOrConnectWithoutAttachmentsInput;
    connect?: TaskWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutTaskAttachmentsInput = {
    create?: XOR<
      UserCreateWithoutTaskAttachmentsInput,
      UserUncheckedCreateWithoutTaskAttachmentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTaskAttachmentsInput;
    connect?: UserWhereUniqueInput;
  };

  export type TaskUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>;
    connectOrCreate?: TaskCreateOrConnectWithoutAttachmentsInput;
    upsert?: TaskUpsertWithoutAttachmentsInput;
    connect?: TaskWhereUniqueInput;
    update?: XOR<
      XOR<TaskUpdateToOneWithWhereWithoutAttachmentsInput, TaskUpdateWithoutAttachmentsInput>,
      TaskUncheckedUpdateWithoutAttachmentsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutTaskAttachmentsNestedInput = {
    create?: XOR<
      UserCreateWithoutTaskAttachmentsInput,
      UserUncheckedCreateWithoutTaskAttachmentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTaskAttachmentsInput;
    upsert?: UserUpsertWithoutTaskAttachmentsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutTaskAttachmentsInput,
        UserUpdateWithoutTaskAttachmentsInput
      >,
      UserUncheckedUpdateWithoutTaskAttachmentsInput
    >;
  };

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
      | RolePermissionCreateWithoutRoleInput[]
      | RolePermissionUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | RolePermissionCreateOrConnectWithoutRoleInput
      | RolePermissionCreateOrConnectWithoutRoleInput[];
    createMany?: RolePermissionCreateManyRoleInputEnvelope;
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
  };

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
      | RolePermissionCreateWithoutRoleInput[]
      | RolePermissionUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | RolePermissionCreateOrConnectWithoutRoleInput
      | RolePermissionCreateOrConnectWithoutRoleInput[];
    createMany?: RolePermissionCreateManyRoleInputEnvelope;
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
  };

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
      | RolePermissionCreateWithoutRoleInput[]
      | RolePermissionUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | RolePermissionCreateOrConnectWithoutRoleInput
      | RolePermissionCreateOrConnectWithoutRoleInput[];
    upsert?:
      | RolePermissionUpsertWithWhereUniqueWithoutRoleInput
      | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: RolePermissionCreateManyRoleInputEnvelope;
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    update?:
      | RolePermissionUpdateWithWhereUniqueWithoutRoleInput
      | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?:
      | RolePermissionUpdateManyWithWhereWithoutRoleInput
      | RolePermissionUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[];
  };

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
      | RolePermissionCreateWithoutRoleInput[]
      | RolePermissionUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | RolePermissionCreateOrConnectWithoutRoleInput
      | RolePermissionCreateOrConnectWithoutRoleInput[];
    upsert?:
      | RolePermissionUpsertWithWhereUniqueWithoutRoleInput
      | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: RolePermissionCreateManyRoleInputEnvelope;
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    update?:
      | RolePermissionUpdateWithWhereUniqueWithoutRoleInput
      | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?:
      | RolePermissionUpdateManyWithWhereWithoutRoleInput
      | RolePermissionUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[];
  };

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?:
      | XOR<
          RolePermissionCreateWithoutPermissionInput,
          RolePermissionUncheckedCreateWithoutPermissionInput
        >
      | RolePermissionCreateWithoutPermissionInput[]
      | RolePermissionUncheckedCreateWithoutPermissionInput[];
    connectOrCreate?:
      | RolePermissionCreateOrConnectWithoutPermissionInput
      | RolePermissionCreateOrConnectWithoutPermissionInput[];
    createMany?: RolePermissionCreateManyPermissionInputEnvelope;
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
  };

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?:
      | XOR<
          RolePermissionCreateWithoutPermissionInput,
          RolePermissionUncheckedCreateWithoutPermissionInput
        >
      | RolePermissionCreateWithoutPermissionInput[]
      | RolePermissionUncheckedCreateWithoutPermissionInput[];
    connectOrCreate?:
      | RolePermissionCreateOrConnectWithoutPermissionInput
      | RolePermissionCreateOrConnectWithoutPermissionInput[];
    createMany?: RolePermissionCreateManyPermissionInputEnvelope;
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
  };

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?:
      | XOR<
          RolePermissionCreateWithoutPermissionInput,
          RolePermissionUncheckedCreateWithoutPermissionInput
        >
      | RolePermissionCreateWithoutPermissionInput[]
      | RolePermissionUncheckedCreateWithoutPermissionInput[];
    connectOrCreate?:
      | RolePermissionCreateOrConnectWithoutPermissionInput
      | RolePermissionCreateOrConnectWithoutPermissionInput[];
    upsert?:
      | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput
      | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[];
    createMany?: RolePermissionCreateManyPermissionInputEnvelope;
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    update?:
      | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput
      | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[];
    updateMany?:
      | RolePermissionUpdateManyWithWhereWithoutPermissionInput
      | RolePermissionUpdateManyWithWhereWithoutPermissionInput[];
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[];
  };

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?:
      | XOR<
          RolePermissionCreateWithoutPermissionInput,
          RolePermissionUncheckedCreateWithoutPermissionInput
        >
      | RolePermissionCreateWithoutPermissionInput[]
      | RolePermissionUncheckedCreateWithoutPermissionInput[];
    connectOrCreate?:
      | RolePermissionCreateOrConnectWithoutPermissionInput
      | RolePermissionCreateOrConnectWithoutPermissionInput[];
    upsert?:
      | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput
      | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[];
    createMany?: RolePermissionCreateManyPermissionInputEnvelope;
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[];
    update?:
      | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput
      | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[];
    updateMany?:
      | RolePermissionUpdateManyWithWhereWithoutPermissionInput
      | RolePermissionUpdateManyWithWhereWithoutPermissionInput[];
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[];
  };

  export type PermissionCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>;
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput;
    connect?: PermissionWhereUniqueInput;
  };

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>;
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput;
    connect?: RoleWhereUniqueInput;
  };

  export type PermissionUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>;
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput;
    upsert?: PermissionUpsertWithoutRolesInput;
    connect?: PermissionWhereUniqueInput;
    update?: XOR<
      XOR<PermissionUpdateToOneWithWhereWithoutRolesInput, PermissionUpdateWithoutRolesInput>,
      PermissionUncheckedUpdateWithoutRolesInput
    >;
  };

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>;
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput;
    upsert?: RoleUpsertWithoutPermissionsInput;
    connect?: RoleWhereUniqueInput;
    update?: XOR<
      XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>,
      RoleUncheckedUpdateWithoutPermissionsInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[];
    notIn?: string[];
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | null;
    notIn?: Date[] | string[] | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[];
    notIn?: Date[] | string[];
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[];
    notIn?: string[];
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | null;
    notIn?: Date[] | string[] | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[];
    notIn?: Date[] | string[];
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type AccountCreateWithoutUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput;
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>;
  };

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ActivityCreateWithoutUserInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    description?: string | null;
    createdAt?: Date | string;
    project?: ProjectCreateNestedOneWithoutActivitiesInput;
    task?: TaskCreateNestedOneWithoutActivitiesInput;
  };

  export type ActivityUncheckedCreateWithoutUserInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    description?: string | null;
    projectId?: string | null;
    taskId?: string | null;
    createdAt?: Date | string;
  };

  export type ActivityCreateOrConnectWithoutUserInput = {
    where: ActivityWhereUniqueInput;
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>;
  };

  export type ActivityCreateManyUserInputEnvelope = {
    data: ActivityCreateManyUserInput | ActivityCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AttendanceCreateWithoutUserInput = {
    id?: string;
    checkInTime?: Date | string;
    checkOutTime?: Date | string | null;
    checkInLatitude?: number | null;
    checkInLongitude?: number | null;
    checkOutLatitude?: number | null;
    checkOutLongitude?: number | null;
    checkInIpAddress?: string | null;
    checkOutIpAddress?: string | null;
    checkInDeviceInfo?: string | null;
    checkOutDeviceInfo?: string | null;
    totalHours?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    checkInLocationName?: string | null;
    checkOutLocationName?: string | null;
    autoCheckout?: boolean;
    project?: ProjectCreateNestedOneWithoutAttendancesInput;
    task?: TaskCreateNestedOneWithoutAttendancesInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutAttendanceInput;
  };

  export type AttendanceUncheckedCreateWithoutUserInput = {
    id?: string;
    checkInTime?: Date | string;
    checkOutTime?: Date | string | null;
    checkInLatitude?: number | null;
    checkInLongitude?: number | null;
    checkOutLatitude?: number | null;
    checkOutLongitude?: number | null;
    checkInIpAddress?: string | null;
    checkOutIpAddress?: string | null;
    checkInDeviceInfo?: string | null;
    checkOutDeviceInfo?: string | null;
    totalHours?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    checkInLocationName?: string | null;
    checkOutLocationName?: string | null;
    projectId?: string | null;
    taskId?: string | null;
    autoCheckout?: boolean;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutAttendanceInput;
  };

  export type AttendanceCreateOrConnectWithoutUserInput = {
    where: AttendanceWhereUniqueInput;
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>;
  };

  export type AttendanceCreateManyUserInputEnvelope = {
    data: AttendanceCreateManyUserInput | AttendanceCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AttendanceCorrectionRequestCreateWithoutUserInput = {
    id?: string;
    originalCheckInTime: Date | string;
    originalCheckOutTime?: Date | string | null;
    requestedCheckInTime: Date | string;
    requestedCheckOutTime?: Date | string | null;
    reason: string;
    status?: string;
    reviewedBy?: string | null;
    reviewedAt?: Date | string | null;
    reviewNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    attendance: AttendanceCreateNestedOneWithoutCorrectionRequestsInput;
  };

  export type AttendanceCorrectionRequestUncheckedCreateWithoutUserInput = {
    id?: string;
    attendanceId: string;
    originalCheckInTime: Date | string;
    originalCheckOutTime?: Date | string | null;
    requestedCheckInTime: Date | string;
    requestedCheckOutTime?: Date | string | null;
    reason: string;
    status?: string;
    reviewedBy?: string | null;
    reviewedAt?: Date | string | null;
    reviewNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AttendanceCorrectionRequestCreateOrConnectWithoutUserInput = {
    where: AttendanceCorrectionRequestWhereUniqueInput;
    create: XOR<
      AttendanceCorrectionRequestCreateWithoutUserInput,
      AttendanceCorrectionRequestUncheckedCreateWithoutUserInput
    >;
  };

  export type AttendanceCorrectionRequestCreateManyUserInputEnvelope = {
    data:
      | AttendanceCorrectionRequestCreateManyUserInput
      | AttendanceCorrectionRequestCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AttendanceSettingsCreateWithoutUserInput = {
    id?: string;
    workHoursPerDay?: number;
    workDays?: string;
    reminderEnabled?: boolean;
    reminderTime?: string | null;
    autoCheckoutEnabled?: boolean;
    autoCheckoutTime?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AttendanceSettingsUncheckedCreateWithoutUserInput = {
    id?: string;
    workHoursPerDay?: number;
    workDays?: string;
    reminderEnabled?: boolean;
    reminderTime?: string | null;
    autoCheckoutEnabled?: boolean;
    autoCheckoutTime?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AttendanceSettingsCreateOrConnectWithoutUserInput = {
    where: AttendanceSettingsWhereUniqueInput;
    create: XOR<
      AttendanceSettingsCreateWithoutUserInput,
      AttendanceSettingsUncheckedCreateWithoutUserInput
    >;
  };

  export type CommentCreateWithoutUserInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    task: TaskCreateNestedOneWithoutCommentsInput;
  };

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string;
    content: string;
    taskId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput;
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>;
  };

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type DocumentCreateWithoutUserInput = {
    id?: string;
    name: string;
    description?: string | null;
    fileType: string;
    fileSize: number;
    filePath: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DocumentUncheckedCreateWithoutUserInput = {
    id?: string;
    name: string;
    description?: string | null;
    fileType: string;
    fileSize: number;
    filePath: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DocumentCreateOrConnectWithoutUserInput = {
    where: DocumentWhereUniqueInput;
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>;
  };

  export type DocumentCreateManyUserInputEnvelope = {
    data: DocumentCreateManyUserInput | DocumentCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ProjectCreateWithoutCreatedByInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    activities?: ActivityCreateNestedManyWithoutProjectInput;
    attendances?: AttendanceCreateNestedManyWithoutProjectInput;
    events?: EventCreateNestedManyWithoutProjectInput;
    statuses?: ProjectStatusCreateNestedManyWithoutProjectInput;
    tasks?: TaskCreateNestedManyWithoutProjectInput;
    teamMembers?: TeamMemberCreateNestedManyWithoutProjectInput;
  };

  export type ProjectUncheckedCreateWithoutCreatedByInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutProjectInput;
    events?: EventUncheckedCreateNestedManyWithoutProjectInput;
    statuses?: ProjectStatusUncheckedCreateNestedManyWithoutProjectInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput;
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutProjectInput;
  };

  export type ProjectCreateOrConnectWithoutCreatedByInput = {
    where: ProjectWhereUniqueInput;
    create: XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput>;
  };

  export type ProjectCreateManyCreatedByInputEnvelope = {
    data: ProjectCreateManyCreatedByInput | ProjectCreateManyCreatedByInput[];
    skipDuplicates?: boolean;
  };

  export type SessionCreateWithoutUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput;
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>;
  };

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type TaskAssigneeCreateWithoutUserInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    task: TaskCreateNestedOneWithoutAssigneesInput;
  };

  export type TaskAssigneeUncheckedCreateWithoutUserInput = {
    id?: string;
    taskId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TaskAssigneeCreateOrConnectWithoutUserInput = {
    where: TaskAssigneeWhereUniqueInput;
    create: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput>;
  };

  export type TaskAssigneeCreateManyUserInputEnvelope = {
    data: TaskAssigneeCreateManyUserInput | TaskAssigneeCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type TaskAttachmentCreateWithoutUserInput = {
    id?: string;
    filename: string;
    fileUrl: string;
    fileSize: number;
    fileType: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    task: TaskCreateNestedOneWithoutAttachmentsInput;
  };

  export type TaskAttachmentUncheckedCreateWithoutUserInput = {
    id?: string;
    filename: string;
    fileUrl: string;
    fileSize: number;
    fileType: string;
    taskId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TaskAttachmentCreateOrConnectWithoutUserInput = {
    where: TaskAttachmentWhereUniqueInput;
    create: XOR<
      TaskAttachmentCreateWithoutUserInput,
      TaskAttachmentUncheckedCreateWithoutUserInput
    >;
  };

  export type TaskAttachmentCreateManyUserInputEnvelope = {
    data: TaskAttachmentCreateManyUserInput | TaskAttachmentCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type TeamMemberCreateWithoutUserInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    project: ProjectCreateNestedOneWithoutTeamMembersInput;
  };

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    id?: string;
    projectId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput;
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>;
  };

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>;
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>;
  };

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>;
  };

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput;
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>;
  };

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[];
    OR?: AccountScalarWhereInput[];
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[];
    id?: StringFilter<'Account'> | string;
    userId?: StringFilter<'Account'> | string;
    type?: StringFilter<'Account'> | string;
    provider?: StringFilter<'Account'> | string;
    providerAccountId?: StringFilter<'Account'> | string;
    refresh_token?: StringNullableFilter<'Account'> | string | null;
    access_token?: StringNullableFilter<'Account'> | string | null;
    expires_at?: IntNullableFilter<'Account'> | number | null;
    token_type?: StringNullableFilter<'Account'> | string | null;
    scope?: StringNullableFilter<'Account'> | string | null;
    id_token?: StringNullableFilter<'Account'> | string | null;
    session_state?: StringNullableFilter<'Account'> | string | null;
  };

  export type ActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput;
    update: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>;
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>;
  };

  export type ActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput;
    data: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>;
  };

  export type ActivityUpdateManyWithWhereWithoutUserInput = {
    where: ActivityScalarWhereInput;
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutUserInput>;
  };

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[];
    OR?: ActivityScalarWhereInput[];
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[];
    id?: StringFilter<'Activity'> | string;
    action?: StringFilter<'Activity'> | string;
    entityType?: StringFilter<'Activity'> | string;
    entityId?: StringFilter<'Activity'> | string;
    description?: StringNullableFilter<'Activity'> | string | null;
    userId?: StringFilter<'Activity'> | string;
    projectId?: StringNullableFilter<'Activity'> | string | null;
    taskId?: StringNullableFilter<'Activity'> | string | null;
    createdAt?: DateTimeFilter<'Activity'> | Date | string;
  };

  export type AttendanceUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput;
    update: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>;
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>;
  };

  export type AttendanceUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput;
    data: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>;
  };

  export type AttendanceUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceScalarWhereInput;
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutUserInput>;
  };

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[];
    OR?: AttendanceScalarWhereInput[];
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[];
    id?: StringFilter<'Attendance'> | string;
    userId?: StringFilter<'Attendance'> | string;
    checkInTime?: DateTimeFilter<'Attendance'> | Date | string;
    checkOutTime?: DateTimeNullableFilter<'Attendance'> | Date | string | null;
    checkInLatitude?: FloatNullableFilter<'Attendance'> | number | null;
    checkInLongitude?: FloatNullableFilter<'Attendance'> | number | null;
    checkOutLatitude?: FloatNullableFilter<'Attendance'> | number | null;
    checkOutLongitude?: FloatNullableFilter<'Attendance'> | number | null;
    checkInIpAddress?: StringNullableFilter<'Attendance'> | string | null;
    checkOutIpAddress?: StringNullableFilter<'Attendance'> | string | null;
    checkInDeviceInfo?: StringNullableFilter<'Attendance'> | string | null;
    checkOutDeviceInfo?: StringNullableFilter<'Attendance'> | string | null;
    totalHours?: FloatNullableFilter<'Attendance'> | number | null;
    notes?: StringNullableFilter<'Attendance'> | string | null;
    createdAt?: DateTimeFilter<'Attendance'> | Date | string;
    updatedAt?: DateTimeFilter<'Attendance'> | Date | string;
    checkInLocationName?: StringNullableFilter<'Attendance'> | string | null;
    checkOutLocationName?: StringNullableFilter<'Attendance'> | string | null;
    projectId?: StringNullableFilter<'Attendance'> | string | null;
    taskId?: StringNullableFilter<'Attendance'> | string | null;
    autoCheckout?: BoolFilter<'Attendance'> | boolean;
  };

  export type AttendanceCorrectionRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceCorrectionRequestWhereUniqueInput;
    update: XOR<
      AttendanceCorrectionRequestUpdateWithoutUserInput,
      AttendanceCorrectionRequestUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      AttendanceCorrectionRequestCreateWithoutUserInput,
      AttendanceCorrectionRequestUncheckedCreateWithoutUserInput
    >;
  };

  export type AttendanceCorrectionRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceCorrectionRequestWhereUniqueInput;
    data: XOR<
      AttendanceCorrectionRequestUpdateWithoutUserInput,
      AttendanceCorrectionRequestUncheckedUpdateWithoutUserInput
    >;
  };

  export type AttendanceCorrectionRequestUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceCorrectionRequestScalarWhereInput;
    data: XOR<
      AttendanceCorrectionRequestUpdateManyMutationInput,
      AttendanceCorrectionRequestUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type AttendanceCorrectionRequestScalarWhereInput = {
    AND?:
      | AttendanceCorrectionRequestScalarWhereInput
      | AttendanceCorrectionRequestScalarWhereInput[];
    OR?: AttendanceCorrectionRequestScalarWhereInput[];
    NOT?:
      | AttendanceCorrectionRequestScalarWhereInput
      | AttendanceCorrectionRequestScalarWhereInput[];
    id?: StringFilter<'AttendanceCorrectionRequest'> | string;
    attendanceId?: StringFilter<'AttendanceCorrectionRequest'> | string;
    userId?: StringFilter<'AttendanceCorrectionRequest'> | string;
    originalCheckInTime?: DateTimeFilter<'AttendanceCorrectionRequest'> | Date | string;
    originalCheckOutTime?:
      | DateTimeNullableFilter<'AttendanceCorrectionRequest'>
      | Date
      | string
      | null;
    requestedCheckInTime?: DateTimeFilter<'AttendanceCorrectionRequest'> | Date | string;
    requestedCheckOutTime?:
      | DateTimeNullableFilter<'AttendanceCorrectionRequest'>
      | Date
      | string
      | null;
    reason?: StringFilter<'AttendanceCorrectionRequest'> | string;
    status?: StringFilter<'AttendanceCorrectionRequest'> | string;
    reviewedBy?: StringNullableFilter<'AttendanceCorrectionRequest'> | string | null;
    reviewedAt?: DateTimeNullableFilter<'AttendanceCorrectionRequest'> | Date | string | null;
    reviewNotes?: StringNullableFilter<'AttendanceCorrectionRequest'> | string | null;
    createdAt?: DateTimeFilter<'AttendanceCorrectionRequest'> | Date | string;
    updatedAt?: DateTimeFilter<'AttendanceCorrectionRequest'> | Date | string;
  };

  export type AttendanceSettingsUpsertWithoutUserInput = {
    update: XOR<
      AttendanceSettingsUpdateWithoutUserInput,
      AttendanceSettingsUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      AttendanceSettingsCreateWithoutUserInput,
      AttendanceSettingsUncheckedCreateWithoutUserInput
    >;
    where?: AttendanceSettingsWhereInput;
  };

  export type AttendanceSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: AttendanceSettingsWhereInput;
    data: XOR<
      AttendanceSettingsUpdateWithoutUserInput,
      AttendanceSettingsUncheckedUpdateWithoutUserInput
    >;
  };

  export type AttendanceSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    workHoursPerDay?: FloatFieldUpdateOperationsInput | number;
    workDays?: StringFieldUpdateOperationsInput | string;
    reminderEnabled?: BoolFieldUpdateOperationsInput | boolean;
    reminderTime?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckoutEnabled?: BoolFieldUpdateOperationsInput | boolean;
    autoCheckoutTime?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AttendanceSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    workHoursPerDay?: FloatFieldUpdateOperationsInput | number;
    workDays?: StringFieldUpdateOperationsInput | string;
    reminderEnabled?: BoolFieldUpdateOperationsInput | boolean;
    reminderTime?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckoutEnabled?: BoolFieldUpdateOperationsInput | boolean;
    autoCheckoutTime?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput;
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>;
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>;
  };

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput;
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>;
  };

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput;
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>;
  };

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[];
    OR?: CommentScalarWhereInput[];
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[];
    id?: StringFilter<'Comment'> | string;
    content?: StringFilter<'Comment'> | string;
    taskId?: StringFilter<'Comment'> | string;
    userId?: StringFilter<'Comment'> | string;
    createdAt?: DateTimeFilter<'Comment'> | Date | string;
    updatedAt?: DateTimeFilter<'Comment'> | Date | string;
  };

  export type DocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput;
    update: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>;
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>;
  };

  export type DocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput;
    data: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>;
  };

  export type DocumentUpdateManyWithWhereWithoutUserInput = {
    where: DocumentScalarWhereInput;
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUserInput>;
  };

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
    OR?: DocumentScalarWhereInput[];
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
    id?: StringFilter<'Document'> | string;
    name?: StringFilter<'Document'> | string;
    description?: StringNullableFilter<'Document'> | string | null;
    fileType?: StringFilter<'Document'> | string;
    fileSize?: IntFilter<'Document'> | number;
    filePath?: StringFilter<'Document'> | string;
    userId?: StringFilter<'Document'> | string;
    createdAt?: DateTimeFilter<'Document'> | Date | string;
    updatedAt?: DateTimeFilter<'Document'> | Date | string;
  };

  export type ProjectUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ProjectWhereUniqueInput;
    update: XOR<ProjectUpdateWithoutCreatedByInput, ProjectUncheckedUpdateWithoutCreatedByInput>;
    create: XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput>;
  };

  export type ProjectUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ProjectWhereUniqueInput;
    data: XOR<ProjectUpdateWithoutCreatedByInput, ProjectUncheckedUpdateWithoutCreatedByInput>;
  };

  export type ProjectUpdateManyWithWhereWithoutCreatedByInput = {
    where: ProjectScalarWhereInput;
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCreatedByInput>;
  };

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[];
    OR?: ProjectScalarWhereInput[];
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[];
    id?: StringFilter<'Project'> | string;
    title?: StringFilter<'Project'> | string;
    description?: StringNullableFilter<'Project'> | string | null;
    startDate?: DateTimeNullableFilter<'Project'> | Date | string | null;
    endDate?: DateTimeNullableFilter<'Project'> | Date | string | null;
    createdAt?: DateTimeFilter<'Project'> | Date | string;
    updatedAt?: DateTimeFilter<'Project'> | Date | string;
    createdById?: StringFilter<'Project'> | string;
    dueDate?: DateTimeNullableFilter<'Project'> | Date | string | null;
    estimatedTime?: FloatNullableFilter<'Project'> | number | null;
    totalTimeSpent?: FloatNullableFilter<'Project'> | number | null;
  };

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>;
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>;
  };

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>;
  };

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput;
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>;
  };

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[];
    OR?: SessionScalarWhereInput[];
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[];
    id?: StringFilter<'Session'> | string;
    sessionToken?: StringFilter<'Session'> | string;
    userId?: StringFilter<'Session'> | string;
    expires?: DateTimeFilter<'Session'> | Date | string;
  };

  export type TaskAssigneeUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskAssigneeWhereUniqueInput;
    update: XOR<TaskAssigneeUpdateWithoutUserInput, TaskAssigneeUncheckedUpdateWithoutUserInput>;
    create: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput>;
  };

  export type TaskAssigneeUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskAssigneeWhereUniqueInput;
    data: XOR<TaskAssigneeUpdateWithoutUserInput, TaskAssigneeUncheckedUpdateWithoutUserInput>;
  };

  export type TaskAssigneeUpdateManyWithWhereWithoutUserInput = {
    where: TaskAssigneeScalarWhereInput;
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyWithoutUserInput>;
  };

  export type TaskAssigneeScalarWhereInput = {
    AND?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[];
    OR?: TaskAssigneeScalarWhereInput[];
    NOT?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[];
    id?: StringFilter<'TaskAssignee'> | string;
    taskId?: StringFilter<'TaskAssignee'> | string;
    userId?: StringFilter<'TaskAssignee'> | string;
    createdAt?: DateTimeFilter<'TaskAssignee'> | Date | string;
    updatedAt?: DateTimeFilter<'TaskAssignee'> | Date | string;
  };

  export type TaskAttachmentUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskAttachmentWhereUniqueInput;
    update: XOR<
      TaskAttachmentUpdateWithoutUserInput,
      TaskAttachmentUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      TaskAttachmentCreateWithoutUserInput,
      TaskAttachmentUncheckedCreateWithoutUserInput
    >;
  };

  export type TaskAttachmentUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskAttachmentWhereUniqueInput;
    data: XOR<TaskAttachmentUpdateWithoutUserInput, TaskAttachmentUncheckedUpdateWithoutUserInput>;
  };

  export type TaskAttachmentUpdateManyWithWhereWithoutUserInput = {
    where: TaskAttachmentScalarWhereInput;
    data: XOR<
      TaskAttachmentUpdateManyMutationInput,
      TaskAttachmentUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type TaskAttachmentScalarWhereInput = {
    AND?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[];
    OR?: TaskAttachmentScalarWhereInput[];
    NOT?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[];
    id?: StringFilter<'TaskAttachment'> | string;
    filename?: StringFilter<'TaskAttachment'> | string;
    fileUrl?: StringFilter<'TaskAttachment'> | string;
    fileSize?: IntFilter<'TaskAttachment'> | number;
    fileType?: StringFilter<'TaskAttachment'> | string;
    taskId?: StringFilter<'TaskAttachment'> | string;
    userId?: StringFilter<'TaskAttachment'> | string;
    createdAt?: DateTimeFilter<'TaskAttachment'> | Date | string;
    updatedAt?: DateTimeFilter<'TaskAttachment'> | Date | string;
  };

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput;
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>;
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>;
  };

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput;
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>;
  };

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput;
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>;
  };

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
    OR?: TeamMemberScalarWhereInput[];
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
    id?: StringFilter<'TeamMember'> | string;
    projectId?: StringFilter<'TeamMember'> | string;
    userId?: StringFilter<'TeamMember'> | string;
    createdAt?: DateTimeFilter<'TeamMember'> | Date | string;
    updatedAt?: DateTimeFilter<'TeamMember'> | Date | string;
  };

  export type UserCreateWithoutAccountsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    activities?: ActivityCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsCreateNestedOneWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    projects?: ProjectCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsUncheckedCreateNestedOneWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
  };

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>;
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>;
  };

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUpdateOneWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    projects?: ProjectUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUncheckedUpdateOneWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    projects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutSessionsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    activities?: ActivityCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsCreateNestedOneWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    projects?: ProjectCreateNestedManyWithoutCreatedByInput;
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsUncheckedCreateNestedOneWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput;
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
  };

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>;
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>;
  };

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    activities?: ActivityUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUpdateOneWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    projects?: ProjectUpdateManyWithoutCreatedByNestedInput;
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUncheckedUpdateOneWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    projects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput;
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ActivityCreateWithoutProjectInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    description?: string | null;
    createdAt?: Date | string;
    task?: TaskCreateNestedOneWithoutActivitiesInput;
    user: UserCreateNestedOneWithoutActivitiesInput;
  };

  export type ActivityUncheckedCreateWithoutProjectInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    description?: string | null;
    userId: string;
    taskId?: string | null;
    createdAt?: Date | string;
  };

  export type ActivityCreateOrConnectWithoutProjectInput = {
    where: ActivityWhereUniqueInput;
    create: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput>;
  };

  export type ActivityCreateManyProjectInputEnvelope = {
    data: ActivityCreateManyProjectInput | ActivityCreateManyProjectInput[];
    skipDuplicates?: boolean;
  };

  export type AttendanceCreateWithoutProjectInput = {
    id?: string;
    checkInTime?: Date | string;
    checkOutTime?: Date | string | null;
    checkInLatitude?: number | null;
    checkInLongitude?: number | null;
    checkOutLatitude?: number | null;
    checkOutLongitude?: number | null;
    checkInIpAddress?: string | null;
    checkOutIpAddress?: string | null;
    checkInDeviceInfo?: string | null;
    checkOutDeviceInfo?: string | null;
    totalHours?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    checkInLocationName?: string | null;
    checkOutLocationName?: string | null;
    autoCheckout?: boolean;
    task?: TaskCreateNestedOneWithoutAttendancesInput;
    user: UserCreateNestedOneWithoutAttendanceRecordsInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutAttendanceInput;
  };

  export type AttendanceUncheckedCreateWithoutProjectInput = {
    id?: string;
    userId: string;
    checkInTime?: Date | string;
    checkOutTime?: Date | string | null;
    checkInLatitude?: number | null;
    checkInLongitude?: number | null;
    checkOutLatitude?: number | null;
    checkOutLongitude?: number | null;
    checkInIpAddress?: string | null;
    checkOutIpAddress?: string | null;
    checkInDeviceInfo?: string | null;
    checkOutDeviceInfo?: string | null;
    totalHours?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    checkInLocationName?: string | null;
    checkOutLocationName?: string | null;
    taskId?: string | null;
    autoCheckout?: boolean;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutAttendanceInput;
  };

  export type AttendanceCreateOrConnectWithoutProjectInput = {
    where: AttendanceWhereUniqueInput;
    create: XOR<AttendanceCreateWithoutProjectInput, AttendanceUncheckedCreateWithoutProjectInput>;
  };

  export type AttendanceCreateManyProjectInputEnvelope = {
    data: AttendanceCreateManyProjectInput | AttendanceCreateManyProjectInput[];
    skipDuplicates?: boolean;
  };

  export type EventCreateWithoutProjectInput = {
    id?: string;
    title: string;
    description?: string | null;
    date: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EventUncheckedCreateWithoutProjectInput = {
    id?: string;
    title: string;
    description?: string | null;
    date: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EventCreateOrConnectWithoutProjectInput = {
    where: EventWhereUniqueInput;
    create: XOR<EventCreateWithoutProjectInput, EventUncheckedCreateWithoutProjectInput>;
  };

  export type EventCreateManyProjectInputEnvelope = {
    data: EventCreateManyProjectInput | EventCreateManyProjectInput[];
    skipDuplicates?: boolean;
  };

  export type UserCreateWithoutProjectsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    activities?: ActivityCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsCreateNestedOneWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsUncheckedCreateNestedOneWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>;
  };

  export type ProjectStatusCreateWithoutProjectInput = {
    id?: string;
    name: string;
    color?: string | null;
    description?: string | null;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    order?: number;
    isCompletedStatus?: boolean;
    tasks?: TaskCreateNestedManyWithoutStatusInput;
  };

  export type ProjectStatusUncheckedCreateWithoutProjectInput = {
    id?: string;
    name: string;
    color?: string | null;
    description?: string | null;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    order?: number;
    isCompletedStatus?: boolean;
    tasks?: TaskUncheckedCreateNestedManyWithoutStatusInput;
  };

  export type ProjectStatusCreateOrConnectWithoutProjectInput = {
    where: ProjectStatusWhereUniqueInput;
    create: XOR<
      ProjectStatusCreateWithoutProjectInput,
      ProjectStatusUncheckedCreateWithoutProjectInput
    >;
  };

  export type ProjectStatusCreateManyProjectInputEnvelope = {
    data: ProjectStatusCreateManyProjectInput | ProjectStatusCreateManyProjectInput[];
    skipDuplicates?: boolean;
  };

  export type TaskCreateWithoutProjectInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceCreateNestedManyWithoutTaskInput;
    comments?: CommentCreateNestedManyWithoutTaskInput;
    parent?: TaskCreateNestedOneWithoutSubtasksInput;
    subtasks?: TaskCreateNestedManyWithoutParentInput;
    status?: ProjectStatusCreateNestedOneWithoutTasksInput;
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput;
  };

  export type TaskUncheckedCreateWithoutProjectInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    parentId?: string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    statusId?: string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityUncheckedCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTaskInput;
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput;
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentInput;
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput;
  };

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput;
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>;
  };

  export type TaskCreateManyProjectInputEnvelope = {
    data: TaskCreateManyProjectInput | TaskCreateManyProjectInput[];
    skipDuplicates?: boolean;
  };

  export type TeamMemberCreateWithoutProjectInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutTeamsInput;
  };

  export type TeamMemberUncheckedCreateWithoutProjectInput = {
    id?: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamMemberCreateOrConnectWithoutProjectInput = {
    where: TeamMemberWhereUniqueInput;
    create: XOR<TeamMemberCreateWithoutProjectInput, TeamMemberUncheckedCreateWithoutProjectInput>;
  };

  export type TeamMemberCreateManyProjectInputEnvelope = {
    data: TeamMemberCreateManyProjectInput | TeamMemberCreateManyProjectInput[];
    skipDuplicates?: boolean;
  };

  export type ActivityUpsertWithWhereUniqueWithoutProjectInput = {
    where: ActivityWhereUniqueInput;
    update: XOR<ActivityUpdateWithoutProjectInput, ActivityUncheckedUpdateWithoutProjectInput>;
    create: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput>;
  };

  export type ActivityUpdateWithWhereUniqueWithoutProjectInput = {
    where: ActivityWhereUniqueInput;
    data: XOR<ActivityUpdateWithoutProjectInput, ActivityUncheckedUpdateWithoutProjectInput>;
  };

  export type ActivityUpdateManyWithWhereWithoutProjectInput = {
    where: ActivityScalarWhereInput;
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutProjectInput>;
  };

  export type AttendanceUpsertWithWhereUniqueWithoutProjectInput = {
    where: AttendanceWhereUniqueInput;
    update: XOR<AttendanceUpdateWithoutProjectInput, AttendanceUncheckedUpdateWithoutProjectInput>;
    create: XOR<AttendanceCreateWithoutProjectInput, AttendanceUncheckedCreateWithoutProjectInput>;
  };

  export type AttendanceUpdateWithWhereUniqueWithoutProjectInput = {
    where: AttendanceWhereUniqueInput;
    data: XOR<AttendanceUpdateWithoutProjectInput, AttendanceUncheckedUpdateWithoutProjectInput>;
  };

  export type AttendanceUpdateManyWithWhereWithoutProjectInput = {
    where: AttendanceScalarWhereInput;
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutProjectInput>;
  };

  export type EventUpsertWithWhereUniqueWithoutProjectInput = {
    where: EventWhereUniqueInput;
    update: XOR<EventUpdateWithoutProjectInput, EventUncheckedUpdateWithoutProjectInput>;
    create: XOR<EventCreateWithoutProjectInput, EventUncheckedCreateWithoutProjectInput>;
  };

  export type EventUpdateWithWhereUniqueWithoutProjectInput = {
    where: EventWhereUniqueInput;
    data: XOR<EventUpdateWithoutProjectInput, EventUncheckedUpdateWithoutProjectInput>;
  };

  export type EventUpdateManyWithWhereWithoutProjectInput = {
    where: EventScalarWhereInput;
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutProjectInput>;
  };

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[];
    OR?: EventScalarWhereInput[];
    NOT?: EventScalarWhereInput | EventScalarWhereInput[];
    id?: StringFilter<'Event'> | string;
    title?: StringFilter<'Event'> | string;
    description?: StringNullableFilter<'Event'> | string | null;
    date?: DateTimeFilter<'Event'> | Date | string;
    projectId?: StringFilter<'Event'> | string;
    createdAt?: DateTimeFilter<'Event'> | Date | string;
    updatedAt?: DateTimeFilter<'Event'> | Date | string;
  };

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>;
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>;
  };

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    activities?: ActivityUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUpdateOneWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUncheckedUpdateOneWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ProjectStatusUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectStatusWhereUniqueInput;
    update: XOR<
      ProjectStatusUpdateWithoutProjectInput,
      ProjectStatusUncheckedUpdateWithoutProjectInput
    >;
    create: XOR<
      ProjectStatusCreateWithoutProjectInput,
      ProjectStatusUncheckedCreateWithoutProjectInput
    >;
  };

  export type ProjectStatusUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectStatusWhereUniqueInput;
    data: XOR<
      ProjectStatusUpdateWithoutProjectInput,
      ProjectStatusUncheckedUpdateWithoutProjectInput
    >;
  };

  export type ProjectStatusUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectStatusScalarWhereInput;
    data: XOR<
      ProjectStatusUpdateManyMutationInput,
      ProjectStatusUncheckedUpdateManyWithoutProjectInput
    >;
  };

  export type ProjectStatusScalarWhereInput = {
    AND?: ProjectStatusScalarWhereInput | ProjectStatusScalarWhereInput[];
    OR?: ProjectStatusScalarWhereInput[];
    NOT?: ProjectStatusScalarWhereInput | ProjectStatusScalarWhereInput[];
    id?: StringFilter<'ProjectStatus'> | string;
    name?: StringFilter<'ProjectStatus'> | string;
    color?: StringNullableFilter<'ProjectStatus'> | string | null;
    description?: StringNullableFilter<'ProjectStatus'> | string | null;
    isDefault?: BoolFilter<'ProjectStatus'> | boolean;
    createdAt?: DateTimeFilter<'ProjectStatus'> | Date | string;
    updatedAt?: DateTimeFilter<'ProjectStatus'> | Date | string;
    order?: IntFilter<'ProjectStatus'> | number;
    projectId?: StringFilter<'ProjectStatus'> | string;
    isCompletedStatus?: BoolFilter<'ProjectStatus'> | boolean;
  };

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput;
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>;
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>;
  };

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput;
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>;
  };

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput;
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutProjectInput>;
  };

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[];
    OR?: TaskScalarWhereInput[];
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[];
    id?: StringFilter<'Task'> | string;
    title?: StringFilter<'Task'> | string;
    description?: StringNullableFilter<'Task'> | string | null;
    priority?: StringFilter<'Task'> | string;
    dueDate?: DateTimeNullableFilter<'Task'> | Date | string | null;
    projectId?: StringFilter<'Task'> | string;
    parentId?: StringNullableFilter<'Task'> | string | null;
    order?: IntFilter<'Task'> | number;
    createdAt?: DateTimeFilter<'Task'> | Date | string;
    updatedAt?: DateTimeFilter<'Task'> | Date | string;
    endDate?: DateTimeNullableFilter<'Task'> | Date | string | null;
    estimatedTime?: FloatNullableFilter<'Task'> | number | null;
    startDate?: DateTimeNullableFilter<'Task'> | Date | string | null;
    statusId?: StringNullableFilter<'Task'> | string | null;
    timeSpent?: FloatNullableFilter<'Task'> | number | null;
    completed?: BoolFilter<'Task'> | boolean;
  };

  export type TeamMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: TeamMemberWhereUniqueInput;
    update: XOR<TeamMemberUpdateWithoutProjectInput, TeamMemberUncheckedUpdateWithoutProjectInput>;
    create: XOR<TeamMemberCreateWithoutProjectInput, TeamMemberUncheckedCreateWithoutProjectInput>;
  };

  export type TeamMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: TeamMemberWhereUniqueInput;
    data: XOR<TeamMemberUpdateWithoutProjectInput, TeamMemberUncheckedUpdateWithoutProjectInput>;
  };

  export type TeamMemberUpdateManyWithWhereWithoutProjectInput = {
    where: TeamMemberScalarWhereInput;
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutProjectInput>;
  };

  export type ProjectCreateWithoutStatusesInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    activities?: ActivityCreateNestedManyWithoutProjectInput;
    attendances?: AttendanceCreateNestedManyWithoutProjectInput;
    events?: EventCreateNestedManyWithoutProjectInput;
    createdBy: UserCreateNestedOneWithoutProjectsInput;
    tasks?: TaskCreateNestedManyWithoutProjectInput;
    teamMembers?: TeamMemberCreateNestedManyWithoutProjectInput;
  };

  export type ProjectUncheckedCreateWithoutStatusesInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdById: string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutProjectInput;
    events?: EventUncheckedCreateNestedManyWithoutProjectInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput;
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutProjectInput;
  };

  export type ProjectCreateOrConnectWithoutStatusesInput = {
    where: ProjectWhereUniqueInput;
    create: XOR<ProjectCreateWithoutStatusesInput, ProjectUncheckedCreateWithoutStatusesInput>;
  };

  export type TaskCreateWithoutStatusInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceCreateNestedManyWithoutTaskInput;
    comments?: CommentCreateNestedManyWithoutTaskInput;
    parent?: TaskCreateNestedOneWithoutSubtasksInput;
    subtasks?: TaskCreateNestedManyWithoutParentInput;
    project: ProjectCreateNestedOneWithoutTasksInput;
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput;
  };

  export type TaskUncheckedCreateWithoutStatusInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    projectId: string;
    parentId?: string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityUncheckedCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTaskInput;
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput;
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentInput;
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput;
  };

  export type TaskCreateOrConnectWithoutStatusInput = {
    where: TaskWhereUniqueInput;
    create: XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput>;
  };

  export type TaskCreateManyStatusInputEnvelope = {
    data: TaskCreateManyStatusInput | TaskCreateManyStatusInput[];
    skipDuplicates?: boolean;
  };

  export type ProjectUpsertWithoutStatusesInput = {
    update: XOR<ProjectUpdateWithoutStatusesInput, ProjectUncheckedUpdateWithoutStatusesInput>;
    create: XOR<ProjectCreateWithoutStatusesInput, ProjectUncheckedCreateWithoutStatusesInput>;
    where?: ProjectWhereInput;
  };

  export type ProjectUpdateToOneWithWhereWithoutStatusesInput = {
    where?: ProjectWhereInput;
    data: XOR<ProjectUpdateWithoutStatusesInput, ProjectUncheckedUpdateWithoutStatusesInput>;
  };

  export type ProjectUpdateWithoutStatusesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    activities?: ActivityUpdateManyWithoutProjectNestedInput;
    attendances?: AttendanceUpdateManyWithoutProjectNestedInput;
    events?: EventUpdateManyWithoutProjectNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutProjectsNestedInput;
    tasks?: TaskUpdateManyWithoutProjectNestedInput;
    teamMembers?: TeamMemberUpdateManyWithoutProjectNestedInput;
  };

  export type ProjectUncheckedUpdateWithoutStatusesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput;
    attendances?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput;
    events?: EventUncheckedUpdateManyWithoutProjectNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput;
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutProjectNestedInput;
  };

  export type TaskUpsertWithWhereUniqueWithoutStatusInput = {
    where: TaskWhereUniqueInput;
    update: XOR<TaskUpdateWithoutStatusInput, TaskUncheckedUpdateWithoutStatusInput>;
    create: XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput>;
  };

  export type TaskUpdateWithWhereUniqueWithoutStatusInput = {
    where: TaskWhereUniqueInput;
    data: XOR<TaskUpdateWithoutStatusInput, TaskUncheckedUpdateWithoutStatusInput>;
  };

  export type TaskUpdateManyWithWhereWithoutStatusInput = {
    where: TaskScalarWhereInput;
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutStatusInput>;
  };

  export type ActivityCreateWithoutTaskInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    description?: string | null;
    createdAt?: Date | string;
    project?: ProjectCreateNestedOneWithoutActivitiesInput;
    user: UserCreateNestedOneWithoutActivitiesInput;
  };

  export type ActivityUncheckedCreateWithoutTaskInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    description?: string | null;
    userId: string;
    projectId?: string | null;
    createdAt?: Date | string;
  };

  export type ActivityCreateOrConnectWithoutTaskInput = {
    where: ActivityWhereUniqueInput;
    create: XOR<ActivityCreateWithoutTaskInput, ActivityUncheckedCreateWithoutTaskInput>;
  };

  export type ActivityCreateManyTaskInputEnvelope = {
    data: ActivityCreateManyTaskInput | ActivityCreateManyTaskInput[];
    skipDuplicates?: boolean;
  };

  export type AttendanceCreateWithoutTaskInput = {
    id?: string;
    checkInTime?: Date | string;
    checkOutTime?: Date | string | null;
    checkInLatitude?: number | null;
    checkInLongitude?: number | null;
    checkOutLatitude?: number | null;
    checkOutLongitude?: number | null;
    checkInIpAddress?: string | null;
    checkOutIpAddress?: string | null;
    checkInDeviceInfo?: string | null;
    checkOutDeviceInfo?: string | null;
    totalHours?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    checkInLocationName?: string | null;
    checkOutLocationName?: string | null;
    autoCheckout?: boolean;
    project?: ProjectCreateNestedOneWithoutAttendancesInput;
    user: UserCreateNestedOneWithoutAttendanceRecordsInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutAttendanceInput;
  };

  export type AttendanceUncheckedCreateWithoutTaskInput = {
    id?: string;
    userId: string;
    checkInTime?: Date | string;
    checkOutTime?: Date | string | null;
    checkInLatitude?: number | null;
    checkInLongitude?: number | null;
    checkOutLatitude?: number | null;
    checkOutLongitude?: number | null;
    checkInIpAddress?: string | null;
    checkOutIpAddress?: string | null;
    checkInDeviceInfo?: string | null;
    checkOutDeviceInfo?: string | null;
    totalHours?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    checkInLocationName?: string | null;
    checkOutLocationName?: string | null;
    projectId?: string | null;
    autoCheckout?: boolean;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutAttendanceInput;
  };

  export type AttendanceCreateOrConnectWithoutTaskInput = {
    where: AttendanceWhereUniqueInput;
    create: XOR<AttendanceCreateWithoutTaskInput, AttendanceUncheckedCreateWithoutTaskInput>;
  };

  export type AttendanceCreateManyTaskInputEnvelope = {
    data: AttendanceCreateManyTaskInput | AttendanceCreateManyTaskInput[];
    skipDuplicates?: boolean;
  };

  export type CommentCreateWithoutTaskInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutCommentsInput;
  };

  export type CommentUncheckedCreateWithoutTaskInput = {
    id?: string;
    content: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CommentCreateOrConnectWithoutTaskInput = {
    where: CommentWhereUniqueInput;
    create: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>;
  };

  export type CommentCreateManyTaskInputEnvelope = {
    data: CommentCreateManyTaskInput | CommentCreateManyTaskInput[];
    skipDuplicates?: boolean;
  };

  export type TaskCreateWithoutSubtasksInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceCreateNestedManyWithoutTaskInput;
    comments?: CommentCreateNestedManyWithoutTaskInput;
    parent?: TaskCreateNestedOneWithoutSubtasksInput;
    project: ProjectCreateNestedOneWithoutTasksInput;
    status?: ProjectStatusCreateNestedOneWithoutTasksInput;
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput;
  };

  export type TaskUncheckedCreateWithoutSubtasksInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    projectId: string;
    parentId?: string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    statusId?: string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityUncheckedCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTaskInput;
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput;
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput;
  };

  export type TaskCreateOrConnectWithoutSubtasksInput = {
    where: TaskWhereUniqueInput;
    create: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>;
  };

  export type TaskCreateWithoutParentInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceCreateNestedManyWithoutTaskInput;
    comments?: CommentCreateNestedManyWithoutTaskInput;
    subtasks?: TaskCreateNestedManyWithoutParentInput;
    project: ProjectCreateNestedOneWithoutTasksInput;
    status?: ProjectStatusCreateNestedOneWithoutTasksInput;
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput;
  };

  export type TaskUncheckedCreateWithoutParentInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    projectId: string;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    statusId?: string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityUncheckedCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTaskInput;
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput;
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentInput;
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput;
  };

  export type TaskCreateOrConnectWithoutParentInput = {
    where: TaskWhereUniqueInput;
    create: XOR<TaskCreateWithoutParentInput, TaskUncheckedCreateWithoutParentInput>;
  };

  export type TaskCreateManyParentInputEnvelope = {
    data: TaskCreateManyParentInput | TaskCreateManyParentInput[];
    skipDuplicates?: boolean;
  };

  export type ProjectCreateWithoutTasksInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    activities?: ActivityCreateNestedManyWithoutProjectInput;
    attendances?: AttendanceCreateNestedManyWithoutProjectInput;
    events?: EventCreateNestedManyWithoutProjectInput;
    createdBy: UserCreateNestedOneWithoutProjectsInput;
    statuses?: ProjectStatusCreateNestedManyWithoutProjectInput;
    teamMembers?: TeamMemberCreateNestedManyWithoutProjectInput;
  };

  export type ProjectUncheckedCreateWithoutTasksInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdById: string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutProjectInput;
    events?: EventUncheckedCreateNestedManyWithoutProjectInput;
    statuses?: ProjectStatusUncheckedCreateNestedManyWithoutProjectInput;
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutProjectInput;
  };

  export type ProjectCreateOrConnectWithoutTasksInput = {
    where: ProjectWhereUniqueInput;
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>;
  };

  export type ProjectStatusCreateWithoutTasksInput = {
    id?: string;
    name: string;
    color?: string | null;
    description?: string | null;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    order?: number;
    isCompletedStatus?: boolean;
    project: ProjectCreateNestedOneWithoutStatusesInput;
  };

  export type ProjectStatusUncheckedCreateWithoutTasksInput = {
    id?: string;
    name: string;
    color?: string | null;
    description?: string | null;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    order?: number;
    projectId: string;
    isCompletedStatus?: boolean;
  };

  export type ProjectStatusCreateOrConnectWithoutTasksInput = {
    where: ProjectStatusWhereUniqueInput;
    create: XOR<
      ProjectStatusCreateWithoutTasksInput,
      ProjectStatusUncheckedCreateWithoutTasksInput
    >;
  };

  export type TaskAssigneeCreateWithoutTaskInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutTaskAssignmentsInput;
  };

  export type TaskAssigneeUncheckedCreateWithoutTaskInput = {
    id?: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TaskAssigneeCreateOrConnectWithoutTaskInput = {
    where: TaskAssigneeWhereUniqueInput;
    create: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput>;
  };

  export type TaskAssigneeCreateManyTaskInputEnvelope = {
    data: TaskAssigneeCreateManyTaskInput | TaskAssigneeCreateManyTaskInput[];
    skipDuplicates?: boolean;
  };

  export type TaskAttachmentCreateWithoutTaskInput = {
    id?: string;
    filename: string;
    fileUrl: string;
    fileSize: number;
    fileType: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutTaskAttachmentsInput;
  };

  export type TaskAttachmentUncheckedCreateWithoutTaskInput = {
    id?: string;
    filename: string;
    fileUrl: string;
    fileSize: number;
    fileType: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TaskAttachmentCreateOrConnectWithoutTaskInput = {
    where: TaskAttachmentWhereUniqueInput;
    create: XOR<
      TaskAttachmentCreateWithoutTaskInput,
      TaskAttachmentUncheckedCreateWithoutTaskInput
    >;
  };

  export type TaskAttachmentCreateManyTaskInputEnvelope = {
    data: TaskAttachmentCreateManyTaskInput | TaskAttachmentCreateManyTaskInput[];
    skipDuplicates?: boolean;
  };

  export type ActivityUpsertWithWhereUniqueWithoutTaskInput = {
    where: ActivityWhereUniqueInput;
    update: XOR<ActivityUpdateWithoutTaskInput, ActivityUncheckedUpdateWithoutTaskInput>;
    create: XOR<ActivityCreateWithoutTaskInput, ActivityUncheckedCreateWithoutTaskInput>;
  };

  export type ActivityUpdateWithWhereUniqueWithoutTaskInput = {
    where: ActivityWhereUniqueInput;
    data: XOR<ActivityUpdateWithoutTaskInput, ActivityUncheckedUpdateWithoutTaskInput>;
  };

  export type ActivityUpdateManyWithWhereWithoutTaskInput = {
    where: ActivityScalarWhereInput;
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutTaskInput>;
  };

  export type AttendanceUpsertWithWhereUniqueWithoutTaskInput = {
    where: AttendanceWhereUniqueInput;
    update: XOR<AttendanceUpdateWithoutTaskInput, AttendanceUncheckedUpdateWithoutTaskInput>;
    create: XOR<AttendanceCreateWithoutTaskInput, AttendanceUncheckedCreateWithoutTaskInput>;
  };

  export type AttendanceUpdateWithWhereUniqueWithoutTaskInput = {
    where: AttendanceWhereUniqueInput;
    data: XOR<AttendanceUpdateWithoutTaskInput, AttendanceUncheckedUpdateWithoutTaskInput>;
  };

  export type AttendanceUpdateManyWithWhereWithoutTaskInput = {
    where: AttendanceScalarWhereInput;
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutTaskInput>;
  };

  export type CommentUpsertWithWhereUniqueWithoutTaskInput = {
    where: CommentWhereUniqueInput;
    update: XOR<CommentUpdateWithoutTaskInput, CommentUncheckedUpdateWithoutTaskInput>;
    create: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>;
  };

  export type CommentUpdateWithWhereUniqueWithoutTaskInput = {
    where: CommentWhereUniqueInput;
    data: XOR<CommentUpdateWithoutTaskInput, CommentUncheckedUpdateWithoutTaskInput>;
  };

  export type CommentUpdateManyWithWhereWithoutTaskInput = {
    where: CommentScalarWhereInput;
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutTaskInput>;
  };

  export type TaskUpsertWithoutSubtasksInput = {
    update: XOR<TaskUpdateWithoutSubtasksInput, TaskUncheckedUpdateWithoutSubtasksInput>;
    create: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>;
    where?: TaskWhereInput;
  };

  export type TaskUpdateToOneWithWhereWithoutSubtasksInput = {
    where?: TaskWhereInput;
    data: XOR<TaskUpdateWithoutSubtasksInput, TaskUncheckedUpdateWithoutSubtasksInput>;
  };

  export type TaskUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUpdateManyWithoutTaskNestedInput;
    comments?: CommentUpdateManyWithoutTaskNestedInput;
    parent?: TaskUpdateOneWithoutSubtasksNestedInput;
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput;
    status?: ProjectStatusUpdateOneWithoutTasksNestedInput;
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput;
  };

  export type TaskUncheckedUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    projectId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    statusId?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUncheckedUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUncheckedUpdateManyWithoutTaskNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput;
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput;
  };

  export type TaskUpsertWithWhereUniqueWithoutParentInput = {
    where: TaskWhereUniqueInput;
    update: XOR<TaskUpdateWithoutParentInput, TaskUncheckedUpdateWithoutParentInput>;
    create: XOR<TaskCreateWithoutParentInput, TaskUncheckedCreateWithoutParentInput>;
  };

  export type TaskUpdateWithWhereUniqueWithoutParentInput = {
    where: TaskWhereUniqueInput;
    data: XOR<TaskUpdateWithoutParentInput, TaskUncheckedUpdateWithoutParentInput>;
  };

  export type TaskUpdateManyWithWhereWithoutParentInput = {
    where: TaskScalarWhereInput;
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutParentInput>;
  };

  export type ProjectUpsertWithoutTasksInput = {
    update: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>;
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>;
    where?: ProjectWhereInput;
  };

  export type ProjectUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectWhereInput;
    data: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>;
  };

  export type ProjectUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    activities?: ActivityUpdateManyWithoutProjectNestedInput;
    attendances?: AttendanceUpdateManyWithoutProjectNestedInput;
    events?: EventUpdateManyWithoutProjectNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutProjectsNestedInput;
    statuses?: ProjectStatusUpdateManyWithoutProjectNestedInput;
    teamMembers?: TeamMemberUpdateManyWithoutProjectNestedInput;
  };

  export type ProjectUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput;
    attendances?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput;
    events?: EventUncheckedUpdateManyWithoutProjectNestedInput;
    statuses?: ProjectStatusUncheckedUpdateManyWithoutProjectNestedInput;
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutProjectNestedInput;
  };

  export type ProjectStatusUpsertWithoutTasksInput = {
    update: XOR<
      ProjectStatusUpdateWithoutTasksInput,
      ProjectStatusUncheckedUpdateWithoutTasksInput
    >;
    create: XOR<
      ProjectStatusCreateWithoutTasksInput,
      ProjectStatusUncheckedCreateWithoutTasksInput
    >;
    where?: ProjectStatusWhereInput;
  };

  export type ProjectStatusUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectStatusWhereInput;
    data: XOR<ProjectStatusUpdateWithoutTasksInput, ProjectStatusUncheckedUpdateWithoutTasksInput>;
  };

  export type ProjectStatusUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: IntFieldUpdateOperationsInput | number;
    isCompletedStatus?: BoolFieldUpdateOperationsInput | boolean;
    project?: ProjectUpdateOneRequiredWithoutStatusesNestedInput;
  };

  export type ProjectStatusUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: IntFieldUpdateOperationsInput | number;
    projectId?: StringFieldUpdateOperationsInput | string;
    isCompletedStatus?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskAssigneeWhereUniqueInput;
    update: XOR<TaskAssigneeUpdateWithoutTaskInput, TaskAssigneeUncheckedUpdateWithoutTaskInput>;
    create: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput>;
  };

  export type TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskAssigneeWhereUniqueInput;
    data: XOR<TaskAssigneeUpdateWithoutTaskInput, TaskAssigneeUncheckedUpdateWithoutTaskInput>;
  };

  export type TaskAssigneeUpdateManyWithWhereWithoutTaskInput = {
    where: TaskAssigneeScalarWhereInput;
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyWithoutTaskInput>;
  };

  export type TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskAttachmentWhereUniqueInput;
    update: XOR<
      TaskAttachmentUpdateWithoutTaskInput,
      TaskAttachmentUncheckedUpdateWithoutTaskInput
    >;
    create: XOR<
      TaskAttachmentCreateWithoutTaskInput,
      TaskAttachmentUncheckedCreateWithoutTaskInput
    >;
  };

  export type TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskAttachmentWhereUniqueInput;
    data: XOR<TaskAttachmentUpdateWithoutTaskInput, TaskAttachmentUncheckedUpdateWithoutTaskInput>;
  };

  export type TaskAttachmentUpdateManyWithWhereWithoutTaskInput = {
    where: TaskAttachmentScalarWhereInput;
    data: XOR<
      TaskAttachmentUpdateManyMutationInput,
      TaskAttachmentUncheckedUpdateManyWithoutTaskInput
    >;
  };

  export type TaskCreateWithoutAssigneesInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceCreateNestedManyWithoutTaskInput;
    comments?: CommentCreateNestedManyWithoutTaskInput;
    parent?: TaskCreateNestedOneWithoutSubtasksInput;
    subtasks?: TaskCreateNestedManyWithoutParentInput;
    project: ProjectCreateNestedOneWithoutTasksInput;
    status?: ProjectStatusCreateNestedOneWithoutTasksInput;
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput;
  };

  export type TaskUncheckedCreateWithoutAssigneesInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    projectId: string;
    parentId?: string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    statusId?: string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityUncheckedCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTaskInput;
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput;
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentInput;
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput;
  };

  export type TaskCreateOrConnectWithoutAssigneesInput = {
    where: TaskWhereUniqueInput;
    create: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>;
  };

  export type UserCreateWithoutTaskAssignmentsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    activities?: ActivityCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsCreateNestedOneWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    projects?: ProjectCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutTaskAssignmentsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsUncheckedCreateNestedOneWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutTaskAssignmentsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTaskAssignmentsInput,
      UserUncheckedCreateWithoutTaskAssignmentsInput
    >;
  };

  export type TaskUpsertWithoutAssigneesInput = {
    update: XOR<TaskUpdateWithoutAssigneesInput, TaskUncheckedUpdateWithoutAssigneesInput>;
    create: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>;
    where?: TaskWhereInput;
  };

  export type TaskUpdateToOneWithWhereWithoutAssigneesInput = {
    where?: TaskWhereInput;
    data: XOR<TaskUpdateWithoutAssigneesInput, TaskUncheckedUpdateWithoutAssigneesInput>;
  };

  export type TaskUpdateWithoutAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUpdateManyWithoutTaskNestedInput;
    comments?: CommentUpdateManyWithoutTaskNestedInput;
    parent?: TaskUpdateOneWithoutSubtasksNestedInput;
    subtasks?: TaskUpdateManyWithoutParentNestedInput;
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput;
    status?: ProjectStatusUpdateOneWithoutTasksNestedInput;
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput;
  };

  export type TaskUncheckedUpdateWithoutAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    projectId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    statusId?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUncheckedUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUncheckedUpdateManyWithoutTaskNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput;
    subtasks?: TaskUncheckedUpdateManyWithoutParentNestedInput;
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput;
  };

  export type UserUpsertWithoutTaskAssignmentsInput = {
    update: XOR<
      UserUpdateWithoutTaskAssignmentsInput,
      UserUncheckedUpdateWithoutTaskAssignmentsInput
    >;
    create: XOR<
      UserCreateWithoutTaskAssignmentsInput,
      UserUncheckedCreateWithoutTaskAssignmentsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutTaskAssignmentsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutTaskAssignmentsInput,
      UserUncheckedUpdateWithoutTaskAssignmentsInput
    >;
  };

  export type UserUpdateWithoutTaskAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    activities?: ActivityUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUpdateOneWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    projects?: ProjectUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutTaskAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUncheckedUpdateOneWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    projects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ProjectCreateWithoutTeamMembersInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    activities?: ActivityCreateNestedManyWithoutProjectInput;
    attendances?: AttendanceCreateNestedManyWithoutProjectInput;
    events?: EventCreateNestedManyWithoutProjectInput;
    createdBy: UserCreateNestedOneWithoutProjectsInput;
    statuses?: ProjectStatusCreateNestedManyWithoutProjectInput;
    tasks?: TaskCreateNestedManyWithoutProjectInput;
  };

  export type ProjectUncheckedCreateWithoutTeamMembersInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdById: string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutProjectInput;
    events?: EventUncheckedCreateNestedManyWithoutProjectInput;
    statuses?: ProjectStatusUncheckedCreateNestedManyWithoutProjectInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput;
  };

  export type ProjectCreateOrConnectWithoutTeamMembersInput = {
    where: ProjectWhereUniqueInput;
    create: XOR<
      ProjectCreateWithoutTeamMembersInput,
      ProjectUncheckedCreateWithoutTeamMembersInput
    >;
  };

  export type UserCreateWithoutTeamsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    activities?: ActivityCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsCreateNestedOneWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    projects?: ProjectCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutTeamsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsUncheckedCreateNestedOneWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutTeamsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>;
  };

  export type ProjectUpsertWithoutTeamMembersInput = {
    update: XOR<
      ProjectUpdateWithoutTeamMembersInput,
      ProjectUncheckedUpdateWithoutTeamMembersInput
    >;
    create: XOR<
      ProjectCreateWithoutTeamMembersInput,
      ProjectUncheckedCreateWithoutTeamMembersInput
    >;
    where?: ProjectWhereInput;
  };

  export type ProjectUpdateToOneWithWhereWithoutTeamMembersInput = {
    where?: ProjectWhereInput;
    data: XOR<ProjectUpdateWithoutTeamMembersInput, ProjectUncheckedUpdateWithoutTeamMembersInput>;
  };

  export type ProjectUpdateWithoutTeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    activities?: ActivityUpdateManyWithoutProjectNestedInput;
    attendances?: AttendanceUpdateManyWithoutProjectNestedInput;
    events?: EventUpdateManyWithoutProjectNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutProjectsNestedInput;
    statuses?: ProjectStatusUpdateManyWithoutProjectNestedInput;
    tasks?: TaskUpdateManyWithoutProjectNestedInput;
  };

  export type ProjectUncheckedUpdateWithoutTeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput;
    attendances?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput;
    events?: EventUncheckedUpdateManyWithoutProjectNestedInput;
    statuses?: ProjectStatusUncheckedUpdateManyWithoutProjectNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput;
  };

  export type UserUpsertWithoutTeamsInput = {
    update: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>;
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutTeamsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>;
  };

  export type UserUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    activities?: ActivityUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUpdateOneWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    projects?: ProjectUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUncheckedUpdateOneWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    projects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ProjectCreateWithoutEventsInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    activities?: ActivityCreateNestedManyWithoutProjectInput;
    attendances?: AttendanceCreateNestedManyWithoutProjectInput;
    createdBy: UserCreateNestedOneWithoutProjectsInput;
    statuses?: ProjectStatusCreateNestedManyWithoutProjectInput;
    tasks?: TaskCreateNestedManyWithoutProjectInput;
    teamMembers?: TeamMemberCreateNestedManyWithoutProjectInput;
  };

  export type ProjectUncheckedCreateWithoutEventsInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdById: string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutProjectInput;
    statuses?: ProjectStatusUncheckedCreateNestedManyWithoutProjectInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput;
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutProjectInput;
  };

  export type ProjectCreateOrConnectWithoutEventsInput = {
    where: ProjectWhereUniqueInput;
    create: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>;
  };

  export type ProjectUpsertWithoutEventsInput = {
    update: XOR<ProjectUpdateWithoutEventsInput, ProjectUncheckedUpdateWithoutEventsInput>;
    create: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>;
    where?: ProjectWhereInput;
  };

  export type ProjectUpdateToOneWithWhereWithoutEventsInput = {
    where?: ProjectWhereInput;
    data: XOR<ProjectUpdateWithoutEventsInput, ProjectUncheckedUpdateWithoutEventsInput>;
  };

  export type ProjectUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    activities?: ActivityUpdateManyWithoutProjectNestedInput;
    attendances?: AttendanceUpdateManyWithoutProjectNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutProjectsNestedInput;
    statuses?: ProjectStatusUpdateManyWithoutProjectNestedInput;
    tasks?: TaskUpdateManyWithoutProjectNestedInput;
    teamMembers?: TeamMemberUpdateManyWithoutProjectNestedInput;
  };

  export type ProjectUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput;
    attendances?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput;
    statuses?: ProjectStatusUncheckedUpdateManyWithoutProjectNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput;
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutProjectNestedInput;
  };

  export type ProjectCreateWithoutAttendancesInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    activities?: ActivityCreateNestedManyWithoutProjectInput;
    events?: EventCreateNestedManyWithoutProjectInput;
    createdBy: UserCreateNestedOneWithoutProjectsInput;
    statuses?: ProjectStatusCreateNestedManyWithoutProjectInput;
    tasks?: TaskCreateNestedManyWithoutProjectInput;
    teamMembers?: TeamMemberCreateNestedManyWithoutProjectInput;
  };

  export type ProjectUncheckedCreateWithoutAttendancesInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdById: string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput;
    events?: EventUncheckedCreateNestedManyWithoutProjectInput;
    statuses?: ProjectStatusUncheckedCreateNestedManyWithoutProjectInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput;
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutProjectInput;
  };

  export type ProjectCreateOrConnectWithoutAttendancesInput = {
    where: ProjectWhereUniqueInput;
    create: XOR<
      ProjectCreateWithoutAttendancesInput,
      ProjectUncheckedCreateWithoutAttendancesInput
    >;
  };

  export type TaskCreateWithoutAttendancesInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityCreateNestedManyWithoutTaskInput;
    comments?: CommentCreateNestedManyWithoutTaskInput;
    parent?: TaskCreateNestedOneWithoutSubtasksInput;
    subtasks?: TaskCreateNestedManyWithoutParentInput;
    project: ProjectCreateNestedOneWithoutTasksInput;
    status?: ProjectStatusCreateNestedOneWithoutTasksInput;
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput;
  };

  export type TaskUncheckedCreateWithoutAttendancesInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    projectId: string;
    parentId?: string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    statusId?: string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityUncheckedCreateNestedManyWithoutTaskInput;
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput;
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentInput;
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput;
  };

  export type TaskCreateOrConnectWithoutAttendancesInput = {
    where: TaskWhereUniqueInput;
    create: XOR<TaskCreateWithoutAttendancesInput, TaskUncheckedCreateWithoutAttendancesInput>;
  };

  export type UserCreateWithoutAttendanceRecordsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    activities?: ActivityCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsCreateNestedOneWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    projects?: ProjectCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAttendanceRecordsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsUncheckedCreateNestedOneWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAttendanceRecordsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAttendanceRecordsInput,
      UserUncheckedCreateWithoutAttendanceRecordsInput
    >;
  };

  export type AttendanceCorrectionRequestCreateWithoutAttendanceInput = {
    id?: string;
    originalCheckInTime: Date | string;
    originalCheckOutTime?: Date | string | null;
    requestedCheckInTime: Date | string;
    requestedCheckOutTime?: Date | string | null;
    reason: string;
    status?: string;
    reviewedBy?: string | null;
    reviewedAt?: Date | string | null;
    reviewNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutCorrectionRequestsInput;
  };

  export type AttendanceCorrectionRequestUncheckedCreateWithoutAttendanceInput = {
    id?: string;
    userId: string;
    originalCheckInTime: Date | string;
    originalCheckOutTime?: Date | string | null;
    requestedCheckInTime: Date | string;
    requestedCheckOutTime?: Date | string | null;
    reason: string;
    status?: string;
    reviewedBy?: string | null;
    reviewedAt?: Date | string | null;
    reviewNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AttendanceCorrectionRequestCreateOrConnectWithoutAttendanceInput = {
    where: AttendanceCorrectionRequestWhereUniqueInput;
    create: XOR<
      AttendanceCorrectionRequestCreateWithoutAttendanceInput,
      AttendanceCorrectionRequestUncheckedCreateWithoutAttendanceInput
    >;
  };

  export type AttendanceCorrectionRequestCreateManyAttendanceInputEnvelope = {
    data:
      | AttendanceCorrectionRequestCreateManyAttendanceInput
      | AttendanceCorrectionRequestCreateManyAttendanceInput[];
    skipDuplicates?: boolean;
  };

  export type ProjectUpsertWithoutAttendancesInput = {
    update: XOR<
      ProjectUpdateWithoutAttendancesInput,
      ProjectUncheckedUpdateWithoutAttendancesInput
    >;
    create: XOR<
      ProjectCreateWithoutAttendancesInput,
      ProjectUncheckedCreateWithoutAttendancesInput
    >;
    where?: ProjectWhereInput;
  };

  export type ProjectUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: ProjectWhereInput;
    data: XOR<ProjectUpdateWithoutAttendancesInput, ProjectUncheckedUpdateWithoutAttendancesInput>;
  };

  export type ProjectUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    activities?: ActivityUpdateManyWithoutProjectNestedInput;
    events?: EventUpdateManyWithoutProjectNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutProjectsNestedInput;
    statuses?: ProjectStatusUpdateManyWithoutProjectNestedInput;
    tasks?: TaskUpdateManyWithoutProjectNestedInput;
    teamMembers?: TeamMemberUpdateManyWithoutProjectNestedInput;
  };

  export type ProjectUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput;
    events?: EventUncheckedUpdateManyWithoutProjectNestedInput;
    statuses?: ProjectStatusUncheckedUpdateManyWithoutProjectNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput;
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutProjectNestedInput;
  };

  export type TaskUpsertWithoutAttendancesInput = {
    update: XOR<TaskUpdateWithoutAttendancesInput, TaskUncheckedUpdateWithoutAttendancesInput>;
    create: XOR<TaskCreateWithoutAttendancesInput, TaskUncheckedCreateWithoutAttendancesInput>;
    where?: TaskWhereInput;
  };

  export type TaskUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: TaskWhereInput;
    data: XOR<TaskUpdateWithoutAttendancesInput, TaskUncheckedUpdateWithoutAttendancesInput>;
  };

  export type TaskUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUpdateManyWithoutTaskNestedInput;
    comments?: CommentUpdateManyWithoutTaskNestedInput;
    parent?: TaskUpdateOneWithoutSubtasksNestedInput;
    subtasks?: TaskUpdateManyWithoutParentNestedInput;
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput;
    status?: ProjectStatusUpdateOneWithoutTasksNestedInput;
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput;
  };

  export type TaskUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    projectId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    statusId?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUncheckedUpdateManyWithoutTaskNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput;
    subtasks?: TaskUncheckedUpdateManyWithoutParentNestedInput;
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput;
  };

  export type UserUpsertWithoutAttendanceRecordsInput = {
    update: XOR<
      UserUpdateWithoutAttendanceRecordsInput,
      UserUncheckedUpdateWithoutAttendanceRecordsInput
    >;
    create: XOR<
      UserCreateWithoutAttendanceRecordsInput,
      UserUncheckedCreateWithoutAttendanceRecordsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAttendanceRecordsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAttendanceRecordsInput,
      UserUncheckedUpdateWithoutAttendanceRecordsInput
    >;
  };

  export type UserUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    activities?: ActivityUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUpdateOneWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    projects?: ProjectUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUncheckedUpdateOneWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    projects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type AttendanceCorrectionRequestUpsertWithWhereUniqueWithoutAttendanceInput = {
    where: AttendanceCorrectionRequestWhereUniqueInput;
    update: XOR<
      AttendanceCorrectionRequestUpdateWithoutAttendanceInput,
      AttendanceCorrectionRequestUncheckedUpdateWithoutAttendanceInput
    >;
    create: XOR<
      AttendanceCorrectionRequestCreateWithoutAttendanceInput,
      AttendanceCorrectionRequestUncheckedCreateWithoutAttendanceInput
    >;
  };

  export type AttendanceCorrectionRequestUpdateWithWhereUniqueWithoutAttendanceInput = {
    where: AttendanceCorrectionRequestWhereUniqueInput;
    data: XOR<
      AttendanceCorrectionRequestUpdateWithoutAttendanceInput,
      AttendanceCorrectionRequestUncheckedUpdateWithoutAttendanceInput
    >;
  };

  export type AttendanceCorrectionRequestUpdateManyWithWhereWithoutAttendanceInput = {
    where: AttendanceCorrectionRequestScalarWhereInput;
    data: XOR<
      AttendanceCorrectionRequestUpdateManyMutationInput,
      AttendanceCorrectionRequestUncheckedUpdateManyWithoutAttendanceInput
    >;
  };

  export type UserCreateWithoutAttendanceSettingsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    activities?: ActivityCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    projects?: ProjectCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAttendanceSettingsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAttendanceSettingsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAttendanceSettingsInput,
      UserUncheckedCreateWithoutAttendanceSettingsInput
    >;
  };

  export type UserUpsertWithoutAttendanceSettingsInput = {
    update: XOR<
      UserUpdateWithoutAttendanceSettingsInput,
      UserUncheckedUpdateWithoutAttendanceSettingsInput
    >;
    create: XOR<
      UserCreateWithoutAttendanceSettingsInput,
      UserUncheckedCreateWithoutAttendanceSettingsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAttendanceSettingsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAttendanceSettingsInput,
      UserUncheckedUpdateWithoutAttendanceSettingsInput
    >;
  };

  export type UserUpdateWithoutAttendanceSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    activities?: ActivityUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    projects?: ProjectUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAttendanceSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    projects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ProjectCreateWithoutActivitiesInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    attendances?: AttendanceCreateNestedManyWithoutProjectInput;
    events?: EventCreateNestedManyWithoutProjectInput;
    createdBy: UserCreateNestedOneWithoutProjectsInput;
    statuses?: ProjectStatusCreateNestedManyWithoutProjectInput;
    tasks?: TaskCreateNestedManyWithoutProjectInput;
    teamMembers?: TeamMemberCreateNestedManyWithoutProjectInput;
  };

  export type ProjectUncheckedCreateWithoutActivitiesInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdById: string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutProjectInput;
    events?: EventUncheckedCreateNestedManyWithoutProjectInput;
    statuses?: ProjectStatusUncheckedCreateNestedManyWithoutProjectInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput;
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutProjectInput;
  };

  export type ProjectCreateOrConnectWithoutActivitiesInput = {
    where: ProjectWhereUniqueInput;
    create: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>;
  };

  export type TaskCreateWithoutActivitiesInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    timeSpent?: number | null;
    completed?: boolean;
    attendances?: AttendanceCreateNestedManyWithoutTaskInput;
    comments?: CommentCreateNestedManyWithoutTaskInput;
    parent?: TaskCreateNestedOneWithoutSubtasksInput;
    subtasks?: TaskCreateNestedManyWithoutParentInput;
    project: ProjectCreateNestedOneWithoutTasksInput;
    status?: ProjectStatusCreateNestedOneWithoutTasksInput;
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput;
  };

  export type TaskUncheckedCreateWithoutActivitiesInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    projectId: string;
    parentId?: string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    statusId?: string | null;
    timeSpent?: number | null;
    completed?: boolean;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTaskInput;
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput;
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentInput;
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput;
  };

  export type TaskCreateOrConnectWithoutActivitiesInput = {
    where: TaskWhereUniqueInput;
    create: XOR<TaskCreateWithoutActivitiesInput, TaskUncheckedCreateWithoutActivitiesInput>;
  };

  export type UserCreateWithoutActivitiesInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsCreateNestedOneWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    projects?: ProjectCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsUncheckedCreateNestedOneWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>;
  };

  export type ProjectUpsertWithoutActivitiesInput = {
    update: XOR<ProjectUpdateWithoutActivitiesInput, ProjectUncheckedUpdateWithoutActivitiesInput>;
    create: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>;
    where?: ProjectWhereInput;
  };

  export type ProjectUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ProjectWhereInput;
    data: XOR<ProjectUpdateWithoutActivitiesInput, ProjectUncheckedUpdateWithoutActivitiesInput>;
  };

  export type ProjectUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    attendances?: AttendanceUpdateManyWithoutProjectNestedInput;
    events?: EventUpdateManyWithoutProjectNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutProjectsNestedInput;
    statuses?: ProjectStatusUpdateManyWithoutProjectNestedInput;
    tasks?: TaskUpdateManyWithoutProjectNestedInput;
    teamMembers?: TeamMemberUpdateManyWithoutProjectNestedInput;
  };

  export type ProjectUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    attendances?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput;
    events?: EventUncheckedUpdateManyWithoutProjectNestedInput;
    statuses?: ProjectStatusUncheckedUpdateManyWithoutProjectNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput;
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutProjectNestedInput;
  };

  export type TaskUpsertWithoutActivitiesInput = {
    update: XOR<TaskUpdateWithoutActivitiesInput, TaskUncheckedUpdateWithoutActivitiesInput>;
    create: XOR<TaskCreateWithoutActivitiesInput, TaskUncheckedCreateWithoutActivitiesInput>;
    where?: TaskWhereInput;
  };

  export type TaskUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: TaskWhereInput;
    data: XOR<TaskUpdateWithoutActivitiesInput, TaskUncheckedUpdateWithoutActivitiesInput>;
  };

  export type TaskUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    attendances?: AttendanceUpdateManyWithoutTaskNestedInput;
    comments?: CommentUpdateManyWithoutTaskNestedInput;
    parent?: TaskUpdateOneWithoutSubtasksNestedInput;
    subtasks?: TaskUpdateManyWithoutParentNestedInput;
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput;
    status?: ProjectStatusUpdateOneWithoutTasksNestedInput;
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput;
  };

  export type TaskUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    projectId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    statusId?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    attendances?: AttendanceUncheckedUpdateManyWithoutTaskNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput;
    subtasks?: TaskUncheckedUpdateManyWithoutParentNestedInput;
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput;
  };

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>;
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>;
  };

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUpdateOneWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    projects?: ProjectUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUncheckedUpdateOneWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    projects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutDocumentsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    activities?: ActivityCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsCreateNestedOneWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutUserInput;
    projects?: ProjectCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsUncheckedCreateNestedOneWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput;
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>;
  };

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>;
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>;
  };

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    activities?: ActivityUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUpdateOneWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutUserNestedInput;
    projects?: ProjectUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUncheckedUpdateOneWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput;
    projects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type AttendanceCreateWithoutCorrectionRequestsInput = {
    id?: string;
    checkInTime?: Date | string;
    checkOutTime?: Date | string | null;
    checkInLatitude?: number | null;
    checkInLongitude?: number | null;
    checkOutLatitude?: number | null;
    checkOutLongitude?: number | null;
    checkInIpAddress?: string | null;
    checkOutIpAddress?: string | null;
    checkInDeviceInfo?: string | null;
    checkOutDeviceInfo?: string | null;
    totalHours?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    checkInLocationName?: string | null;
    checkOutLocationName?: string | null;
    autoCheckout?: boolean;
    project?: ProjectCreateNestedOneWithoutAttendancesInput;
    task?: TaskCreateNestedOneWithoutAttendancesInput;
    user: UserCreateNestedOneWithoutAttendanceRecordsInput;
  };

  export type AttendanceUncheckedCreateWithoutCorrectionRequestsInput = {
    id?: string;
    userId: string;
    checkInTime?: Date | string;
    checkOutTime?: Date | string | null;
    checkInLatitude?: number | null;
    checkInLongitude?: number | null;
    checkOutLatitude?: number | null;
    checkOutLongitude?: number | null;
    checkInIpAddress?: string | null;
    checkOutIpAddress?: string | null;
    checkInDeviceInfo?: string | null;
    checkOutDeviceInfo?: string | null;
    totalHours?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    checkInLocationName?: string | null;
    checkOutLocationName?: string | null;
    projectId?: string | null;
    taskId?: string | null;
    autoCheckout?: boolean;
  };

  export type AttendanceCreateOrConnectWithoutCorrectionRequestsInput = {
    where: AttendanceWhereUniqueInput;
    create: XOR<
      AttendanceCreateWithoutCorrectionRequestsInput,
      AttendanceUncheckedCreateWithoutCorrectionRequestsInput
    >;
  };

  export type UserCreateWithoutCorrectionRequestsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    activities?: ActivityCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsCreateNestedOneWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    projects?: ProjectCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutCorrectionRequestsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsUncheckedCreateNestedOneWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutCorrectionRequestsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCorrectionRequestsInput,
      UserUncheckedCreateWithoutCorrectionRequestsInput
    >;
  };

  export type AttendanceUpsertWithoutCorrectionRequestsInput = {
    update: XOR<
      AttendanceUpdateWithoutCorrectionRequestsInput,
      AttendanceUncheckedUpdateWithoutCorrectionRequestsInput
    >;
    create: XOR<
      AttendanceCreateWithoutCorrectionRequestsInput,
      AttendanceUncheckedCreateWithoutCorrectionRequestsInput
    >;
    where?: AttendanceWhereInput;
  };

  export type AttendanceUpdateToOneWithWhereWithoutCorrectionRequestsInput = {
    where?: AttendanceWhereInput;
    data: XOR<
      AttendanceUpdateWithoutCorrectionRequestsInput,
      AttendanceUncheckedUpdateWithoutCorrectionRequestsInput
    >;
  };

  export type AttendanceUpdateWithoutCorrectionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    checkInLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkInDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkInLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckout?: BoolFieldUpdateOperationsInput | boolean;
    project?: ProjectUpdateOneWithoutAttendancesNestedInput;
    task?: TaskUpdateOneWithoutAttendancesNestedInput;
    user?: UserUpdateOneRequiredWithoutAttendanceRecordsNestedInput;
  };

  export type AttendanceUncheckedUpdateWithoutCorrectionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    checkInLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkInDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkInLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    projectId?: NullableStringFieldUpdateOperationsInput | string | null;
    taskId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckout?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type UserUpsertWithoutCorrectionRequestsInput = {
    update: XOR<
      UserUpdateWithoutCorrectionRequestsInput,
      UserUncheckedUpdateWithoutCorrectionRequestsInput
    >;
    create: XOR<
      UserCreateWithoutCorrectionRequestsInput,
      UserUncheckedCreateWithoutCorrectionRequestsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCorrectionRequestsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutCorrectionRequestsInput,
      UserUncheckedUpdateWithoutCorrectionRequestsInput
    >;
  };

  export type UserUpdateWithoutCorrectionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    activities?: ActivityUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUpdateOneWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    projects?: ProjectUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutCorrectionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUncheckedUpdateOneWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    projects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type TaskCreateWithoutCommentsInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceCreateNestedManyWithoutTaskInput;
    parent?: TaskCreateNestedOneWithoutSubtasksInput;
    subtasks?: TaskCreateNestedManyWithoutParentInput;
    project: ProjectCreateNestedOneWithoutTasksInput;
    status?: ProjectStatusCreateNestedOneWithoutTasksInput;
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput;
  };

  export type TaskUncheckedCreateWithoutCommentsInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    projectId: string;
    parentId?: string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    statusId?: string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityUncheckedCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTaskInput;
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentInput;
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput;
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput;
  };

  export type TaskCreateOrConnectWithoutCommentsInput = {
    where: TaskWhereUniqueInput;
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>;
  };

  export type UserCreateWithoutCommentsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    activities?: ActivityCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsCreateNestedOneWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    projects?: ProjectCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsUncheckedCreateNestedOneWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput;
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>;
  };

  export type TaskUpsertWithoutCommentsInput = {
    update: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>;
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>;
    where?: TaskWhereInput;
  };

  export type TaskUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TaskWhereInput;
    data: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>;
  };

  export type TaskUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUpdateManyWithoutTaskNestedInput;
    parent?: TaskUpdateOneWithoutSubtasksNestedInput;
    subtasks?: TaskUpdateManyWithoutParentNestedInput;
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput;
    status?: ProjectStatusUpdateOneWithoutTasksNestedInput;
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput;
  };

  export type TaskUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    projectId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    statusId?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUncheckedUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUncheckedUpdateManyWithoutTaskNestedInput;
    subtasks?: TaskUncheckedUpdateManyWithoutParentNestedInput;
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput;
  };

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>;
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>;
  };

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    activities?: ActivityUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUpdateOneWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    projects?: ProjectUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUncheckedUpdateOneWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    projects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput;
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type TaskCreateWithoutAttachmentsInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceCreateNestedManyWithoutTaskInput;
    comments?: CommentCreateNestedManyWithoutTaskInput;
    parent?: TaskCreateNestedOneWithoutSubtasksInput;
    subtasks?: TaskCreateNestedManyWithoutParentInput;
    project: ProjectCreateNestedOneWithoutTasksInput;
    status?: ProjectStatusCreateNestedOneWithoutTasksInput;
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput;
  };

  export type TaskUncheckedCreateWithoutAttachmentsInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    projectId: string;
    parentId?: string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    statusId?: string | null;
    timeSpent?: number | null;
    completed?: boolean;
    activities?: ActivityUncheckedCreateNestedManyWithoutTaskInput;
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTaskInput;
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput;
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentInput;
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput;
  };

  export type TaskCreateOrConnectWithoutAttachmentsInput = {
    where: TaskWhereUniqueInput;
    create: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>;
  };

  export type UserCreateWithoutTaskAttachmentsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    activities?: ActivityCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsCreateNestedOneWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    projects?: ProjectCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutTaskAttachmentsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    role?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    bio?: string | null;
    department?: string | null;
    jobTitle?: string | null;
    location?: string | null;
    phone?: string | null;
    skills?: string | null;
    active?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput;
    attendanceRecords?: AttendanceUncheckedCreateNestedManyWithoutUserInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedCreateNestedManyWithoutUserInput;
    attendanceSettings?: AttendanceSettingsUncheckedCreateNestedOneWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutTaskAttachmentsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTaskAttachmentsInput,
      UserUncheckedCreateWithoutTaskAttachmentsInput
    >;
  };

  export type TaskUpsertWithoutAttachmentsInput = {
    update: XOR<TaskUpdateWithoutAttachmentsInput, TaskUncheckedUpdateWithoutAttachmentsInput>;
    create: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>;
    where?: TaskWhereInput;
  };

  export type TaskUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: TaskWhereInput;
    data: XOR<TaskUpdateWithoutAttachmentsInput, TaskUncheckedUpdateWithoutAttachmentsInput>;
  };

  export type TaskUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUpdateManyWithoutTaskNestedInput;
    comments?: CommentUpdateManyWithoutTaskNestedInput;
    parent?: TaskUpdateOneWithoutSubtasksNestedInput;
    subtasks?: TaskUpdateManyWithoutParentNestedInput;
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput;
    status?: ProjectStatusUpdateOneWithoutTasksNestedInput;
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput;
  };

  export type TaskUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    projectId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    statusId?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUncheckedUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUncheckedUpdateManyWithoutTaskNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput;
    subtasks?: TaskUncheckedUpdateManyWithoutParentNestedInput;
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput;
  };

  export type UserUpsertWithoutTaskAttachmentsInput = {
    update: XOR<
      UserUpdateWithoutTaskAttachmentsInput,
      UserUncheckedUpdateWithoutTaskAttachmentsInput
    >;
    create: XOR<
      UserCreateWithoutTaskAttachmentsInput,
      UserUncheckedCreateWithoutTaskAttachmentsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutTaskAttachmentsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutTaskAttachmentsInput,
      UserUncheckedUpdateWithoutTaskAttachmentsInput
    >;
  };

  export type UserUpdateWithoutTaskAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    activities?: ActivityUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUpdateOneWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    projects?: ProjectUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutTaskAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput;
    attendanceRecords?: AttendanceUncheckedUpdateManyWithoutUserNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutUserNestedInput;
    attendanceSettings?: AttendanceSettingsUncheckedUpdateOneWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    projects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type RolePermissionCreateWithoutRoleInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    permission: PermissionCreateNestedOneWithoutRolesInput;
  };

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: string;
    permissionId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput;
    create: XOR<
      RolePermissionCreateWithoutRoleInput,
      RolePermissionUncheckedCreateWithoutRoleInput
    >;
  };

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[];
    skipDuplicates?: boolean;
  };

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput;
    update: XOR<
      RolePermissionUpdateWithoutRoleInput,
      RolePermissionUncheckedUpdateWithoutRoleInput
    >;
    create: XOR<
      RolePermissionCreateWithoutRoleInput,
      RolePermissionUncheckedCreateWithoutRoleInput
    >;
  };

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput;
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>;
  };

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput;
    data: XOR<
      RolePermissionUpdateManyMutationInput,
      RolePermissionUncheckedUpdateManyWithoutRoleInput
    >;
  };

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[];
    OR?: RolePermissionScalarWhereInput[];
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[];
    id?: StringFilter<'RolePermission'> | string;
    roleId?: StringFilter<'RolePermission'> | string;
    permissionId?: StringFilter<'RolePermission'> | string;
    createdAt?: DateTimeFilter<'RolePermission'> | Date | string;
    updatedAt?: DateTimeFilter<'RolePermission'> | Date | string;
  };

  export type RolePermissionCreateWithoutPermissionInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role: RoleCreateNestedOneWithoutPermissionsInput;
  };

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string;
    roleId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput;
    create: XOR<
      RolePermissionCreateWithoutPermissionInput,
      RolePermissionUncheckedCreateWithoutPermissionInput
    >;
  };

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[];
    skipDuplicates?: boolean;
  };

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput;
    update: XOR<
      RolePermissionUpdateWithoutPermissionInput,
      RolePermissionUncheckedUpdateWithoutPermissionInput
    >;
    create: XOR<
      RolePermissionCreateWithoutPermissionInput,
      RolePermissionUncheckedCreateWithoutPermissionInput
    >;
  };

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput;
    data: XOR<
      RolePermissionUpdateWithoutPermissionInput,
      RolePermissionUncheckedUpdateWithoutPermissionInput
    >;
  };

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput;
    data: XOR<
      RolePermissionUpdateManyMutationInput,
      RolePermissionUncheckedUpdateManyWithoutPermissionInput
    >;
  };

  export type PermissionCreateWithoutRolesInput = {
    id?: string;
    name: string;
    description?: string | null;
    category?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id?: string;
    name: string;
    description?: string | null;
    category?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput;
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>;
  };

  export type RoleCreateWithoutPermissionsInput = {
    id?: string;
    name: string;
    description?: string | null;
    color?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: string;
    name: string;
    description?: string | null;
    color?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput;
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>;
  };

  export type PermissionUpsertWithoutRolesInput = {
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>;
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>;
    where?: PermissionWhereInput;
  };

  export type PermissionUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermissionWhereInput;
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>;
  };

  export type PermissionUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>;
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>;
    where?: RoleWhereInput;
  };

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput;
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>;
  };

  export type RoleUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AccountCreateManyUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type ActivityCreateManyUserInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    description?: string | null;
    projectId?: string | null;
    taskId?: string | null;
    createdAt?: Date | string;
  };

  export type AttendanceCreateManyUserInput = {
    id?: string;
    checkInTime?: Date | string;
    checkOutTime?: Date | string | null;
    checkInLatitude?: number | null;
    checkInLongitude?: number | null;
    checkOutLatitude?: number | null;
    checkOutLongitude?: number | null;
    checkInIpAddress?: string | null;
    checkOutIpAddress?: string | null;
    checkInDeviceInfo?: string | null;
    checkOutDeviceInfo?: string | null;
    totalHours?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    checkInLocationName?: string | null;
    checkOutLocationName?: string | null;
    projectId?: string | null;
    taskId?: string | null;
    autoCheckout?: boolean;
  };

  export type AttendanceCorrectionRequestCreateManyUserInput = {
    id?: string;
    attendanceId: string;
    originalCheckInTime: Date | string;
    originalCheckOutTime?: Date | string | null;
    requestedCheckInTime: Date | string;
    requestedCheckOutTime?: Date | string | null;
    reason: string;
    status?: string;
    reviewedBy?: string | null;
    reviewedAt?: Date | string | null;
    reviewNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CommentCreateManyUserInput = {
    id?: string;
    content: string;
    taskId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DocumentCreateManyUserInput = {
    id?: string;
    name: string;
    description?: string | null;
    fileType: string;
    fileSize: number;
    filePath: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProjectCreateManyCreatedByInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dueDate?: Date | string | null;
    estimatedTime?: number | null;
    totalTimeSpent?: number | null;
  };

  export type SessionCreateManyUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type TaskAssigneeCreateManyUserInput = {
    id?: string;
    taskId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TaskAttachmentCreateManyUserInput = {
    id?: string;
    filename: string;
    fileUrl: string;
    fileSize: number;
    fileType: string;
    taskId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamMemberCreateManyUserInput = {
    id?: string;
    projectId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    project?: ProjectUpdateOneWithoutActivitiesNestedInput;
    task?: TaskUpdateOneWithoutActivitiesNestedInput;
  };

  export type ActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    projectId?: NullableStringFieldUpdateOperationsInput | string | null;
    taskId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    projectId?: NullableStringFieldUpdateOperationsInput | string | null;
    taskId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AttendanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    checkInLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkInDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkInLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckout?: BoolFieldUpdateOperationsInput | boolean;
    project?: ProjectUpdateOneWithoutAttendancesNestedInput;
    task?: TaskUpdateOneWithoutAttendancesNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutAttendanceNestedInput;
  };

  export type AttendanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    checkInLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkInDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkInLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    projectId?: NullableStringFieldUpdateOperationsInput | string | null;
    taskId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckout?: BoolFieldUpdateOperationsInput | boolean;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutAttendanceNestedInput;
  };

  export type AttendanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    checkInLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkInDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkInLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    projectId?: NullableStringFieldUpdateOperationsInput | string | null;
    taskId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckout?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type AttendanceCorrectionRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    originalCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    originalCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requestedCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    requestedCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    attendance?: AttendanceUpdateOneRequiredWithoutCorrectionRequestsNestedInput;
  };

  export type AttendanceCorrectionRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attendanceId?: StringFieldUpdateOperationsInput | string;
    originalCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    originalCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requestedCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    requestedCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AttendanceCorrectionRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attendanceId?: StringFieldUpdateOperationsInput | string;
    originalCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    originalCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requestedCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    requestedCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput;
  };

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    taskId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    taskId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    fileType?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    filePath?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    fileType?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    filePath?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    fileType?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    filePath?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProjectUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    activities?: ActivityUpdateManyWithoutProjectNestedInput;
    attendances?: AttendanceUpdateManyWithoutProjectNestedInput;
    events?: EventUpdateManyWithoutProjectNestedInput;
    statuses?: ProjectStatusUpdateManyWithoutProjectNestedInput;
    tasks?: TaskUpdateManyWithoutProjectNestedInput;
    teamMembers?: TeamMemberUpdateManyWithoutProjectNestedInput;
  };

  export type ProjectUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput;
    attendances?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput;
    events?: EventUncheckedUpdateManyWithoutProjectNestedInput;
    statuses?: ProjectStatusUncheckedUpdateManyWithoutProjectNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput;
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutProjectNestedInput;
  };

  export type ProjectUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalTimeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
  };

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TaskAssigneeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    task?: TaskUpdateOneRequiredWithoutAssigneesNestedInput;
  };

  export type TaskAssigneeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    taskId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TaskAssigneeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    taskId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TaskAttachmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    task?: TaskUpdateOneRequiredWithoutAttachmentsNestedInput;
  };

  export type TaskAttachmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    taskId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TaskAttachmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    taskId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    project?: ProjectUpdateOneRequiredWithoutTeamMembersNestedInput;
  };

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    projectId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    projectId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ActivityCreateManyProjectInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    description?: string | null;
    userId: string;
    taskId?: string | null;
    createdAt?: Date | string;
  };

  export type AttendanceCreateManyProjectInput = {
    id?: string;
    userId: string;
    checkInTime?: Date | string;
    checkOutTime?: Date | string | null;
    checkInLatitude?: number | null;
    checkInLongitude?: number | null;
    checkOutLatitude?: number | null;
    checkOutLongitude?: number | null;
    checkInIpAddress?: string | null;
    checkOutIpAddress?: string | null;
    checkInDeviceInfo?: string | null;
    checkOutDeviceInfo?: string | null;
    totalHours?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    checkInLocationName?: string | null;
    checkOutLocationName?: string | null;
    taskId?: string | null;
    autoCheckout?: boolean;
  };

  export type EventCreateManyProjectInput = {
    id?: string;
    title: string;
    description?: string | null;
    date: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProjectStatusCreateManyProjectInput = {
    id?: string;
    name: string;
    color?: string | null;
    description?: string | null;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    order?: number;
    isCompletedStatus?: boolean;
  };

  export type TaskCreateManyProjectInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    parentId?: string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    statusId?: string | null;
    timeSpent?: number | null;
    completed?: boolean;
  };

  export type TeamMemberCreateManyProjectInput = {
    id?: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ActivityUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    task?: TaskUpdateOneWithoutActivitiesNestedInput;
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput;
  };

  export type ActivityUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
    taskId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ActivityUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
    taskId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AttendanceUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    checkInLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkInDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkInLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckout?: BoolFieldUpdateOperationsInput | boolean;
    task?: TaskUpdateOneWithoutAttendancesNestedInput;
    user?: UserUpdateOneRequiredWithoutAttendanceRecordsNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutAttendanceNestedInput;
  };

  export type AttendanceUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    checkInLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkInDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkInLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    taskId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckout?: BoolFieldUpdateOperationsInput | boolean;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutAttendanceNestedInput;
  };

  export type AttendanceUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    checkInLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkInDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkInLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    taskId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckout?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type EventUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProjectStatusUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: IntFieldUpdateOperationsInput | number;
    isCompletedStatus?: BoolFieldUpdateOperationsInput | boolean;
    tasks?: TaskUpdateManyWithoutStatusNestedInput;
  };

  export type ProjectStatusUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: IntFieldUpdateOperationsInput | number;
    isCompletedStatus?: BoolFieldUpdateOperationsInput | boolean;
    tasks?: TaskUncheckedUpdateManyWithoutStatusNestedInput;
  };

  export type ProjectStatusUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: IntFieldUpdateOperationsInput | number;
    isCompletedStatus?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type TaskUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUpdateManyWithoutTaskNestedInput;
    comments?: CommentUpdateManyWithoutTaskNestedInput;
    parent?: TaskUpdateOneWithoutSubtasksNestedInput;
    subtasks?: TaskUpdateManyWithoutParentNestedInput;
    status?: ProjectStatusUpdateOneWithoutTasksNestedInput;
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput;
  };

  export type TaskUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    statusId?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUncheckedUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUncheckedUpdateManyWithoutTaskNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput;
    subtasks?: TaskUncheckedUpdateManyWithoutParentNestedInput;
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput;
  };

  export type TaskUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    statusId?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type TeamMemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutTeamsNestedInput;
  };

  export type TeamMemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TaskCreateManyStatusInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    projectId: string;
    parentId?: string | null;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    timeSpent?: number | null;
    completed?: boolean;
  };

  export type TaskUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUpdateManyWithoutTaskNestedInput;
    comments?: CommentUpdateManyWithoutTaskNestedInput;
    parent?: TaskUpdateOneWithoutSubtasksNestedInput;
    subtasks?: TaskUpdateManyWithoutParentNestedInput;
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput;
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput;
  };

  export type TaskUncheckedUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    projectId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUncheckedUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUncheckedUpdateManyWithoutTaskNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput;
    subtasks?: TaskUncheckedUpdateManyWithoutParentNestedInput;
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput;
  };

  export type TaskUncheckedUpdateManyWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    projectId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type ActivityCreateManyTaskInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    description?: string | null;
    userId: string;
    projectId?: string | null;
    createdAt?: Date | string;
  };

  export type AttendanceCreateManyTaskInput = {
    id?: string;
    userId: string;
    checkInTime?: Date | string;
    checkOutTime?: Date | string | null;
    checkInLatitude?: number | null;
    checkInLongitude?: number | null;
    checkOutLatitude?: number | null;
    checkOutLongitude?: number | null;
    checkInIpAddress?: string | null;
    checkOutIpAddress?: string | null;
    checkInDeviceInfo?: string | null;
    checkOutDeviceInfo?: string | null;
    totalHours?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    checkInLocationName?: string | null;
    checkOutLocationName?: string | null;
    projectId?: string | null;
    autoCheckout?: boolean;
  };

  export type CommentCreateManyTaskInput = {
    id?: string;
    content: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TaskCreateManyParentInput = {
    id?: string;
    title: string;
    description?: string | null;
    priority?: string;
    dueDate?: Date | string | null;
    projectId: string;
    order?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: Date | string | null;
    estimatedTime?: number | null;
    startDate?: Date | string | null;
    statusId?: string | null;
    timeSpent?: number | null;
    completed?: boolean;
  };

  export type TaskAssigneeCreateManyTaskInput = {
    id?: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TaskAttachmentCreateManyTaskInput = {
    id?: string;
    filename: string;
    fileUrl: string;
    fileSize: number;
    fileType: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ActivityUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    project?: ProjectUpdateOneWithoutActivitiesNestedInput;
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput;
  };

  export type ActivityUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
    projectId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ActivityUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
    projectId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AttendanceUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string;
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    checkInLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkInDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkInLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckout?: BoolFieldUpdateOperationsInput | boolean;
    project?: ProjectUpdateOneWithoutAttendancesNestedInput;
    user?: UserUpdateOneRequiredWithoutAttendanceRecordsNestedInput;
    correctionRequests?: AttendanceCorrectionRequestUpdateManyWithoutAttendanceNestedInput;
  };

  export type AttendanceUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    checkInLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkInDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkInLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    projectId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckout?: BoolFieldUpdateOperationsInput | boolean;
    correctionRequests?: AttendanceCorrectionRequestUncheckedUpdateManyWithoutAttendanceNestedInput;
  };

  export type AttendanceUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    checkInLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkOutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null;
    checkInIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutIpAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    checkInDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutDeviceInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    checkInLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    checkOutLocationName?: NullableStringFieldUpdateOperationsInput | string | null;
    projectId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoCheckout?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type CommentUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput;
  };

  export type CommentUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TaskUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUpdateManyWithoutTaskNestedInput;
    comments?: CommentUpdateManyWithoutTaskNestedInput;
    subtasks?: TaskUpdateManyWithoutParentNestedInput;
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput;
    status?: ProjectStatusUpdateOneWithoutTasksNestedInput;
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput;
  };

  export type TaskUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    projectId?: StringFieldUpdateOperationsInput | string;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    statusId?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    activities?: ActivityUncheckedUpdateManyWithoutTaskNestedInput;
    attendances?: AttendanceUncheckedUpdateManyWithoutTaskNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput;
    subtasks?: TaskUncheckedUpdateManyWithoutParentNestedInput;
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput;
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput;
  };

  export type TaskUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: StringFieldUpdateOperationsInput | string;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    projectId?: StringFieldUpdateOperationsInput | string;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    statusId?: NullableStringFieldUpdateOperationsInput | string | null;
    timeSpent?: NullableFloatFieldUpdateOperationsInput | number | null;
    completed?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type TaskAssigneeUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutTaskAssignmentsNestedInput;
  };

  export type TaskAssigneeUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TaskAssigneeUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TaskAttachmentUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutTaskAttachmentsNestedInput;
  };

  export type TaskAttachmentUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TaskAttachmentUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AttendanceCorrectionRequestCreateManyAttendanceInput = {
    id?: string;
    userId: string;
    originalCheckInTime: Date | string;
    originalCheckOutTime?: Date | string | null;
    requestedCheckInTime: Date | string;
    requestedCheckOutTime?: Date | string | null;
    reason: string;
    status?: string;
    reviewedBy?: string | null;
    reviewedAt?: Date | string | null;
    reviewNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AttendanceCorrectionRequestUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    originalCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    originalCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requestedCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    requestedCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutCorrectionRequestsNestedInput;
  };

  export type AttendanceCorrectionRequestUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    originalCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    originalCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requestedCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    requestedCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AttendanceCorrectionRequestUncheckedUpdateManyWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    originalCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    originalCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requestedCheckInTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    requestedCheckOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RolePermissionCreateManyRoleInput = {
    id?: string;
    permissionId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RolePermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput;
  };

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permissionId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permissionId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RolePermissionCreateManyPermissionInput = {
    id?: string;
    roleId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RolePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput;
  };

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
